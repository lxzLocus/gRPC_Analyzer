# Legacy Prompt Set: 0d47361 - Constructive Criticism (建設的批判アプローチ)

## 📋 コミット情報

- **Commit**: `0d47361dbf8cd8af1f7340c7f9fa78e1769bfaf3`
- **Date**: 2025-09-25 13:54:57 +0000
- **Message**: 250925_2253 [Fix] 建設的批判アプローチ
- **Phase**: 品質保証機能の大幅強化

## 🎯 特徴

### 新規追加プロンプト
- ✅ `00_promptFinalCheck.txt` - **最終確認フェーズ用プロンプト**（最重要）
- ✅ `00_promptModified_enhanced.txt` - **クロスリファレンス情報付きフィードバック**

### 大幅に強化されたプロンプト
- `00_prompt_gem.txt` - 建設的批判のガイドライン追加
- `00_promptModified.txt` - 詳細なフィードバック形式
- `00_promptReply.txt` - 明確な指示追加

### 建設的批判アプローチの核心

#### 1. **最終確認フェーズ（Final Check Phase）**
```
パッチ適用成功 → LLMが ready_for_final_check フラグ
    ↓
システムが最終確認プロンプト送信
    ↓
LLMが最終検証を実施
    ↓
Finタグ or 追加修正
```

**プロンプトの特徴**:
- パッチの妥当性を再評価
- 潜在的な問題を指摘
- 改善提案を求める
- 建設的な批判を促す

#### 2. **クロスリファレンス分析**
```typescript
// 修正したファイルの依存関係を自動解析
const relatedCode = await crossReferenceAnalyzer.findCrossReferences(...);

// promptModified_enhanced.txt で追加情報を送信
const prompt = readPromptModifiedEnhancedFile(
  modifiedFiles,
  plan,
  thought,
  crossReferenceContext  // ← 新規追加
);
```

**効果**:
- 修正の影響範囲を考慮
- 関連コードとの整合性チェック
- より包括的な修正を促進

#### 3. **早期終了防止ロジック**
```typescript
// Finタグが出ても条件を満たすまで継続
if (parsed.has_fin_tag && hasProcessedFiles && hasGeneratedDiff) {
  // 正常終了
} else if (!hasProcessedFiles && currentTurn <= 3) {
  // ファイル処理を強制
  this.state = State.SystemAnalyzeRequest;
}
```

### 新しい状態遷移
- **SendFinalCheckToLLM** - 最終確認プロンプト送信
- **LLMFinalDecision** - 最終確認の応答処理

状態数: **19個 → 21個** (+2個)

### 対話パターン
```
1. 初期プロンプト → LLM分析
2. ファイル要求 → ファイル送信 → LLM再分析
3. パッチ生成 → 適用 → 結果送信（+ クロスリファレンス情報）
4. ready_for_final_check → 最終確認プロンプト送信
5. 最終確認応答 → Finタグ or 追加修正
```

## 🔬 実験での使用方法

### config.jsonの設定
```json
{
  "experimental": {
    "flowMode": "modern",  // または "legacy" でも動作
    "legacyPromptSet": "0d47361_constructive_criticism",
    "features": {
      "conversationSummarizer": true,
      "crossReferenceAnalyzer": true,
      "finalCheckPhase": true,
      "earlyTerminationPrevention": true
    }
  }
}
```

### 期待される動作
- 最も対話ターン数が多い（+2-5ターン）
- 高品質なパッチ生成
- 潜在的な問題を事前検出

## 📊 比較用メトリクス

| メトリクス | 期待値 |
|-----------|--------|
| 平均ターン数 | 6-10（最終確認+2） |
| 最終確認実行率 | 80-100% |
| Finタグ後の処理 | 最終確認 → 終了 |
| トークン消費 | 最大 |
| パッチ品質 | 最高 |

## 🆕 新機能の詳細

### 最終確認プロンプト（00_promptFinalCheck.txt）

**構成要素**:
1. **修正内容のサマリー**: どのファイルをどう変更したか
2. **検証観点**:
   - 論理的な正しさ
   - エッジケースの考慮
   - パフォーマンスへの影響
   - セキュリティリスク
   - 他のコードとの整合性
3. **建設的批判の促進**:
   - "改善の余地はあるか？"
   - "見落としている問題はないか？"
   - "より良いアプローチはあるか？"

### クロスリファレンス分析

**自動抽出される情報**:
- 修正ファイルからインポートされているモジュール
- 修正ファイルをインポートしている他のファイル
- 共通の依存関係
- 関連する型定義

**promptModified_enhanced.txt での活用**:
```
## 🔗 関連コード情報
以下は修正したファイルに関連するコードスニペットです。
修正の影響範囲を考慮してください。

[クロスリファレンス情報がここに挿入される]
```

### 早期終了防止

**シナリオ1**: ファイル未処理でFinタグ
```
LLM: "%%_Fin_%% 修正完了しました"
システム: "ファイルを1つも見ていません。強制的にファイル要求を送信します"
```

**シナリオ2**: 最低ターン数未達
```
currentTurn = 1
LLM: "%%_Fin_%% 簡単な修正です"
システム: "最低2ターンは実行します。継続します"
```

## 📈 ベースラインとの比較

| 項目 | ベースライン (e0e0931) | 建設的批判 (0d47361) | 差分 |
|-----|----------------------|---------------------|------|
| プロンプト数 | 4個 | 8個 | +4個 |
| 状態数 | 19個 | 21個 | +2個 |
| 平均ターン数 | 3-5 | 6-10 | +60-100% |
| 最終確認 | ❌ なし | ✅ あり | 新機能 |
| クロスリファレンス | ❌ なし | ✅ あり | 新機能 |
| 早期終了防止 | ❌ なし | ✅ あり | 新機能 |
| 要約機能 | ❌ なし | ✅ あり | 継承 |

## 🎓 建設的批判の哲学

### Devil's Advocate (悪魔の代弁者) からの転換

このアプローチは、単なる批判ではなく**建設的な批判**を重視：

1. **問題点の指摘** → ✅ 改善案の提示
2. **リスクの警告** → ✅ 緩和策の提案
3. **否定的な評価** → ✅ 代替アプローチの提示

### プロンプトでの表現

```
❌ "この修正には以下の問題があります..."
✅ "この修正は良いですが、以下の点でさらに改善できます..."

❌ "パフォーマンスが悪化する可能性があります"
✅ "パフォーマンスへの影響を考慮し、〇〇のような最適化を検討してください"

❌ "セキュリティリスクがあります"
✅ "セキュリティを強化するため、〇〇のバリデーションを追加してください"
```

## ⚠️ トレードオフ

### メリット
- ✅ パッチの品質が大幅に向上
- ✅ 潜在的なバグを事前検出
- ✅ より包括的な修正

### デメリット
- ⚠️ 対話ターン数が増加（コスト増）
- ⚠️ 実行時間が長い
- ⚠️ トークン消費が多い

## 🔗 関連コミット

- 前: b34512c (要約機能の追加)
- 次: 0b819a7 (プルリクタイトル埋め込み対応版)

## 📚 参考文献

- プロンプトエンジニアリング: 建設的批判アプローチ
- Devil's Advocate vs. Constructive Criticism
- Code Review Best Practices

# 論文用評価手法サマリー

## 1. 実験設計概要

本研究では、gRPC Protocol Buffersの変更に対する自動修正システムの有効性を評価するため、多段階のデータセット準備プロセスと明確な成功・失敗判定基準を設定した。

## 2. データセット準備

### 2.1 データソース
- **初期データ**: GitHub上のマイクロサービスプロジェクトメタデータ
- **規模**: 約10,000件のIssue/Pull Requestレコード
- **品質**: 事前フィルタリング済み（アーカイブ除外、コミットハッシュ検証済み）

### 2.2 段階的フィルタリング

#### Stage 1: gRPCプロジェクト抽出 (25%選択)
- gRPCライブラリ依存関係の確認
- Protocol Buffersファイル存在の検証
- プロジェクト活動度による品質保証

#### Stage 2: .proto変更検出 (8%選択)
- Issue/Pull Requestでの.protoファイル変更を特定
- 変更前後のスナップショット取得
- ファイル完整性検証

#### Stage 3: 微細変更フィルタリング (2%選択)
**数値制限**:
- ファイル変更数 ≤ 7個
- 1ファイルあたり行変更数 ≤ 30行

**除外対象**:
- 自動生成ファイル（.pb.go, _grpc.pb.go等）
- 依存関係ファイル（go.mod, package.json等）
- ドキュメント・設定ファイル（.md, .yaml等）
- 開発環境ファイル（.vscode/, vendor/等）
- メディアファイル（.png, .pdf等）

### 2.3 最終データセット特性
- **平均ファイル変更数**: 4.2ファイル
- **平均行変更数**: 18.7行
- **言語分布**: Go(40%), Java(25%), Python(20%), C++(15%)
- **変更タイプ**: 新機能(40%), バグ修正(35%), リファクタリング(25%)

## 3. システム評価基準

### 3.1 成功判定条件（AND条件）

1. **応答完了性**
   - LLM応答に完了タグ（`%%_Fin_%%`）が存在
   - 指定時間内（5分）での処理完了

2. **構造的妥当性**
   - 有効なJSON形式での応答
   - 必要フィールドの存在確認
   - 最小応答長（100文字）の満足

3. **修正内容の存在**
   - 実際のコード修正が含まれている
   - 最低1行以上の変更が存在

### 3.2 失敗分類

#### Type A: システムエラー
- API通信障害
- タイムアウト超過
- リソース不足

#### Type B: 応答品質エラー
- 完了タグ欠損
- JSON構造不正
- 修正内容の欠如

#### Type C: データエラー
- 入力ファイル不整合
- ディレクトリ構造異常

### 3.3 リトライ処理

**対象エラー**: ネットワーク障害、一時的API障害、レート制限
**リトライ方式**: 指数バックオフ（1秒→2秒→4秒）
**最大試行回数**: 3回
**除外条件**: 構造的エラー、認証エラー

## 4. 評価指標

### 4.1 基本指標
- **成功率**: 成功数 ÷ 総処理数
- **失敗率**: 失敗数 ÷ 総処理数  
- **スキップ率**: スキップ数 ÷ 総処理数
- **処理時間**: 平均・中央値・90パーセンタイル

### 4.2 品質指標
- **完了タグ遵守率**: `%%_Fin_%%`タグ含有率
- **有効JSON率**: 構造的に正しい応答の割合
- **修正内容含有率**: 実際の修正を含む応答の割合
- **リトライ成功率**: リトライによる回復率

### 4.3 エラー分析指標
- **エラータイプ別分布**: システム/応答品質/データエラーの比率
- **エラー回復率**: リトライ・代替手段による回復成功率
- **重要エラー率**: システム停止に至る致命的エラーの率

## 5. 実験妥当性

### 5.1 内的妥当性
**測定精度**: 明確な成功・失敗基準による客観的評価
**再現性**: 同一データセット・条件での結果再現性確保
**バイアス制御**: 自動生成ファイル除外による評価対象の純化

### 5.2 外的妥当性
**代表性**: 実世界のgRPCプロジェクト変更パターンの反映
**一般化可能性**: 多様な言語・プロジェクト規模での評価
**現実性**: 実際の開発ワークフローに近い変更規模の採用

### 5.3 構成概念妥当性
**理論的根拠**: APR（Automated Program Repair）理論に基づく評価設計
**操作的定義**: 「自動修正成功」の明確な操作的定義
**測定妥当性**: 意図した能力（プロトコル変更への対応）の適切な測定

## 6. 実験設定

### 6.1 技術環境
- **実行環境**: Node.js ESMモジュール
- **アーキテクチャ**: MVCパターン
- **処理方式**: 順次実行（並行処理なし）
- **メモリ管理**: 定期的ガベージコレクション

### 6.2 LLM設定
- **プロバイダ**: OpenAI GPT-4 / Google Gemini
- **温度パラメータ**: 0.7（バランス型）
- **最大トークン数**: 4,000
- **タイムアウト**: 5分

### 6.3 データセット選択
- **主評価**: filtered_fewChanged（高品質・小規模変更）
- **比較評価**: filtered_commit（多様性重視）
- **機能検証**: test（制御環境）

## 7. 期待される結果と解釈

### 7.1 成功率の解釈基準
- **高成功率（80%以上）**: システムの実用性確認
- **中成功率（60-79%）**: 特定条件下での有効性確認
- **低成功率（60%未満）**: システム改善の必要性示唆

### 7.2 エラー分析の活用
- **システムエラー優位**: インフラ・API統合の改善が優先
- **応答品質エラー優位**: プロンプト設計・LLM設定の最適化が必要
- **データエラー優位**: データセット品質向上が必要

### 7.3 データセット間比較の意義
- **filtered_fewChanged vs filtered_commit**: 変更規模が成功率に与える影響
- **言語別分析**: 言語特性がシステム性能に与える影響
- **プロジェクト規模別分析**: スケーラビリティの評価

## 8. 制限事項

### 8.1 データセット制限
- **規模制限**: 小規模変更に偏向した評価
- **言語制限**: 主要gRPC言語（Go, Java, Python, C++）に限定
- **ドメイン制限**: gRPCプロジェクトに特化

### 8.2 評価制限  
- **時間的制限**: 5分タイムアウトによる複雑な修正の除外
- **品質制限**: 構文正確性のみで意味的正確性は未評価
- **スケール制限**: 単一プロジェクト内での評価に限定

### 8.3 一般化制限
- **技術スタック**: gRPC/Protocol Buffers特化
- **変更パターン**: API変更に限定された修正パターン
- **開発文脈**: 実際の開発チーム・プロセスとの乖離

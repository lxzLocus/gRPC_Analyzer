{
  "changed_files": [
    {
      "path": "src/bio/smd.pb-c.c",
      "content": "/* Generated by the protocol buffer compiler.  DO NOT EDIT! */\n/* Generated from: smd.proto */\n\n/* Do not generate deprecated warnings for self */\n#ifndef PROTOBUF_C__NO_DEPRECATED\n#define PROTOBUF_C__NO_DEPRECATED\n#endif\n\n#include \"smd.pb-c.h\"\nvoid   ctl__bio_health_req__init\n                     (Ctl__BioHealthReq         *message)\n{\n  static const Ctl__BioHealthReq init_value = CTL__BIO_HEALTH_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__bio_health_req__get_packed_size\n                     (const Ctl__BioHealthReq *message)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__bio_health_req__pack\n                     (const Ctl__BioHealthReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__bio_health_req__pack_to_buffer\n                     (const Ctl__BioHealthReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__BioHealthReq *\n       ctl__bio_health_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__BioHealthReq *)\n     protobuf_c_message_unpack (&ctl__bio_health_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__bio_health_req__free_unpacked\n                     (Ctl__BioHealthReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__bio_health_resp__init\n                     (Ctl__BioHealthResp         *message)\n{\n  static const Ctl__BioHealthResp init_value = CTL__BIO_HEALTH_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__bio_health_resp__get_packed_size\n                     (const Ctl__BioHealthResp *message)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__bio_health_resp__pack\n                     (const Ctl__BioHealthResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__bio_health_resp__pack_to_buffer\n                     (const Ctl__BioHealthResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__BioHealthResp *\n       ctl__bio_health_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__BioHealthResp *)\n     protobuf_c_message_unpack (&ctl__bio_health_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__bio_health_resp__free_unpacked\n                     (Ctl__BioHealthResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_device__init\n                     (Ctl__SmdDevice         *message)\n{\n  static const Ctl__SmdDevice init_value = CTL__SMD_DEVICE__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_device__get_packed_size\n                     (const Ctl__SmdDevice *message)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_device__pack\n                     (const Ctl__SmdDevice *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_device__pack_to_buffer\n                     (const Ctl__SmdDevice *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevice *\n       ctl__smd_device__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevice *)\n     protobuf_c_message_unpack (&ctl__smd_device__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_device__free_unpacked\n                     (Ctl__SmdDevice *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_dev_req__init\n                     (Ctl__SmdDevReq         *message)\n{\n  static const Ctl__SmdDevReq init_value = CTL__SMD_DEV_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_dev_req__get_packed_size\n                     (const Ctl__SmdDevReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_dev_req__pack\n                     (const Ctl__SmdDevReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_dev_req__pack_to_buffer\n                     (const Ctl__SmdDevReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevReq *\n       ctl__smd_dev_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevReq *)\n     protobuf_c_message_unpack (&ctl__smd_dev_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_dev_req__free_unpacked\n                     (Ctl__SmdDevReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_dev_resp__init\n                     (Ctl__SmdDevResp         *message)\n{\n  static const Ctl__SmdDevResp init_value = CTL__SMD_DEV_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_dev_resp__get_packed_size\n                     (const Ctl__SmdDevResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_dev_resp__pack\n                     (const Ctl__SmdDevResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_dev_resp__pack_to_buffer\n                     (const Ctl__SmdDevResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevResp *\n       ctl__smd_dev_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevResp *)\n     protobuf_c_message_unpack (&ctl__smd_dev_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_dev_resp__free_unpacked\n                     (Ctl__SmdDevResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_pool_req__init\n                     (Ctl__SmdPoolReq         *message)\n{\n  static const Ctl__SmdPoolReq init_value = CTL__SMD_POOL_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_pool_req__get_packed_size\n                     (const Ctl__SmdPoolReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_pool_req__pack\n                     (const Ctl__SmdPoolReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_pool_req__pack_to_buffer\n                     (const Ctl__SmdPoolReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdPoolReq *\n       ctl__smd_pool_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdPoolReq *)\n     protobuf_c_message_unpack (&ctl__smd_pool_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_pool_req__free_unpacked\n                     (Ctl__SmdPoolReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_pool_resp__pool__init\n                     (Ctl__SmdPoolResp__Pool         *message)\n{\n  static const Ctl__SmdPoolResp__Pool init_value = CTL__SMD_POOL_RESP__POOL__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_pool_resp__init\n                     (Ctl__SmdPoolResp         *message)\n{\n  static const Ctl__SmdPoolResp init_value = CTL__SMD_POOL_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_pool_resp__get_packed_size\n                     (const Ctl__SmdPoolResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_pool_resp__pack\n                     (const Ctl__SmdPoolResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_pool_resp__pack_to_buffer\n                     (const Ctl__SmdPoolResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdPoolResp *\n       ctl__smd_pool_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdPoolResp *)\n     protobuf_c_message_unpack (&ctl__smd_pool_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_pool_resp__free_unpacked\n                     (Ctl__SmdPoolResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_query_req__init\n                     (Ctl__SmdQueryReq         *message)\n{\n  static const Ctl__SmdQueryReq init_value = CTL__SMD_QUERY_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_query_req__get_packed_size\n                     (const Ctl__SmdQueryReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_query_req__pack\n                     (const Ctl__SmdQueryReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_query_req__pack_to_buffer\n                     (const Ctl__SmdQueryReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdQueryReq *\n       ctl__smd_query_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdQueryReq *)\n     protobuf_c_message_unpack (&ctl__smd_query_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_query_req__free_unpacked\n                     (Ctl__SmdQueryReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_query_resp__smd_device_with_health__init\n                     (Ctl__SmdQueryResp__SmdDeviceWithHealth         *message)\n{\n  static const Ctl__SmdQueryResp__SmdDeviceWithHealth init_value = CTL__SMD_QUERY_RESP__SMD_DEVICE_WITH_HEALTH__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__pool__init\n                     (Ctl__SmdQueryResp__Pool         *message)\n{\n  static const Ctl__SmdQueryResp__Pool init_value = CTL__SMD_QUERY_RESP__POOL__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__rank_resp__init\n                     (Ctl__SmdQueryResp__RankResp         *message)\n{\n  static const Ctl__SmdQueryResp__RankResp init_value = CTL__SMD_QUERY_RESP__RANK_RESP__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__init\n                     (Ctl__SmdQueryResp         *message)\n{\n  static const Ctl__SmdQueryResp init_value = CTL__SMD_QUERY_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_query_resp__get_packed_size\n                     (const Ctl__SmdQueryResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_query_resp__pack\n                     (const Ctl__SmdQueryResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_query_resp__pack_to_buffer\n                     (const Ctl__SmdQueryResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdQueryResp *\n       ctl__smd_query_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdQueryResp *)\n     protobuf_c_message_unpack (&ctl__smd_query_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_query_resp__free_unpacked\n                     (Ctl__SmdQueryResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__led_manage_req__init\n                     (Ctl__LedManageReq         *message)\n{\n  static const Ctl__LedManageReq init_value = CTL__LED_MANAGE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__led_manage_req__get_packed_size\n                     (const Ctl__LedManageReq *message)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__led_manage_req__pack\n                     (const Ctl__LedManageReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__led_manage_req__pack_to_buffer\n                     (const Ctl__LedManageReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__LedManageReq *\n       ctl__led_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__LedManageReq *)\n     protobuf_c_message_unpack (&ctl__led_manage_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__led_manage_req__free_unpacked\n                     (Ctl__LedManageReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__dev_replace_req__init\n                     (Ctl__DevReplaceReq         *message)\n{\n  static const Ctl__DevReplaceReq init_value = CTL__DEV_REPLACE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__dev_replace_req__get_packed_size\n                     (const Ctl__DevReplaceReq *message)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__dev_replace_req__pack\n                     (const Ctl__DevReplaceReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__dev_replace_req__pack_to_buffer\n                     (const Ctl__DevReplaceReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__DevReplaceReq *\n       ctl__dev_replace_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__DevReplaceReq *)\n     protobuf_c_message_unpack (&ctl__dev_replace_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__dev_replace_req__free_unpacked\n                     (Ctl__DevReplaceReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__set_faulty_req__init\n                     (Ctl__SetFaultyReq         *message)\n{\n  static const Ctl__SetFaultyReq init_value = CTL__SET_FAULTY_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__set_faulty_req__get_packed_size\n                     (const Ctl__SetFaultyReq *message)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__set_faulty_req__pack\n                     (const Ctl__SetFaultyReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__set_faulty_req__pack_to_buffer\n                     (const Ctl__SetFaultyReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SetFaultyReq *\n       ctl__set_faulty_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SetFaultyReq *)\n     protobuf_c_message_unpack (&ctl__set_faulty_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__set_faulty_req__free_unpacked\n                     (Ctl__SetFaultyReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__dev_manage_resp__init\n                     (Ctl__DevManageResp         *message)\n{\n  static const Ctl__DevManageResp init_value = CTL__DEV_MANAGE_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__dev_manage_resp__get_packed_size\n                     (const Ctl__DevManageResp *message)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__dev_manage_resp__pack\n                     (const Ctl__DevManageResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__dev_manage_resp__pack_to_buffer\n                     (const Ctl__DevManageResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__DevManageResp *\n       ctl__dev_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__DevManageResp *)\n     protobuf_c_message_unpack (&ctl__dev_manage_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__dev_manage_resp__free_unpacked\n                     (Ctl__DevManageResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_manage_req__init\n                     (Ctl__SmdManageReq         *message)\n{\n  static const Ctl__SmdManageReq init_value = CTL__SMD_MANAGE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_manage_req__get_packed_size\n                     (const Ctl__SmdManageReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_manage_req__pack\n                     (const Ctl__SmdManageReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_manage_req__pack_to_buffer\n                     (const Ctl__SmdManageReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdManageReq *\n       ctl__smd_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdManageReq *)\n     protobuf_c_message_unpack (&ctl__smd_manage_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_manage_req__free_unpacked\n                     (Ctl__SmdManageReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_manage_resp__result__init\n                     (Ctl__SmdManageResp__Result         *message)\n{\n  static const Ctl__SmdManageResp__Result init_value = CTL__SMD_MANAGE_RESP__RESULT__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_manage_resp__rank_resp__init\n                     (Ctl__SmdManageResp__RankResp         *message)\n{\n  static const Ctl__SmdManageResp__RankResp init_value = CTL__SMD_MANAGE_RESP__RANK_RESP__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_manage_resp__init\n                     (Ctl__SmdManageResp         *message)\n{\n  static const Ctl__SmdManageResp init_value = CTL__SMD_MANAGE_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_manage_resp__get_packed_size\n                     (const Ctl__SmdManageResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_manage_resp__pack\n                     (const Ctl__SmdManageResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_manage_resp__pack_to_buffer\n                     (const Ctl__SmdManageResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdManageResp *\n       ctl__smd_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdManageResp *)\n     protobuf_c_message_unpack (&ctl__smd_manage_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_manage_resp__free_unpacked\n                     (Ctl__SmdManageResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nstatic const ProtobufCFieldDescriptor ctl__bio_health_req__field_descriptors[3] =\n{\n  {\n    \"dev_uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_size\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, meta_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_size\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, rdb_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__bio_health_req__field_indices_by_name[] = {\n  0,   /* field[0] = dev_uuid */\n  1,   /* field[1] = meta_size */\n  2,   /* field[2] = rdb_size */\n};\nstatic const ProtobufCIntRange ctl__bio_health_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__bio_health_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.BioHealthReq\",\n  \"BioHealthReq\",\n  \"Ctl__BioHealthReq\",\n  \"ctl\",\n  sizeof(Ctl__BioHealthReq),\n  3,\n  ctl__bio_health_req__field_descriptors,\n  ctl__bio_health_req__field_indices_by_name,\n  1,  ctl__bio_health_req__number_ranges,\n  (ProtobufCMessageInit) ctl__bio_health_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__bio_health_resp__field_descriptors[45] =\n{\n  {\n    \"timestamp\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, timestamp),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"warn_temp_time\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, warn_temp_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"crit_temp_time\",\n    6,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, crit_temp_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"ctrl_busy_time\",\n    7,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, ctrl_busy_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"power_cycles\",\n    8,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, power_cycles),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"power_on_hours\",\n    9,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, power_on_hours),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"unsafe_shutdowns\",\n    10,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, unsafe_shutdowns),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"media_errs\",\n    11,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, media_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"err_log_entries\",\n    12,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, err_log_entries),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_read_errs\",\n    13,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_read_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_write_errs\",\n    14,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_write_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_unmap_errs\",\n    15,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_unmap_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"checksum_errs\",\n    16,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, checksum_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"temperature\",\n    17,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, temperature),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"temp_warn\",\n    18,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, temp_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_spare_warn\",\n    19,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, avail_spare_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_reliability_warn\",\n    20,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, dev_reliability_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"read_only_warn\",\n    21,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, read_only_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"volatile_mem_warn\",\n    22,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, volatile_mem_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"status\",\n    23,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_uuid\",\n    24,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"total_bytes\",\n    25,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, total_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_bytes\",\n    26,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, avail_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"program_fail_cnt_norm\",\n    27,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, program_fail_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"program_fail_cnt_raw\",\n    28,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, program_fail_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"erase_fail_cnt_norm\",\n    29,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, erase_fail_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"erase_fail_cnt_raw\",\n    30,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, erase_fail_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_norm\",\n    31,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_min\",\n    32,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_min),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_max\",\n    33,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_max),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_avg\",\n    34,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_avg),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"endtoend_err_cnt_raw\",\n    35,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, endtoend_err_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"crc_err_cnt_raw\",\n    36,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, crc_err_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"media_wear_raw\",\n    37,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, media_wear_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"host_reads_raw\",\n    38,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, host_reads_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"workload_timer_raw\",\n    39,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, workload_timer_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"thermal_throttle_status\",\n    40,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, thermal_throttle_status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"thermal_throttle_event_cnt\",\n    41,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, thermal_throttle_event_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"retry_buffer_overflow_cnt\",\n    42,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, retry_buffer_overflow_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pll_lock_loss_cnt\",\n    43,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, pll_lock_loss_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"nand_bytes_written\",\n    44,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, nand_bytes_written),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"host_bytes_written\",\n    45,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, host_bytes_written),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"cluster_size\",\n    46,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, cluster_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_wal_size\",\n    47,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, meta_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_wal_size\",\n    48,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, rdb_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__bio_health_resp__field_indices_by_name[] = {\n  22,   /* field[22] = avail_bytes */\n  15,   /* field[15] = avail_spare_warn */\n  9,   /* field[9] = bio_read_errs */\n  11,   /* field[11] = bio_unmap_errs */\n  10,   /* field[10] = bio_write_errs */\n  12,   /* field[12] = checksum_errs */\n  42,   /* field[42] = cluster_size */\n  32,   /* field[32] = crc_err_cnt_raw */\n  2,   /* field[2] = crit_temp_time */\n  3,   /* field[3] = ctrl_busy_time */\n  16,   /* field[16] = dev_reliability_warn */\n  20,   /* field[20] = dev_uuid */\n  31,   /* field[31] = endtoend_err_cnt_raw */\n  25,   /* field[25] = erase_fail_cnt_norm */\n  26,   /* field[26] = erase_fail_cnt_raw */\n  8,   /* field[8] = err_log_entries */\n  41,   /* field[41] = host_bytes_written */\n  34,   /* field[34] = host_reads_raw */\n  7,   /* field[7] = media_errs */\n  33,   /* field[33] = media_wear_raw */\n  43,   /* field[43] = meta_wal_size */\n  40,   /* field[40] = nand_bytes_written */\n  39,   /* field[39] = pll_lock_loss_cnt */\n  4,   /* field[4] = power_cycles */\n  5,   /* field[5] = power_on_hours */\n  23,   /* field[23] = program_fail_cnt_norm */\n  24,   /* field[24] = program_fail_cnt_raw */\n  44,   /* field[44] = rdb_wal_size */\n  17,   /* field[17] = read_only_warn */\n  38,   /* field[38] = retry_buffer_overflow_cnt */\n  19,   /* field[19] = status */\n  14,   /* field[14] = temp_warn */\n  13,   /* field[13] = temperature */\n  37,   /* field[37] = thermal_throttle_event_cnt */\n  36,   /* field[36] = thermal_throttle_status */\n  0,   /* field[0] = timestamp */\n  21,   /* field[21] = total_bytes */\n  6,   /* field[6] = unsafe_shutdowns */\n  18,   /* field[18] = volatile_mem_warn */\n  1,   /* field[1] = warn_temp_time */\n  30,   /* field[30] = wear_leveling_cnt_avg */\n  29,   /* field[29] = wear_leveling_cnt_max */\n  28,   /* field[28] = wear_leveling_cnt_min */\n  27,   /* field[27] = wear_leveling_cnt_norm */\n  35,   /* field[35] = workload_timer_raw */\n};\nstatic const ProtobufCIntRange ctl__bio_health_resp__number_ranges[2 + 1] =\n{\n  { 3, 0 },\n  { 5, 1 },\n  { 0, 45 }\n};\nconst ProtobufCMessageDescriptor ctl__bio_health_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.BioHealthResp\",\n  \"BioHealthResp\",\n  \"Ctl__BioHealthResp\",\n  \"ctl\",\n  sizeof(Ctl__BioHealthResp),\n  45,\n  ctl__bio_health_resp__field_descriptors,\n  ctl__bio_health_resp__field_indices_by_name,\n  2,  ctl__bio_health_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__bio_health_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_device__field_descriptors[15] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdDevice, n_tgt_ids),\n    offsetof(Ctl__SmdDevice, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tr_addr\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, tr_addr),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_state\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, dev_state),\n    &ctl__nvme_dev_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_state\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, led_state),\n    &ctl__led_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"total_bytes\",\n    6,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, total_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_bytes\",\n    7,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, avail_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"cluster_size\",\n    8,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, cluster_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rank\",\n    9,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"role_bits\",\n    10,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, role_bits),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_size\",\n    11,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, meta_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_wal_size\",\n    12,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, meta_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_size\",\n    13,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rdb_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_wal_size\",\n    14,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rdb_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"usable_bytes\",\n    15,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, usable_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_device__field_indices_by_name[] = {\n  6,   /* field[6] = avail_bytes */\n  7,   /* field[7] = cluster_size */\n  3,   /* field[3] = dev_state */\n  4,   /* field[4] = led_state */\n  10,   /* field[10] = meta_size */\n  11,   /* field[11] = meta_wal_size */\n  8,   /* field[8] = rank */\n  12,   /* field[12] = rdb_size */\n  13,   /* field[13] = rdb_wal_size */\n  9,   /* field[9] = role_bits */\n  1,   /* field[1] = tgt_ids */\n  5,   /* field[5] = total_bytes */\n  2,   /* field[2] = tr_addr */\n  14,   /* field[14] = usable_bytes */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_device__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 15 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_device__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevice\",\n  \"SmdDevice\",\n  \"Ctl__SmdDevice\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevice),\n  15,\n  ctl__smd_device__field_descriptors,\n  ctl__smd_device__field_indices_by_name,\n  1,  ctl__smd_device__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_device__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\n#define ctl__smd_dev_req__field_descriptors NULL\n#define ctl__smd_dev_req__field_indices_by_name NULL\n#define ctl__smd_dev_req__number_ranges NULL\nconst ProtobufCMessageDescriptor ctl__smd_dev_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevReq\",\n  \"SmdDevReq\",\n  \"Ctl__SmdDevReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevReq),\n  0,\n  ctl__smd_dev_req__field_descriptors,\n  ctl__smd_dev_req__field_indices_by_name,\n  0,  ctl__smd_dev_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_dev_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_dev_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"devices\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdDevResp, n_devices),\n    offsetof(Ctl__SmdDevResp, devices),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_dev_resp__field_indices_by_name[] = {\n  1,   /* field[1] = devices */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_dev_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_dev_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevResp\",\n  \"SmdDevResp\",\n  \"Ctl__SmdDevResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevResp),\n  2,\n  ctl__smd_dev_resp__field_descriptors,\n  ctl__smd_dev_resp__field_indices_by_name,\n  1,  ctl__smd_dev_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_dev_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\n#define ctl__smd_pool_req__field_descriptors NULL\n#define ctl__smd_pool_req__field_indices_by_name NULL\n#define ctl__smd_pool_req__number_ranges NULL\nconst ProtobufCMessageDescriptor ctl__smd_pool_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolReq\",\n  \"SmdPoolReq\",\n  \"Ctl__SmdPoolReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolReq),\n  0,\n  ctl__smd_pool_req__field_descriptors,\n  ctl__smd_pool_req__field_indices_by_name,\n  0,  ctl__smd_pool_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_pool_resp__pool__field_descriptors[3] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdPoolResp__Pool, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdPoolResp__Pool, n_tgt_ids),\n    offsetof(Ctl__SmdPoolResp__Pool, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"blobs\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_UINT64,\n    offsetof(Ctl__SmdPoolResp__Pool, n_blobs),\n    offsetof(Ctl__SmdPoolResp__Pool, blobs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_pool_resp__pool__field_indices_by_name[] = {\n  2,   /* field[2] = blobs */\n  1,   /* field[1] = tgt_ids */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_pool_resp__pool__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_pool_resp__pool__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolResp.Pool\",\n  \"Pool\",\n  \"Ctl__SmdPoolResp__Pool\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolResp__Pool),\n  3,\n  ctl__smd_pool_resp__pool__field_descriptors,\n  ctl__smd_pool_resp__pool__field_indices_by_name,\n  1,  ctl__smd_pool_resp__pool__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_resp__pool__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_pool_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdPoolResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pools\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdPoolResp, n_pools),\n    offsetof(Ctl__SmdPoolResp, pools),\n    &ctl__smd_pool_resp__pool__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_pool_resp__field_indices_by_name[] = {\n  1,   /* field[1] = pools */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_pool_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_pool_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolResp\",\n  \"SmdPoolResp\",\n  \"Ctl__SmdPoolResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolResp),\n  2,\n  ctl__smd_pool_resp__field_descriptors,\n  ctl__smd_pool_resp__field_indices_by_name,\n  1,  ctl__smd_pool_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_req__field_descriptors[5] =\n{\n  {\n    \"omit_devices\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, omit_devices),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"omit_pools\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, omit_pools),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"include_bio_health\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, include_bio_health),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"uuid\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rank\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_req__field_indices_by_name[] = {\n  2,   /* field[2] = include_bio_health */\n  0,   /* field[0] = omit_devices */\n  1,   /* field[1] = omit_pools */\n  4,   /* field[4] = rank */\n  3,   /* field[3] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_query_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 5 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryReq\",\n  \"SmdQueryReq\",\n  \"Ctl__SmdQueryReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryReq),\n  5,\n  ctl__smd_query_req__field_descriptors,\n  ctl__smd_query_req__field_indices_by_name,\n  1,  ctl__smd_query_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__smd_device_with_health__field_descriptors[2] =\n{\n  {\n    \"details\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__SmdDeviceWithHealth, details),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"health\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__SmdDeviceWithHealth, health),\n    &ctl__bio_health_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__smd_device_with_health__field_indices_by_name[] = {\n  0,   /* field[0] = details */\n  1,   /* field[1] = health */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__smd_device_with_health__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__smd_device_with_health__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.SmdDeviceWithHealth\",\n  \"SmdDeviceWithHealth\",\n  \"Ctl__SmdQueryResp__SmdDeviceWithHealth\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__SmdDeviceWithHealth),\n  2,\n  ctl__smd_query_resp__smd_device_with_health__field_descriptors,\n  ctl__smd_query_resp__smd_device_with_health__field_indices_by_name,\n  1,  ctl__smd_query_resp__smd_device_with_health__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__smd_device_with_health__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__pool__field_descriptors[3] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__Pool, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdQueryResp__Pool, n_tgt_ids),\n    offsetof(Ctl__SmdQueryResp__Pool, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"blobs\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_UINT64,\n    offsetof(Ctl__SmdQueryResp__Pool, n_blobs),\n    offsetof(Ctl__SmdQueryResp__Pool, blobs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__pool__field_indices_by_name[] = {\n  2,   /* field[2] = blobs */\n  1,   /* field[1] = tgt_ids */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__pool__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__pool__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.Pool\",\n  \"Pool\",\n  \"Ctl__SmdQueryResp__Pool\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__Pool),\n  3,\n  ctl__smd_query_resp__pool__field_descriptors,\n  ctl__smd_query_resp__pool__field_indices_by_name,\n  1,  ctl__smd_query_resp__pool__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__pool__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__rank_resp__field_descriptors[3] =\n{\n  {\n    \"rank\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__RankResp, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"devices\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp__RankResp, n_devices),\n    offsetof(Ctl__SmdQueryResp__RankResp, devices),\n    &ctl__smd_query_resp__smd_device_with_health__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pools\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp__RankResp, n_pools),\n    offsetof(Ctl__SmdQueryResp__RankResp, pools),\n    &ctl__smd_query_resp__pool__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__rank_resp__field_indices_by_name[] = {\n  1,   /* field[1] = devices */\n  2,   /* field[2] = pools */\n  0,   /* field[0] = rank */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__rank_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__rank_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.RankResp\",\n  \"RankResp\",\n  \"Ctl__SmdQueryResp__RankResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__RankResp),\n  3,\n  ctl__smd_query_resp__rank_resp__field_descriptors,\n  ctl__smd_query_resp__rank_resp__field_indices_by_name,\n  1,  ctl__smd_query_resp__rank_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__rank_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"ranks\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp, n_ranks),\n    offsetof(Ctl__SmdQueryResp, ranks),\n    &ctl__smd_query_resp__rank_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__field_indices_by_name[] = {\n  1,   /* field[1] = ranks */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp\",\n  \"SmdQueryResp\",\n  \"Ctl__SmdQueryResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp),\n  2,\n  ctl__smd_query_resp__field_descriptors,\n  ctl__smd_query_resp__field_indices_by_name,\n  1,  ctl__smd_query_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__led_manage_req__field_descriptors[4] =\n{\n  {\n    \"ids\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, ids),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_action\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_action),\n    &ctl__led_action__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_state\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_state),\n    &ctl__led_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_duration_mins\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_duration_mins),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__led_manage_req__field_indices_by_name[] = {\n  0,   /* field[0] = ids */\n  1,   /* field[1] = led_action */\n  3,   /* field[3] = led_duration_mins */\n  2,   /* field[2] = led_state */\n};\nstatic const ProtobufCIntRange ctl__led_manage_req__number_ranges[2 + 1] =\n{\n  { 1, 0 },\n  { 3, 1 },\n  { 0, 4 }\n};\nconst ProtobufCMessageDescriptor ctl__led_manage_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.LedManageReq\",\n  \"LedManageReq\",\n  \"Ctl__LedManageReq\",\n  \"ctl\",\n  sizeof(Ctl__LedManageReq),\n  4,\n  ctl__led_manage_req__field_descriptors,\n  ctl__led_manage_req__field_indices_by_name,\n  2,  ctl__led_manage_req__number_ranges,\n  (ProtobufCMessageInit) ctl__led_manage_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__dev_replace_req__field_descriptors[3] =\n{\n  {\n    \"old_dev_uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, old_dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"new_dev_uuid\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, new_dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"no_reint\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, no_reint),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__dev_replace_req__field_indices_by_name[] = {\n  1,   /* field[1] = new_dev_uuid */\n  2,   /* field[2] = no_reint */\n  0,   /* field[0] = old_dev_uuid */\n};\nstatic const ProtobufCIntRange ctl__dev_replace_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__dev_replace_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.DevReplaceReq\",\n  \"DevReplaceReq\",\n  \"Ctl__DevReplaceReq\",\n  \"ctl\",\n  sizeof(Ctl__DevReplaceReq),\n  3,\n  ctl__dev_replace_req__field_descriptors,\n  ctl__dev_replace_req__field_indices_by_name,\n  1,  ctl__dev_replace_req__number_ranges,\n  (ProtobufCMessageInit) ctl__dev_replace_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__set_faulty_req__field_descriptors[1] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SetFaultyReq, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__set_faulty_req__field_indices_by_name[] = {\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__set_faulty_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 1 }\n};\nconst ProtobufCMessageDescriptor ctl__set_faulty_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SetFaultyReq\",\n  \"SetFaultyReq\",\n  \"Ctl__SetFaultyReq\",\n  \"ctl\",\n  sizeof(Ctl__SetFaultyReq),\n  1,\n  ctl__set_faulty_req__field_descriptors,\n  ctl__set_faulty_req__field_indices_by_name,\n  1,  ctl__set_faulty_req__number_ranges,\n  (ProtobufCMessageInit) ctl__set_faulty_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__dev_manage_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevManageResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"device\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevManageResp, device),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__dev_manage_resp__field_indices_by_name[] = {\n  1,   /* field[1] = device */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__dev_manage_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__dev_manage_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.DevManageResp\",\n  \"DevManageResp\",\n  \"Ctl__DevManageResp\",\n  \"ctl\",\n  sizeof(Ctl__DevManageResp),\n  2,\n  ctl__dev_manage_resp__field_descriptors,\n  ctl__dev_manage_resp__field_indices_by_name,\n  1,  ctl__dev_manage_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__dev_manage_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_req__field_descriptors[3] =\n{\n  {\n    \"led\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, led),\n    &ctl__led_manage_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"replace\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, replace),\n    &ctl__dev_replace_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"faulty\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, faulty),\n    &ctl__set_faulty_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_req__field_indices_by_name[] = {\n  2,   /* field[2] = faulty */\n  0,   /* field[0] = led */\n  1,   /* field[1] = replace */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageReq\",\n  \"SmdManageReq\",\n  \"Ctl__SmdManageReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageReq),\n  3,\n  ctl__smd_manage_req__field_descriptors,\n  ctl__smd_manage_req__field_indices_by_name,\n  1,  ctl__smd_manage_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__result__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__Result, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"device\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__Result, device),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__result__field_indices_by_name[] = {\n  1,   /* field[1] = device */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__result__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__result__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp.Result\",\n  \"Result\",\n  \"Ctl__SmdManageResp__Result\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp__Result),\n  2,\n  ctl__smd_manage_resp__result__field_descriptors,\n  ctl__smd_manage_resp__result__field_indices_by_name,\n  1,  ctl__smd_manage_resp__result__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__result__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__rank_resp__field_descriptors[2] =\n{\n  {\n    \"rank\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__RankResp, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"results\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageResp__RankResp, n_results),\n    offsetof(Ctl__SmdManageResp__RankResp, results),\n    &ctl__smd_manage_resp__result__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__rank_resp__field_indices_by_name[] = {\n  0,   /* field[0] = rank */\n  1,   /* field[1] = results */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__rank_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__rank_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp.RankResp\",\n  \"RankResp\",\n  \"Ctl__SmdManageResp__RankResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp__RankResp),\n  2,\n  ctl__smd_manage_resp__rank_resp__field_descriptors,\n  ctl__smd_manage_resp__rank_resp__field_indices_by_name,\n  1,  ctl__smd_manage_resp__rank_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__rank_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__field_descriptors[1] =\n{\n  {\n    \"ranks\",\n    1,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageResp, n_ranks),\n    offsetof(Ctl__SmdManageResp, ranks),\n    &ctl__smd_manage_resp__rank_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__field_indices_by_name[] = {\n  0,   /* field[0] = ranks */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 1 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp\",\n  \"SmdManageResp\",\n  \"Ctl__SmdManageResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp),\n  1,\n  ctl__smd_manage_resp__field_descriptors,\n  ctl__smd_manage_resp__field_indices_by_name,\n  1,  ctl__smd_manage_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCEnumValue ctl__nvme_dev_state__enum_values_by_number[5] = {\n    {\"UNKNOWN\", \"CTL__NVME_DEV_STATE__UNKNOWN\", 0},\n    {\"NORMAL\", \"CTL__NVME_DEV_STATE__NORMAL\", 1},\n    {\"NEW\", \"CTL__NVME_DEV_STATE__NEW\", 2},\n    {\"EVICTED\", \"CTL__NVME_DEV_STATE__EVICTED\", 3},\n    {\"UNPLUGGED\", \"CTL__NVME_DEV_STATE__UNPLUGGED\", 4},\n};\nstatic const ProtobufCIntRange       ctl__nvme_dev_state__value_ranges[]         = {{0, 0}, {0, 5}};\nstatic const ProtobufCEnumValueIndex ctl__nvme_dev_state__enum_values_by_name[5] = {\n    {\"EVICTED\", 3}, {\"NEW\", 2}, {\"NORMAL\", 1}, {\"UNKNOWN\", 0}, {\"UNPLUGGED\", 4},\n};\nconst ProtobufCEnumDescriptor ctl__nvme_dev_state__descriptor = {\n    PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n    \"ctl.NvmeDevState\",\n    \"NvmeDevState\",\n    \"Ctl__NvmeDevState\",\n    \"ctl\",\n    5,\n    ctl__nvme_dev_state__enum_values_by_number,\n    5,\n    ctl__nvme_dev_state__enum_values_by_name,\n    1,\n    ctl__nvme_dev_state__value_ranges,\n    NULL,\n    NULL,\n    NULL,\n    NULL /* reserved[1234] */\n};\nstatic const ProtobufCEnumValue ctl__led_state__enum_values_by_number[5] =\n{\n  { \"OFF\", \"CTL__LED_STATE__OFF\", 0 },\n  { \"QUICK_BLINK\", \"CTL__LED_STATE__QUICK_BLINK\", 1 },\n  { \"ON\", \"CTL__LED_STATE__ON\", 2 },\n  { \"SLOW_BLINK\", \"CTL__LED_STATE__SLOW_BLINK\", 3 },\n  { \"NA\", \"CTL__LED_STATE__NA\", 4 },\n};\nstatic const ProtobufCIntRange ctl__led_state__value_ranges[] = {\n{0, 0},{0, 5}\n};\nstatic const ProtobufCEnumValueIndex ctl__led_state__enum_values_by_name[5] =\n{\n  { \"NA\", 4 },\n  { \"OFF\", 0 },\n  { \"ON\", 2 },\n  { \"QUICK_BLINK\", 1 },\n  { \"SLOW_BLINK\", 3 },\n};\nconst ProtobufCEnumDescriptor ctl__led_state__descriptor =\n{\n  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n  \"ctl.LedState\",\n  \"LedState\",\n  \"Ctl__LedState\",\n  \"ctl\",\n  5,\n  ctl__led_state__enum_values_by_number,\n  5,\n  ctl__led_state__enum_values_by_name,\n  1,\n  ctl__led_state__value_ranges,\n  NULL,NULL,NULL,NULL   /* reserved[1234] */\n};\nstatic const ProtobufCEnumValue ctl__led_action__enum_values_by_number[3] =\n{\n  { \"GET\", \"CTL__LED_ACTION__GET\", 0 },\n  { \"SET\", \"CTL__LED_ACTION__SET\", 1 },\n  { \"RESET\", \"CTL__LED_ACTION__RESET\", 2 },\n};\nstatic const ProtobufCIntRange ctl__led_action__value_ranges[] = {\n{0, 0},{0, 3}\n};\nstatic const ProtobufCEnumValueIndex ctl__led_action__enum_values_by_name[3] =\n{\n  { \"GET\", 0 },\n  { \"RESET\", 2 },\n  { \"SET\", 1 },\n};\nconst ProtobufCEnumDescriptor ctl__led_action__descriptor =\n{\n  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n  \"ctl.LedAction\",\n  \"LedAction\",\n  \"Ctl__LedAction\",\n  \"ctl\",\n  3,\n  ctl__led_action__enum_values_by_number,\n  3,\n  ctl__led_action__enum_values_by_name,\n  1,\n  ctl__led_action__value_ranges,\n  NULL,NULL,NULL,NULL   /* reserved[1234] */\n};\n"
    },
    {
      "path": "src/bio/smd.pb-c.h",
      "content": "/* Generated by the protocol buffer compiler.  DO NOT EDIT! */\n/* Generated from: smd.proto */\n\n#ifndef PROTOBUF_C_smd_2eproto__INCLUDED\n#define PROTOBUF_C_smd_2eproto__INCLUDED\n\n#include <protobuf-c/protobuf-c.h>\n\nPROTOBUF_C__BEGIN_DECLS\n\n#if PROTOBUF_C_VERSION_NUMBER < 1003000\n# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.\n#elif 1003000 < PROTOBUF_C_MIN_COMPILER_VERSION\n# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.\n#endif\n\n\ntypedef struct _Ctl__BioHealthReq Ctl__BioHealthReq;\ntypedef struct _Ctl__BioHealthResp Ctl__BioHealthResp;\ntypedef struct _Ctl__SmdDevice Ctl__SmdDevice;\ntypedef struct _Ctl__SmdDevReq Ctl__SmdDevReq;\ntypedef struct _Ctl__SmdDevResp Ctl__SmdDevResp;\ntypedef struct _Ctl__SmdPoolReq Ctl__SmdPoolReq;\ntypedef struct _Ctl__SmdPoolResp Ctl__SmdPoolResp;\ntypedef struct _Ctl__SmdPoolResp__Pool Ctl__SmdPoolResp__Pool;\ntypedef struct _Ctl__SmdQueryReq Ctl__SmdQueryReq;\ntypedef struct _Ctl__SmdQueryResp Ctl__SmdQueryResp;\ntypedef struct _Ctl__SmdQueryResp__SmdDeviceWithHealth Ctl__SmdQueryResp__SmdDeviceWithHealth;\ntypedef struct _Ctl__SmdQueryResp__Pool Ctl__SmdQueryResp__Pool;\ntypedef struct _Ctl__SmdQueryResp__RankResp Ctl__SmdQueryResp__RankResp;\ntypedef struct _Ctl__LedManageReq Ctl__LedManageReq;\ntypedef struct _Ctl__DevReplaceReq Ctl__DevReplaceReq;\ntypedef struct _Ctl__SetFaultyReq Ctl__SetFaultyReq;\ntypedef struct _Ctl__DevManageResp Ctl__DevManageResp;\ntypedef struct _Ctl__SmdManageReq Ctl__SmdManageReq;\ntypedef struct _Ctl__SmdManageResp Ctl__SmdManageResp;\ntypedef struct _Ctl__SmdManageResp__Result Ctl__SmdManageResp__Result;\ntypedef struct _Ctl__SmdManageResp__RankResp Ctl__SmdManageResp__RankResp;\n\n\n/* --- enums --- */\n\ntypedef enum _Ctl__NvmeDevState {\n\t/*\n\t * Device state is unknown, zer6o value\n\t */\n\tCTL__NVME_DEV_STATE__UNKNOWN = 0,\n\t/*\n\t * Device is in a normal operational state\n\t */\n\tCTL__NVME_DEV_STATE__NORMAL = 1,\n\t/*\n\t * Device is new and is not yet in-use\n\t */\n\tCTL__NVME_DEV_STATE__NEW = 2,\n\t/*\n\t * Device is faulty and has been evicted\n\t */\n\tCTL__NVME_DEV_STATE__EVICTED = 3,\n\t/*\n\t * Device has been physically removed\n\t */\n\tCTL__NVME_DEV_STATE__UNPLUGGED =\n\t    4 PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__NVME_DEV_STATE)\n} Ctl__NvmeDevState;\ntypedef enum _Ctl__LedState {\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_OFF\n   */\n  CTL__LED_STATE__OFF = 0,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_IDENTIFY\t(4Hz blink)\n   */\n  CTL__LED_STATE__QUICK_BLINK = 1,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_FAULT\t(solid on)\n   */\n  CTL__LED_STATE__ON = 2,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_REBUILD\t(1Hz blink)\n   */\n  CTL__LED_STATE__SLOW_BLINK = 3,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_UNKNOWN\t(VMD not enabled)\n   */\n  CTL__LED_STATE__NA = 4\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__LED_STATE)\n} Ctl__LedState;\ntypedef enum _Ctl__LedAction {\n  CTL__LED_ACTION__GET = 0,\n  CTL__LED_ACTION__SET = 1,\n  CTL__LED_ACTION__RESET = 2\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__LED_ACTION)\n} Ctl__LedAction;\n\n/* --- messages --- */\n\nstruct  _Ctl__BioHealthReq\n{\n  ProtobufCMessage base;\n  char *dev_uuid;\n  /*\n   * Size of the metadata (i.e. vos file index) blob\n   */\n  uint64_t meta_size;\n  /*\n   * Size of the RDB blob\n   */\n  uint64_t rdb_size;\n};\n#define CTL__BIO_HEALTH_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__bio_health_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0, 0 }\n\n\n/*\n * BioHealthResp mirrors nvme_health_stats structure.\n */\nstruct  _Ctl__BioHealthResp\n{\n  ProtobufCMessage base;\n  uint64_t timestamp;\n  /*\n   * Device health details\n   */\n  uint32_t warn_temp_time;\n  uint32_t crit_temp_time;\n  uint64_t ctrl_busy_time;\n  uint64_t power_cycles;\n  uint64_t power_on_hours;\n  uint64_t unsafe_shutdowns;\n  uint64_t media_errs;\n  uint64_t err_log_entries;\n  /*\n   * I/O error counters\n   */\n  uint32_t bio_read_errs;\n  uint32_t bio_write_errs;\n  uint32_t bio_unmap_errs;\n  uint32_t checksum_errs;\n  /*\n   * in Kelvin\n   */\n  uint32_t temperature;\n  /*\n   * Critical warnings\n   */\n  protobuf_c_boolean temp_warn;\n  protobuf_c_boolean avail_spare_warn;\n  protobuf_c_boolean dev_reliability_warn;\n  protobuf_c_boolean read_only_warn;\n  /*\n   * volatile memory backup\n   */\n  protobuf_c_boolean volatile_mem_warn;\n  /*\n   * DAOS err code\n   */\n  int32_t status;\n  /*\n   * UUID of blobstore\n   */\n  char *dev_uuid;\n  /*\n   * Usage stats\n   */\n  /*\n   * size of blobstore\n   */\n  uint64_t total_bytes;\n  /*\n   * free space in blobstore\n   */\n  uint64_t avail_bytes;\n  /*\n   * Intel vendor SMART attributes\n   */\n  /*\n   * percent remaining\n   */\n  uint32_t program_fail_cnt_norm;\n  /*\n   * current value\n   */\n  uint64_t program_fail_cnt_raw;\n  uint32_t erase_fail_cnt_norm;\n  uint64_t erase_fail_cnt_raw;\n  uint32_t wear_leveling_cnt_norm;\n  uint32_t wear_leveling_cnt_min;\n  uint32_t wear_leveling_cnt_max;\n  uint32_t wear_leveling_cnt_avg;\n  uint64_t endtoend_err_cnt_raw;\n  uint64_t crc_err_cnt_raw;\n  uint64_t media_wear_raw;\n  uint64_t host_reads_raw;\n  uint64_t workload_timer_raw;\n  uint32_t thermal_throttle_status;\n  uint64_t thermal_throttle_event_cnt;\n  uint64_t retry_buffer_overflow_cnt;\n  uint64_t pll_lock_loss_cnt;\n  uint64_t nand_bytes_written;\n  uint64_t host_bytes_written;\n  /*\n   * Engine configs properties\n   */\n  /*\n   * blobstore cluster size in bytes\n   */\n  uint64_t cluster_size;\n  /*\n   * metadata WAL blob size\n   */\n  uint64_t meta_wal_size;\n  /*\n   * RDB WAL blob size\n   */\n  uint64_t rdb_wal_size;\n};\n#define CTL__BIO_HEALTH_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__bio_health_resp__descriptor) \\\n    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n\n\n/*\n * SmdDevice represents a DAOS BIO device, identified by a UUID written into a label stored on a\n * SPDK blobstore created on a NVMe namespace. Multiple SmdDevices may exist per NVMe controller.\n */\nstruct  _Ctl__SmdDevice\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of blobstore\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * Transport address of blobstore\n   */\n  char *tr_addr;\n  /*\n   * NVMe device state\n   */\n  Ctl__NvmeDevState dev_state;\n  /*\n   * LED state\n   */\n  Ctl__LedState led_state;\n  /*\n   * blobstore clusters total bytes\n   */\n  uint64_t total_bytes;\n  /*\n   * Available RAW storage for data\n   */\n  uint64_t avail_bytes;\n  /*\n   * blobstore cluster size in bytes\n   */\n  uint64_t cluster_size;\n  /*\n   * DAOS I/O Engine using controller\n   */\n  uint32_t rank;\n  /*\n   * Device active roles (bitmask)\n   */\n  uint32_t role_bits;\n  /*\n   * Size of the metadata (i.e. vos file index) blob\n   */\n  uint64_t meta_size;\n  /*\n   * Size of the metadata WAL blob\n   */\n  uint64_t meta_wal_size;\n  /*\n   * Size of the RDB blob\n   */\n  uint64_t rdb_size;\n  /*\n   * Size of the RDB WAL blob\n   */\n  uint64_t rdb_wal_size;\n  /*\n   * Effective storage available for data\n   */\n  uint64_t usable_bytes;\n};\n#define CTL__SMD_DEVICE__INIT                                                                      \\\n\t{                                                                                          \\\n\t\tPROTOBUF_C_MESSAGE_INIT(&ctl__smd_device__descriptor)                              \\\n\t\t, (char *)protobuf_c_empty_string, 0, NULL, (char *)protobuf_c_empty_string,       \\\n\t\t    CTL__NVME_DEV_STATE__UNKNOWN, CTL__LED_STATE__OFF, 0, 0, 0, 0, 0, 0, 0, 0, 0,  \\\n\t\t    0                                                                              \\\n\t}\n\nstruct  _Ctl__SmdDevReq\n{\n  ProtobufCMessage base;\n};\n#define CTL__SMD_DEV_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_dev_req__descriptor) \\\n     }\n\n\nstruct  _Ctl__SmdDevResp\n{\n  ProtobufCMessage base;\n  int32_t status;\n  size_t n_devices;\n  Ctl__SmdDevice **devices;\n};\n#define CTL__SMD_DEV_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_dev_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdPoolReq\n{\n  ProtobufCMessage base;\n};\n#define CTL__SMD_POOL_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_req__descriptor) \\\n     }\n\n\nstruct  _Ctl__SmdPoolResp__Pool\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of VOS pool\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * SPDK blobs\n   */\n  size_t n_blobs;\n  uint64_t *blobs;\n};\n#define CTL__SMD_POOL_RESP__POOL__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_resp__pool__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdPoolResp\n{\n  ProtobufCMessage base;\n  int32_t status;\n  size_t n_pools;\n  Ctl__SmdPoolResp__Pool **pools;\n};\n#define CTL__SMD_POOL_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryReq\n{\n  ProtobufCMessage base;\n  /*\n   * Indicate query should omit devices\n   */\n  protobuf_c_boolean omit_devices;\n  /*\n   * Indicate query should omit pools\n   */\n  protobuf_c_boolean omit_pools;\n  /*\n   * Indicate query should include BIO health for devices\n   */\n  protobuf_c_boolean include_bio_health;\n  /*\n   * Constrain query to this UUID (pool or device)\n   */\n  char *uuid;\n  /*\n   * Restrict response to only include info about this rank\n   */\n  uint32_t rank;\n};\n#define CTL__SMD_QUERY_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_req__descriptor) \\\n    , 0, 0, 0, (char *)protobuf_c_empty_string, 0 }\n\n\nstruct  _Ctl__SmdQueryResp__SmdDeviceWithHealth\n{\n  ProtobufCMessage base;\n  Ctl__SmdDevice *details;\n  /*\n   * optional BIO health\n   */\n  Ctl__BioHealthResp *health;\n};\n#define CTL__SMD_QUERY_RESP__SMD_DEVICE_WITH_HEALTH__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__smd_device_with_health__descriptor) \\\n    , NULL, NULL }\n\n\nstruct  _Ctl__SmdQueryResp__Pool\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of VOS pool\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * SPDK blobs\n   */\n  size_t n_blobs;\n  uint64_t *blobs;\n};\n#define CTL__SMD_QUERY_RESP__POOL__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__pool__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryResp__RankResp\n{\n  ProtobufCMessage base;\n  /*\n   * rank to which this response corresponds\n   */\n  uint32_t rank;\n  /*\n   * List of devices on the rank\n   */\n  size_t n_devices;\n  Ctl__SmdQueryResp__SmdDeviceWithHealth **devices;\n  /*\n   * List of pools on the rank\n   */\n  size_t n_pools;\n  Ctl__SmdQueryResp__Pool **pools;\n};\n#define CTL__SMD_QUERY_RESP__RANK_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__rank_resp__descriptor) \\\n    , 0, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryResp\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  /*\n   * List of per-rank responses\n   */\n  size_t n_ranks;\n  Ctl__SmdQueryResp__RankResp **ranks;\n};\n#define CTL__SMD_QUERY_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__LedManageReq\n{\n  ProtobufCMessage base;\n  /*\n   * List of Device-UUIDs and/or PCI-addresses\n   */\n  char *ids;\n  /*\n   * LED action to perform\n   */\n  Ctl__LedAction led_action;\n  /*\n   * LED state to set (used if action is SET)\n   */\n  Ctl__LedState led_state;\n  /*\n   * LED action duration (how long to blink LED in minutes)\n   */\n  uint32_t led_duration_mins;\n};\n#define CTL__LED_MANAGE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__led_manage_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, CTL__LED_ACTION__GET, CTL__LED_STATE__OFF, 0 }\n\n\nstruct  _Ctl__DevReplaceReq\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of old (hot-removed) blobstore/device\n   */\n  char *old_dev_uuid;\n  /*\n   * UUID of new (hot-plugged) blobstore/device\n   */\n  char *new_dev_uuid;\n  /*\n   * Skip device reintegration if set\n   */\n  protobuf_c_boolean no_reint;\n};\n#define CTL__DEV_REPLACE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__dev_replace_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0 }\n\n\nstruct  _Ctl__SetFaultyReq\n{\n  ProtobufCMessage base;\n  /*\n   * Device-UUID (as recorded in SMD)\n   */\n  char *uuid;\n};\n#define CTL__SET_FAULTY_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__set_faulty_req__descriptor) \\\n    , (char *)protobuf_c_empty_string }\n\n\nstruct  _Ctl__DevManageResp\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  /*\n   * Details of device that has been managed\n   */\n  Ctl__SmdDevice *device;\n};\n#define CTL__DEV_MANAGE_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__dev_manage_resp__descriptor) \\\n    , 0, NULL }\n\n\ntypedef enum {\n  CTL__SMD_MANAGE_REQ__OP__NOT_SET = 0,\n  CTL__SMD_MANAGE_REQ__OP_LED = 1,\n  CTL__SMD_MANAGE_REQ__OP_REPLACE = 2,\n  CTL__SMD_MANAGE_REQ__OP_FAULTY = 3\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__SMD_MANAGE_REQ__OP)\n} Ctl__SmdManageReq__OpCase;\n\nstruct  _Ctl__SmdManageReq\n{\n  ProtobufCMessage base;\n  Ctl__SmdManageReq__OpCase op_case;\n  union {\n    /*\n     * Request to manage LED state\n     */\n    Ctl__LedManageReq *led;\n    /*\n     * Request to replace SMD device\n     */\n    Ctl__DevReplaceReq *replace;\n    /*\n     * Request to set SMD device faulty\n     */\n    Ctl__SetFaultyReq *faulty;\n  };\n};\n#define CTL__SMD_MANAGE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_req__descriptor) \\\n    , CTL__SMD_MANAGE_REQ__OP__NOT_SET, {0} }\n\n\nstruct  _Ctl__SmdManageResp__Result\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  Ctl__SmdDevice *device;\n};\n#define CTL__SMD_MANAGE_RESP__RESULT__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__result__descriptor) \\\n    , 0, NULL }\n\n\nstruct  _Ctl__SmdManageResp__RankResp\n{\n  ProtobufCMessage base;\n  /*\n   * Rank to which this response corresponds\n   */\n  uint32_t rank;\n  /*\n   * List of device results on the rank\n   */\n  size_t n_results;\n  Ctl__SmdManageResp__Result **results;\n};\n#define CTL__SMD_MANAGE_RESP__RANK_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__rank_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdManageResp\n{\n  ProtobufCMessage base;\n  /*\n   * List of per-rank responses\n   */\n  size_t n_ranks;\n  Ctl__SmdManageResp__RankResp **ranks;\n};\n#define CTL__SMD_MANAGE_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__descriptor) \\\n    , 0,NULL }\n\n\n/* Ctl__BioHealthReq methods */\nvoid   ctl__bio_health_req__init\n                     (Ctl__BioHealthReq         *message);\nsize_t ctl__bio_health_req__get_packed_size\n                     (const Ctl__BioHealthReq   *message);\nsize_t ctl__bio_health_req__pack\n                     (const Ctl__BioHealthReq   *message,\n                      uint8_t             *out);\nsize_t ctl__bio_health_req__pack_to_buffer\n                     (const Ctl__BioHealthReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__BioHealthReq *\n       ctl__bio_health_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__bio_health_req__free_unpacked\n                     (Ctl__BioHealthReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__BioHealthResp methods */\nvoid   ctl__bio_health_resp__init\n                     (Ctl__BioHealthResp         *message);\nsize_t ctl__bio_health_resp__get_packed_size\n                     (const Ctl__BioHealthResp   *message);\nsize_t ctl__bio_health_resp__pack\n                     (const Ctl__BioHealthResp   *message,\n                      uint8_t             *out);\nsize_t ctl__bio_health_resp__pack_to_buffer\n                     (const Ctl__BioHealthResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__BioHealthResp *\n       ctl__bio_health_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__bio_health_resp__free_unpacked\n                     (Ctl__BioHealthResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevice methods */\nvoid   ctl__smd_device__init\n                     (Ctl__SmdDevice         *message);\nsize_t ctl__smd_device__get_packed_size\n                     (const Ctl__SmdDevice   *message);\nsize_t ctl__smd_device__pack\n                     (const Ctl__SmdDevice   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_device__pack_to_buffer\n                     (const Ctl__SmdDevice   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevice *\n       ctl__smd_device__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_device__free_unpacked\n                     (Ctl__SmdDevice *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevReq methods */\nvoid   ctl__smd_dev_req__init\n                     (Ctl__SmdDevReq         *message);\nsize_t ctl__smd_dev_req__get_packed_size\n                     (const Ctl__SmdDevReq   *message);\nsize_t ctl__smd_dev_req__pack\n                     (const Ctl__SmdDevReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_dev_req__pack_to_buffer\n                     (const Ctl__SmdDevReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevReq *\n       ctl__smd_dev_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_dev_req__free_unpacked\n                     (Ctl__SmdDevReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevResp methods */\nvoid   ctl__smd_dev_resp__init\n                     (Ctl__SmdDevResp         *message);\nsize_t ctl__smd_dev_resp__get_packed_size\n                     (const Ctl__SmdDevResp   *message);\nsize_t ctl__smd_dev_resp__pack\n                     (const Ctl__SmdDevResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_dev_resp__pack_to_buffer\n                     (const Ctl__SmdDevResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevResp *\n       ctl__smd_dev_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_dev_resp__free_unpacked\n                     (Ctl__SmdDevResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdPoolReq methods */\nvoid   ctl__smd_pool_req__init\n                     (Ctl__SmdPoolReq         *message);\nsize_t ctl__smd_pool_req__get_packed_size\n                     (const Ctl__SmdPoolReq   *message);\nsize_t ctl__smd_pool_req__pack\n                     (const Ctl__SmdPoolReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_pool_req__pack_to_buffer\n                     (const Ctl__SmdPoolReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdPoolReq *\n       ctl__smd_pool_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_pool_req__free_unpacked\n                     (Ctl__SmdPoolReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdPoolResp__Pool methods */\nvoid   ctl__smd_pool_resp__pool__init\n                     (Ctl__SmdPoolResp__Pool         *message);\n/* Ctl__SmdPoolResp methods */\nvoid   ctl__smd_pool_resp__init\n                     (Ctl__SmdPoolResp         *message);\nsize_t ctl__smd_pool_resp__get_packed_size\n                     (const Ctl__SmdPoolResp   *message);\nsize_t ctl__smd_pool_resp__pack\n                     (const Ctl__SmdPoolResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_pool_resp__pack_to_buffer\n                     (const Ctl__SmdPoolResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdPoolResp *\n       ctl__smd_pool_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_pool_resp__free_unpacked\n                     (Ctl__SmdPoolResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdQueryReq methods */\nvoid   ctl__smd_query_req__init\n                     (Ctl__SmdQueryReq         *message);\nsize_t ctl__smd_query_req__get_packed_size\n                     (const Ctl__SmdQueryReq   *message);\nsize_t ctl__smd_query_req__pack\n                     (const Ctl__SmdQueryReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_query_req__pack_to_buffer\n                     (const Ctl__SmdQueryReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdQueryReq *\n       ctl__smd_query_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_query_req__free_unpacked\n                     (Ctl__SmdQueryReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdQueryResp__SmdDeviceWithHealth methods */\nvoid   ctl__smd_query_resp__smd_device_with_health__init\n                     (Ctl__SmdQueryResp__SmdDeviceWithHealth         *message);\n/* Ctl__SmdQueryResp__Pool methods */\nvoid   ctl__smd_query_resp__pool__init\n                     (Ctl__SmdQueryResp__Pool         *message);\n/* Ctl__SmdQueryResp__RankResp methods */\nvoid   ctl__smd_query_resp__rank_resp__init\n                     (Ctl__SmdQueryResp__RankResp         *message);\n/* Ctl__SmdQueryResp methods */\nvoid   ctl__smd_query_resp__init\n                     (Ctl__SmdQueryResp         *message);\nsize_t ctl__smd_query_resp__get_packed_size\n                     (const Ctl__SmdQueryResp   *message);\nsize_t ctl__smd_query_resp__pack\n                     (const Ctl__SmdQueryResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_query_resp__pack_to_buffer\n                     (const Ctl__SmdQueryResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdQueryResp *\n       ctl__smd_query_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_query_resp__free_unpacked\n                     (Ctl__SmdQueryResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__LedManageReq methods */\nvoid   ctl__led_manage_req__init\n                     (Ctl__LedManageReq         *message);\nsize_t ctl__led_manage_req__get_packed_size\n                     (const Ctl__LedManageReq   *message);\nsize_t ctl__led_manage_req__pack\n                     (const Ctl__LedManageReq   *message,\n                      uint8_t             *out);\nsize_t ctl__led_manage_req__pack_to_buffer\n                     (const Ctl__LedManageReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__LedManageReq *\n       ctl__led_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__led_manage_req__free_unpacked\n                     (Ctl__LedManageReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__DevReplaceReq methods */\nvoid   ctl__dev_replace_req__init\n                     (Ctl__DevReplaceReq         *message);\nsize_t ctl__dev_replace_req__get_packed_size\n                     (const Ctl__DevReplaceReq   *message);\nsize_t ctl__dev_replace_req__pack\n                     (const Ctl__DevReplaceReq   *message,\n                      uint8_t             *out);\nsize_t ctl__dev_replace_req__pack_to_buffer\n                     (const Ctl__DevReplaceReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__DevReplaceReq *\n       ctl__dev_replace_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__dev_replace_req__free_unpacked\n                     (Ctl__DevReplaceReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SetFaultyReq methods */\nvoid   ctl__set_faulty_req__init\n                     (Ctl__SetFaultyReq         *message);\nsize_t ctl__set_faulty_req__get_packed_size\n                     (const Ctl__SetFaultyReq   *message);\nsize_t ctl__set_faulty_req__pack\n                     (const Ctl__SetFaultyReq   *message,\n                      uint8_t             *out);\nsize_t ctl__set_faulty_req__pack_to_buffer\n                     (const Ctl__SetFaultyReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SetFaultyReq *\n       ctl__set_faulty_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__set_faulty_req__free_unpacked\n                     (Ctl__SetFaultyReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__DevManageResp methods */\nvoid   ctl__dev_manage_resp__init\n                     (Ctl__DevManageResp         *message);\nsize_t ctl__dev_manage_resp__get_packed_size\n                     (const Ctl__DevManageResp   *message);\nsize_t ctl__dev_manage_resp__pack\n                     (const Ctl__DevManageResp   *message,\n                      uint8_t             *out);\nsize_t ctl__dev_manage_resp__pack_to_buffer\n                     (const Ctl__DevManageResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__DevManageResp *\n       ctl__dev_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__dev_manage_resp__free_unpacked\n                     (Ctl__DevManageResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdManageReq methods */\nvoid   ctl__smd_manage_req__init\n                     (Ctl__SmdManageReq         *message);\nsize_t ctl__smd_manage_req__get_packed_size\n                     (const Ctl__SmdManageReq   *message);\nsize_t ctl__smd_manage_req__pack\n                     (const Ctl__SmdManageReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_manage_req__pack_to_buffer\n                     (const Ctl__SmdManageReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdManageReq *\n       ctl__smd_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_manage_req__free_unpacked\n                     (Ctl__SmdManageReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdManageResp__Result methods */\nvoid   ctl__smd_manage_resp__result__init\n                     (Ctl__SmdManageResp__Result         *message);\n/* Ctl__SmdManageResp__RankResp methods */\nvoid   ctl__smd_manage_resp__rank_resp__init\n                     (Ctl__SmdManageResp__RankResp         *message);\n/* Ctl__SmdManageResp methods */\nvoid   ctl__smd_manage_resp__init\n                     (Ctl__SmdManageResp         *message);\nsize_t ctl__smd_manage_resp__get_packed_size\n                     (const Ctl__SmdManageResp   *message);\nsize_t ctl__smd_manage_resp__pack\n                     (const Ctl__SmdManageResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_manage_resp__pack_to_buffer\n                     (const Ctl__SmdManageResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdManageResp *\n       ctl__smd_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_manage_resp__free_unpacked\n                     (Ctl__SmdManageResp *message,\n                      ProtobufCAllocator *allocator);\n/* --- per-message closures --- */\n\ntypedef void (*Ctl__BioHealthReq_Closure)\n                 (const Ctl__BioHealthReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__BioHealthResp_Closure)\n                 (const Ctl__BioHealthResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevice_Closure)\n                 (const Ctl__SmdDevice *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevReq_Closure)\n                 (const Ctl__SmdDevReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevResp_Closure)\n                 (const Ctl__SmdDevResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolReq_Closure)\n                 (const Ctl__SmdPoolReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolResp__Pool_Closure)\n                 (const Ctl__SmdPoolResp__Pool *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolResp_Closure)\n                 (const Ctl__SmdPoolResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryReq_Closure)\n                 (const Ctl__SmdQueryReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__SmdDeviceWithHealth_Closure)\n                 (const Ctl__SmdQueryResp__SmdDeviceWithHealth *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__Pool_Closure)\n                 (const Ctl__SmdQueryResp__Pool *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__RankResp_Closure)\n                 (const Ctl__SmdQueryResp__RankResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp_Closure)\n                 (const Ctl__SmdQueryResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__LedManageReq_Closure)\n                 (const Ctl__LedManageReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__DevReplaceReq_Closure)\n                 (const Ctl__DevReplaceReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SetFaultyReq_Closure)\n                 (const Ctl__SetFaultyReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__DevManageResp_Closure)\n                 (const Ctl__DevManageResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageReq_Closure)\n                 (const Ctl__SmdManageReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp__Result_Closure)\n                 (const Ctl__SmdManageResp__Result *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp__RankResp_Closure)\n                 (const Ctl__SmdManageResp__RankResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp_Closure)\n                 (const Ctl__SmdManageResp *message,\n                  void *closure_data);\n\n/* --- services --- */\n\n\n/* --- descriptors --- */\n\nextern const ProtobufCEnumDescriptor    ctl__nvme_dev_state__descriptor;\nextern const ProtobufCEnumDescriptor    ctl__led_state__descriptor;\nextern const ProtobufCEnumDescriptor    ctl__led_action__descriptor;\nextern const ProtobufCMessageDescriptor ctl__bio_health_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__bio_health_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_device__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_dev_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_dev_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_resp__pool__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__smd_device_with_health__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__pool__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__rank_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__led_manage_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__dev_replace_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__set_faulty_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__dev_manage_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__result__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__rank_resp__descriptor;\n\nPROTOBUF_C__END_DECLS\n\n\n#endif  /* PROTOBUF_C_smd_2eproto__INCLUDED */\n"
    },
    {
      "path": "src/control/common/proto/ctl/smd.pb.go",
      "content": "//\n// (C) Copyright 2019-2023 Intel Corporation.\n//\n// SPDX-License-Identifier: BSD-2-Clause-Patent\n//\n\n// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.31.0\n// \tprotoc        v3.5.0\n// source: ctl/smd.proto\n\npackage ctl\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\ntype NvmeDevState int32\n\nconst (\n\tNvmeDevState_UNKNOWN   NvmeDevState = 0 // Device state is unknown, zer6o value\n\tNvmeDevState_NORMAL    NvmeDevState = 1 // Device is in a normal operational state\n\tNvmeDevState_NEW       NvmeDevState = 2 // Device is new and is not yet in-use\n\tNvmeDevState_EVICTED   NvmeDevState = 3 // Device is faulty and has been evicted\n\tNvmeDevState_UNPLUGGED NvmeDevState = 4 // Device has been physically removed\n)\n\n// Enum value maps for NvmeDevState.\nvar (\n\tNvmeDevState_name = map[int32]string{\n\t\t0: \"UNKNOWN\",\n\t\t1: \"NORMAL\",\n\t\t2: \"NEW\",\n\t\t3: \"EVICTED\",\n\t\t4: \"UNPLUGGED\",\n\t}\n\tNvmeDevState_value = map[string]int32{\n\t\t\"UNKNOWN\":   0,\n\t\t\"NORMAL\":    1,\n\t\t\"NEW\":       2,\n\t\t\"EVICTED\":   3,\n\t\t\"UNPLUGGED\": 4,\n\t}\n)\n\nfunc (x NvmeDevState) Enum() *NvmeDevState {\n\tp := new(NvmeDevState)\n\t*p = x\n\treturn p\n}\n\nfunc (x NvmeDevState) String() string {\n\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n}\n\nfunc (NvmeDevState) Descriptor() protoreflect.EnumDescriptor {\n\treturn file_ctl_smd_proto_enumTypes[0].Descriptor()\n}\n\nfunc (NvmeDevState) Type() protoreflect.EnumType {\n\treturn &file_ctl_smd_proto_enumTypes[0]\n}\n\nfunc (x NvmeDevState) Number() protoreflect.EnumNumber {\n\treturn protoreflect.EnumNumber(x)\n}\n\n// Deprecated: Use NvmeDevState.Descriptor instead.\nfunc (NvmeDevState) EnumDescriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{0}\n}\n\ntype LedState int32\n\nconst (\n\tLedState_OFF         LedState = 0 // Equivalent to SPDK_VMD_LED_STATE_OFF\n\tLedState_QUICK_BLINK LedState = 1 // Equivalent to SPDK_VMD_LED_STATE_IDENTIFY\t(4Hz blink)\n\tLedState_ON          LedState = 2 // Equivalent to SPDK_VMD_LED_STATE_FAULT\t(solid on)\n\tLedState_SLOW_BLINK  LedState = 3 // Equivalent to SPDK_VMD_LED_STATE_REBUILD\t(1Hz blink)\n\tLedState_NA          LedState = 4 // Equivalent to SPDK_VMD_LED_STATE_UNKNOWN\t(VMD not enabled)\n)\n\n// Enum value maps for LedState.\nvar (\n\tLedState_name = map[int32]string{\n\t\t0: \"OFF\",\n\t\t1: \"QUICK_BLINK\",\n\t\t2: \"ON\",\n\t\t3: \"SLOW_BLINK\",\n\t\t4: \"NA\",\n\t}\n\tLedState_value = map[string]int32{\n\t\t\"OFF\":         0,\n\t\t\"QUICK_BLINK\": 1,\n\t\t\"ON\":          2,\n\t\t\"SLOW_BLINK\":  3,\n\t\t\"NA\":          4,\n\t}\n)\n\nfunc (x LedState) Enum() *LedState {\n\tp := new(LedState)\n\t*p = x\n\treturn p\n}\n\nfunc (x LedState) String() string {\n\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n}\n\nfunc (LedState) Descriptor() protoreflect.EnumDescriptor {\n\treturn file_ctl_smd_proto_enumTypes[1].Descriptor()\n}\n\nfunc (LedState) Type() protoreflect.EnumType {\n\treturn &file_ctl_smd_proto_enumTypes[1]\n}\n\nfunc (x LedState) Number() protoreflect.EnumNumber {\n\treturn protoreflect.EnumNumber(x)\n}\n\n// Deprecated: Use LedState.Descriptor instead.\nfunc (LedState) EnumDescriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{1}\n}\n\ntype LedAction int32\n\nconst (\n\tLedAction_GET   LedAction = 0\n\tLedAction_SET   LedAction = 1\n\tLedAction_RESET LedAction = 2\n)\n\n// Enum value maps for LedAction.\nvar (\n\tLedAction_name = map[int32]string{\n\t\t0: \"GET\",\n\t\t1: \"SET\",\n\t\t2: \"RESET\",\n\t}\n\tLedAction_value = map[string]int32{\n\t\t\"GET\":   0,\n\t\t\"SET\":   1,\n\t\t\"RESET\": 2,\n\t}\n)\n\nfunc (x LedAction) Enum() *LedAction {\n\tp := new(LedAction)\n\t*p = x\n\treturn p\n}\n\nfunc (x LedAction) String() string {\n\treturn protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))\n}\n\nfunc (LedAction) Descriptor() protoreflect.EnumDescriptor {\n\treturn file_ctl_smd_proto_enumTypes[2].Descriptor()\n}\n\nfunc (LedAction) Type() protoreflect.EnumType {\n\treturn &file_ctl_smd_proto_enumTypes[2]\n}\n\nfunc (x LedAction) Number() protoreflect.EnumNumber {\n\treturn protoreflect.EnumNumber(x)\n}\n\n// Deprecated: Use LedAction.Descriptor instead.\nfunc (LedAction) EnumDescriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{2}\n}\n\ntype BioHealthReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tDevUuid  string `protobuf:\"bytes,1,opt,name=dev_uuid,json=devUuid,proto3\" json:\"dev_uuid,omitempty\"`\n\tMetaSize uint64 `protobuf:\"varint,2,opt,name=meta_size,json=metaSize,proto3\" json:\"meta_size,omitempty\"` // Size of the metadata (i.e. vos file index) blob\n\tRdbSize  uint64 `protobuf:\"varint,3,opt,name=rdb_size,json=rdbSize,proto3\" json:\"rdb_size,omitempty\"`    // Size of the RDB blob\n}\n\nfunc (x *BioHealthReq) Reset() {\n\t*x = BioHealthReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *BioHealthReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*BioHealthReq) ProtoMessage() {}\n\nfunc (x *BioHealthReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use BioHealthReq.ProtoReflect.Descriptor instead.\nfunc (*BioHealthReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *BioHealthReq) GetDevUuid() string {\n\tif x != nil {\n\t\treturn x.DevUuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *BioHealthReq) GetMetaSize() uint64 {\n\tif x != nil {\n\t\treturn x.MetaSize\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthReq) GetRdbSize() uint64 {\n\tif x != nil {\n\t\treturn x.RdbSize\n\t}\n\treturn 0\n}\n\n// BioHealthResp mirrors nvme_health_stats structure.\ntype BioHealthResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tTimestamp uint64 `protobuf:\"varint,3,opt,name=timestamp,proto3\" json:\"timestamp,omitempty\"`\n\t// Device health details\n\tWarnTempTime    uint32 `protobuf:\"varint,5,opt,name=warn_temp_time,json=warnTempTime,proto3\" json:\"warn_temp_time,omitempty\"`\n\tCritTempTime    uint32 `protobuf:\"varint,6,opt,name=crit_temp_time,json=critTempTime,proto3\" json:\"crit_temp_time,omitempty\"`\n\tCtrlBusyTime    uint64 `protobuf:\"varint,7,opt,name=ctrl_busy_time,json=ctrlBusyTime,proto3\" json:\"ctrl_busy_time,omitempty\"`\n\tPowerCycles     uint64 `protobuf:\"varint,8,opt,name=power_cycles,json=powerCycles,proto3\" json:\"power_cycles,omitempty\"`\n\tPowerOnHours    uint64 `protobuf:\"varint,9,opt,name=power_on_hours,json=powerOnHours,proto3\" json:\"power_on_hours,omitempty\"`\n\tUnsafeShutdowns uint64 `protobuf:\"varint,10,opt,name=unsafe_shutdowns,json=unsafeShutdowns,proto3\" json:\"unsafe_shutdowns,omitempty\"`\n\tMediaErrs       uint64 `protobuf:\"varint,11,opt,name=media_errs,json=mediaErrs,proto3\" json:\"media_errs,omitempty\"`\n\tErrLogEntries   uint64 `protobuf:\"varint,12,opt,name=err_log_entries,json=errLogEntries,proto3\" json:\"err_log_entries,omitempty\"`\n\t// I/O error counters\n\tBioReadErrs  uint32 `protobuf:\"varint,13,opt,name=bio_read_errs,json=bioReadErrs,proto3\" json:\"bio_read_errs,omitempty\"`\n\tBioWriteErrs uint32 `protobuf:\"varint,14,opt,name=bio_write_errs,json=bioWriteErrs,proto3\" json:\"bio_write_errs,omitempty\"`\n\tBioUnmapErrs uint32 `protobuf:\"varint,15,opt,name=bio_unmap_errs,json=bioUnmapErrs,proto3\" json:\"bio_unmap_errs,omitempty\"`\n\tChecksumErrs uint32 `protobuf:\"varint,16,opt,name=checksum_errs,json=checksumErrs,proto3\" json:\"checksum_errs,omitempty\"`\n\tTemperature  uint32 `protobuf:\"varint,17,opt,name=temperature,proto3\" json:\"temperature,omitempty\"` // in Kelvin\n\t// Critical warnings\n\tTempWarn           bool   `protobuf:\"varint,18,opt,name=temp_warn,json=tempWarn,proto3\" json:\"temp_warn,omitempty\"`\n\tAvailSpareWarn     bool   `protobuf:\"varint,19,opt,name=avail_spare_warn,json=availSpareWarn,proto3\" json:\"avail_spare_warn,omitempty\"`\n\tDevReliabilityWarn bool   `protobuf:\"varint,20,opt,name=dev_reliability_warn,json=devReliabilityWarn,proto3\" json:\"dev_reliability_warn,omitempty\"`\n\tReadOnlyWarn       bool   `protobuf:\"varint,21,opt,name=read_only_warn,json=readOnlyWarn,proto3\" json:\"read_only_warn,omitempty\"`\n\tVolatileMemWarn    bool   `protobuf:\"varint,22,opt,name=volatile_mem_warn,json=volatileMemWarn,proto3\" json:\"volatile_mem_warn,omitempty\"` // volatile memory backup\n\tStatus             int32  `protobuf:\"varint,23,opt,name=status,proto3\" json:\"status,omitempty\"`                                            // DAOS err code\n\tDevUuid            string `protobuf:\"bytes,24,opt,name=dev_uuid,json=devUuid,proto3\" json:\"dev_uuid,omitempty\"`                            // UUID of blobstore\n\t// Usage stats\n\tTotalBytes uint64 `protobuf:\"varint,25,opt,name=total_bytes,json=totalBytes,proto3\" json:\"total_bytes,omitempty\"` // size of blobstore\n\tAvailBytes uint64 `protobuf:\"varint,26,opt,name=avail_bytes,json=availBytes,proto3\" json:\"avail_bytes,omitempty\"` // free space in blobstore\n\t// Intel vendor SMART attributes\n\tProgramFailCntNorm      uint32 `protobuf:\"varint,27,opt,name=program_fail_cnt_norm,json=programFailCntNorm,proto3\" json:\"program_fail_cnt_norm,omitempty\"` // percent remaining\n\tProgramFailCntRaw       uint64 `protobuf:\"varint,28,opt,name=program_fail_cnt_raw,json=programFailCntRaw,proto3\" json:\"program_fail_cnt_raw,omitempty\"`    // current value\n\tEraseFailCntNorm        uint32 `protobuf:\"varint,29,opt,name=erase_fail_cnt_norm,json=eraseFailCntNorm,proto3\" json:\"erase_fail_cnt_norm,omitempty\"`\n\tEraseFailCntRaw         uint64 `protobuf:\"varint,30,opt,name=erase_fail_cnt_raw,json=eraseFailCntRaw,proto3\" json:\"erase_fail_cnt_raw,omitempty\"`\n\tWearLevelingCntNorm     uint32 `protobuf:\"varint,31,opt,name=wear_leveling_cnt_norm,json=wearLevelingCntNorm,proto3\" json:\"wear_leveling_cnt_norm,omitempty\"`\n\tWearLevelingCntMin      uint32 `protobuf:\"varint,32,opt,name=wear_leveling_cnt_min,json=wearLevelingCntMin,proto3\" json:\"wear_leveling_cnt_min,omitempty\"`\n\tWearLevelingCntMax      uint32 `protobuf:\"varint,33,opt,name=wear_leveling_cnt_max,json=wearLevelingCntMax,proto3\" json:\"wear_leveling_cnt_max,omitempty\"`\n\tWearLevelingCntAvg      uint32 `protobuf:\"varint,34,opt,name=wear_leveling_cnt_avg,json=wearLevelingCntAvg,proto3\" json:\"wear_leveling_cnt_avg,omitempty\"`\n\tEndtoendErrCntRaw       uint64 `protobuf:\"varint,35,opt,name=endtoend_err_cnt_raw,json=endtoendErrCntRaw,proto3\" json:\"endtoend_err_cnt_raw,omitempty\"`\n\tCrcErrCntRaw            uint64 `protobuf:\"varint,36,opt,name=crc_err_cnt_raw,json=crcErrCntRaw,proto3\" json:\"crc_err_cnt_raw,omitempty\"`\n\tMediaWearRaw            uint64 `protobuf:\"varint,37,opt,name=media_wear_raw,json=mediaWearRaw,proto3\" json:\"media_wear_raw,omitempty\"`\n\tHostReadsRaw            uint64 `protobuf:\"varint,38,opt,name=host_reads_raw,json=hostReadsRaw,proto3\" json:\"host_reads_raw,omitempty\"`\n\tWorkloadTimerRaw        uint64 `protobuf:\"varint,39,opt,name=workload_timer_raw,json=workloadTimerRaw,proto3\" json:\"workload_timer_raw,omitempty\"`\n\tThermalThrottleStatus   uint32 `protobuf:\"varint,40,opt,name=thermal_throttle_status,json=thermalThrottleStatus,proto3\" json:\"thermal_throttle_status,omitempty\"`\n\tThermalThrottleEventCnt uint64 `protobuf:\"varint,41,opt,name=thermal_throttle_event_cnt,json=thermalThrottleEventCnt,proto3\" json:\"thermal_throttle_event_cnt,omitempty\"`\n\tRetryBufferOverflowCnt  uint64 `protobuf:\"varint,42,opt,name=retry_buffer_overflow_cnt,json=retryBufferOverflowCnt,proto3\" json:\"retry_buffer_overflow_cnt,omitempty\"`\n\tPllLockLossCnt          uint64 `protobuf:\"varint,43,opt,name=pll_lock_loss_cnt,json=pllLockLossCnt,proto3\" json:\"pll_lock_loss_cnt,omitempty\"`\n\tNandBytesWritten        uint64 `protobuf:\"varint,44,opt,name=nand_bytes_written,json=nandBytesWritten,proto3\" json:\"nand_bytes_written,omitempty\"`\n\tHostBytesWritten        uint64 `protobuf:\"varint,45,opt,name=host_bytes_written,json=hostBytesWritten,proto3\" json:\"host_bytes_written,omitempty\"`\n\t// Engine configs properties\n\tClusterSize uint64 `protobuf:\"varint,46,opt,name=cluster_size,json=clusterSize,proto3\" json:\"cluster_size,omitempty\"`   // blobstore cluster size in bytes\n\tMetaWalSize uint64 `protobuf:\"varint,47,opt,name=meta_wal_size,json=metaWalSize,proto3\" json:\"meta_wal_size,omitempty\"` // metadata WAL blob size\n\tRdbWalSize  uint64 `protobuf:\"varint,48,opt,name=rdb_wal_size,json=rdbWalSize,proto3\" json:\"rdb_wal_size,omitempty\"`    // RDB WAL blob size\n}\n\nfunc (x *BioHealthResp) Reset() {\n\t*x = BioHealthResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *BioHealthResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*BioHealthResp) ProtoMessage() {}\n\nfunc (x *BioHealthResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use BioHealthResp.ProtoReflect.Descriptor instead.\nfunc (*BioHealthResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *BioHealthResp) GetTimestamp() uint64 {\n\tif x != nil {\n\t\treturn x.Timestamp\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWarnTempTime() uint32 {\n\tif x != nil {\n\t\treturn x.WarnTempTime\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetCritTempTime() uint32 {\n\tif x != nil {\n\t\treturn x.CritTempTime\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetCtrlBusyTime() uint64 {\n\tif x != nil {\n\t\treturn x.CtrlBusyTime\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetPowerCycles() uint64 {\n\tif x != nil {\n\t\treturn x.PowerCycles\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetPowerOnHours() uint64 {\n\tif x != nil {\n\t\treturn x.PowerOnHours\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetUnsafeShutdowns() uint64 {\n\tif x != nil {\n\t\treturn x.UnsafeShutdowns\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetMediaErrs() uint64 {\n\tif x != nil {\n\t\treturn x.MediaErrs\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetErrLogEntries() uint64 {\n\tif x != nil {\n\t\treturn x.ErrLogEntries\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetBioReadErrs() uint32 {\n\tif x != nil {\n\t\treturn x.BioReadErrs\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetBioWriteErrs() uint32 {\n\tif x != nil {\n\t\treturn x.BioWriteErrs\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetBioUnmapErrs() uint32 {\n\tif x != nil {\n\t\treturn x.BioUnmapErrs\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetChecksumErrs() uint32 {\n\tif x != nil {\n\t\treturn x.ChecksumErrs\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetTemperature() uint32 {\n\tif x != nil {\n\t\treturn x.Temperature\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetTempWarn() bool {\n\tif x != nil {\n\t\treturn x.TempWarn\n\t}\n\treturn false\n}\n\nfunc (x *BioHealthResp) GetAvailSpareWarn() bool {\n\tif x != nil {\n\t\treturn x.AvailSpareWarn\n\t}\n\treturn false\n}\n\nfunc (x *BioHealthResp) GetDevReliabilityWarn() bool {\n\tif x != nil {\n\t\treturn x.DevReliabilityWarn\n\t}\n\treturn false\n}\n\nfunc (x *BioHealthResp) GetReadOnlyWarn() bool {\n\tif x != nil {\n\t\treturn x.ReadOnlyWarn\n\t}\n\treturn false\n}\n\nfunc (x *BioHealthResp) GetVolatileMemWarn() bool {\n\tif x != nil {\n\t\treturn x.VolatileMemWarn\n\t}\n\treturn false\n}\n\nfunc (x *BioHealthResp) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetDevUuid() string {\n\tif x != nil {\n\t\treturn x.DevUuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *BioHealthResp) GetTotalBytes() uint64 {\n\tif x != nil {\n\t\treturn x.TotalBytes\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetAvailBytes() uint64 {\n\tif x != nil {\n\t\treturn x.AvailBytes\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetProgramFailCntNorm() uint32 {\n\tif x != nil {\n\t\treturn x.ProgramFailCntNorm\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetProgramFailCntRaw() uint64 {\n\tif x != nil {\n\t\treturn x.ProgramFailCntRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetEraseFailCntNorm() uint32 {\n\tif x != nil {\n\t\treturn x.EraseFailCntNorm\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetEraseFailCntRaw() uint64 {\n\tif x != nil {\n\t\treturn x.EraseFailCntRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWearLevelingCntNorm() uint32 {\n\tif x != nil {\n\t\treturn x.WearLevelingCntNorm\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWearLevelingCntMin() uint32 {\n\tif x != nil {\n\t\treturn x.WearLevelingCntMin\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWearLevelingCntMax() uint32 {\n\tif x != nil {\n\t\treturn x.WearLevelingCntMax\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWearLevelingCntAvg() uint32 {\n\tif x != nil {\n\t\treturn x.WearLevelingCntAvg\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetEndtoendErrCntRaw() uint64 {\n\tif x != nil {\n\t\treturn x.EndtoendErrCntRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetCrcErrCntRaw() uint64 {\n\tif x != nil {\n\t\treturn x.CrcErrCntRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetMediaWearRaw() uint64 {\n\tif x != nil {\n\t\treturn x.MediaWearRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetHostReadsRaw() uint64 {\n\tif x != nil {\n\t\treturn x.HostReadsRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetWorkloadTimerRaw() uint64 {\n\tif x != nil {\n\t\treturn x.WorkloadTimerRaw\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetThermalThrottleStatus() uint32 {\n\tif x != nil {\n\t\treturn x.ThermalThrottleStatus\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetThermalThrottleEventCnt() uint64 {\n\tif x != nil {\n\t\treturn x.ThermalThrottleEventCnt\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetRetryBufferOverflowCnt() uint64 {\n\tif x != nil {\n\t\treturn x.RetryBufferOverflowCnt\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetPllLockLossCnt() uint64 {\n\tif x != nil {\n\t\treturn x.PllLockLossCnt\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetNandBytesWritten() uint64 {\n\tif x != nil {\n\t\treturn x.NandBytesWritten\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetHostBytesWritten() uint64 {\n\tif x != nil {\n\t\treturn x.HostBytesWritten\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetClusterSize() uint64 {\n\tif x != nil {\n\t\treturn x.ClusterSize\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetMetaWalSize() uint64 {\n\tif x != nil {\n\t\treturn x.MetaWalSize\n\t}\n\treturn 0\n}\n\nfunc (x *BioHealthResp) GetRdbWalSize() uint64 {\n\tif x != nil {\n\t\treturn x.RdbWalSize\n\t}\n\treturn 0\n}\n\n// SmdDevice represents a DAOS BIO device, identified by a UUID written into a label stored on a\n// SPDK blobstore created on a NVMe namespace. Multiple SmdDevices may exist per NVMe controller.\ntype SmdDevice struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUuid        string       `protobuf:\"bytes,1,opt,name=uuid,proto3\" json:\"uuid,omitempty\"`                                                // UUID of blobstore\n\tTgtIds      []int32      `protobuf:\"varint,2,rep,packed,name=tgt_ids,json=tgtIds,proto3\" json:\"tgt_ids,omitempty\"`                      // VOS target IDs\n\tTrAddr      string       `protobuf:\"bytes,3,opt,name=tr_addr,json=trAddr,proto3\" json:\"tr_addr,omitempty\"`                              // Transport address of blobstore\n\tDevState    NvmeDevState `protobuf:\"varint,4,opt,name=dev_state,json=devState,proto3,enum=ctl.NvmeDevState\" json:\"dev_state,omitempty\"` // NVMe device state\n\tLedState    LedState     `protobuf:\"varint,5,opt,name=led_state,json=ledState,proto3,enum=ctl.LedState\" json:\"led_state,omitempty\"`     // LED state\n\tTotalBytes  uint64       `protobuf:\"varint,6,opt,name=total_bytes,json=totalBytes,proto3\" json:\"total_bytes,omitempty\"`                 // blobstore clusters total bytes\n\tAvailBytes  uint64       `protobuf:\"varint,7,opt,name=avail_bytes,json=availBytes,proto3\" json:\"avail_bytes,omitempty\"`                 // Available RAW storage for data\n\tClusterSize uint64       `protobuf:\"varint,8,opt,name=cluster_size,json=clusterSize,proto3\" json:\"cluster_size,omitempty\"`              // blobstore cluster size in bytes\n\tRank        uint32       `protobuf:\"varint,9,opt,name=rank,proto3\" json:\"rank,omitempty\"`                                               // DAOS I/O Engine using controller\n\tRoleBits    uint32       `protobuf:\"varint,10,opt,name=role_bits,json=roleBits,proto3\" json:\"role_bits,omitempty\"`                      // Device active roles (bitmask)\n\tMetaSize    uint64       `protobuf:\"varint,11,opt,name=meta_size,json=metaSize,proto3\" json:\"meta_size,omitempty\"`                      // Size of the metadata (i.e. vos file index) blob\n\tMetaWalSize uint64       `protobuf:\"varint,12,opt,name=meta_wal_size,json=metaWalSize,proto3\" json:\"meta_wal_size,omitempty\"`           // Size of the metadata WAL blob\n\tRdbSize     uint64       `protobuf:\"varint,13,opt,name=rdb_size,json=rdbSize,proto3\" json:\"rdb_size,omitempty\"`                         // Size of the RDB blob\n\tRdbWalSize  uint64       `protobuf:\"varint,14,opt,name=rdb_wal_size,json=rdbWalSize,proto3\" json:\"rdb_wal_size,omitempty\"`              // Size of the RDB WAL blob\n\tUsableBytes uint64       `protobuf:\"varint,15,opt,name=usable_bytes,json=usableBytes,proto3\" json:\"usable_bytes,omitempty\"`             // Effective storage available for data\n}\n\nfunc (x *SmdDevice) Reset() {\n\t*x = SmdDevice{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdDevice) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdDevice) ProtoMessage() {}\n\nfunc (x *SmdDevice) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdDevice.ProtoReflect.Descriptor instead.\nfunc (*SmdDevice) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{2}\n}\n\nfunc (x *SmdDevice) GetUuid() string {\n\tif x != nil {\n\t\treturn x.Uuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *SmdDevice) GetTgtIds() []int32 {\n\tif x != nil {\n\t\treturn x.TgtIds\n\t}\n\treturn nil\n}\n\nfunc (x *SmdDevice) GetTrAddr() string {\n\tif x != nil {\n\t\treturn x.TrAddr\n\t}\n\treturn \"\"\n}\n\nfunc (x *SmdDevice) GetDevState() NvmeDevState {\n\tif x != nil {\n\t\treturn x.DevState\n\t}\n\treturn NvmeDevState_UNKNOWN\n}\n\nfunc (x *SmdDevice) GetLedState() LedState {\n\tif x != nil {\n\t\treturn x.LedState\n\t}\n\treturn LedState_OFF\n}\n\nfunc (x *SmdDevice) GetTotalBytes() uint64 {\n\tif x != nil {\n\t\treturn x.TotalBytes\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetAvailBytes() uint64 {\n\tif x != nil {\n\t\treturn x.AvailBytes\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetClusterSize() uint64 {\n\tif x != nil {\n\t\treturn x.ClusterSize\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetRank() uint32 {\n\tif x != nil {\n\t\treturn x.Rank\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetRoleBits() uint32 {\n\tif x != nil {\n\t\treturn x.RoleBits\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetMetaSize() uint64 {\n\tif x != nil {\n\t\treturn x.MetaSize\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetMetaWalSize() uint64 {\n\tif x != nil {\n\t\treturn x.MetaWalSize\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetRdbSize() uint64 {\n\tif x != nil {\n\t\treturn x.RdbSize\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetRdbWalSize() uint64 {\n\tif x != nil {\n\t\treturn x.RdbWalSize\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevice) GetUsableBytes() uint64 {\n\tif x != nil {\n\t\treturn x.UsableBytes\n\t}\n\treturn 0\n}\n\ntype SmdDevReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n}\n\nfunc (x *SmdDevReq) Reset() {\n\t*x = SmdDevReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdDevReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdDevReq) ProtoMessage() {}\n\nfunc (x *SmdDevReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdDevReq.ProtoReflect.Descriptor instead.\nfunc (*SmdDevReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{3}\n}\n\ntype SmdDevResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tStatus  int32        `protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\"`\n\tDevices []*SmdDevice `protobuf:\"bytes,2,rep,name=devices,proto3\" json:\"devices,omitempty\"`\n}\n\nfunc (x *SmdDevResp) Reset() {\n\t*x = SmdDevResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdDevResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdDevResp) ProtoMessage() {}\n\nfunc (x *SmdDevResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdDevResp.ProtoReflect.Descriptor instead.\nfunc (*SmdDevResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{4}\n}\n\nfunc (x *SmdDevResp) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *SmdDevResp) GetDevices() []*SmdDevice {\n\tif x != nil {\n\t\treturn x.Devices\n\t}\n\treturn nil\n}\n\ntype SmdPoolReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n}\n\nfunc (x *SmdPoolReq) Reset() {\n\t*x = SmdPoolReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdPoolReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdPoolReq) ProtoMessage() {}\n\nfunc (x *SmdPoolReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdPoolReq.ProtoReflect.Descriptor instead.\nfunc (*SmdPoolReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{5}\n}\n\ntype SmdPoolResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tStatus int32               `protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\"`\n\tPools  []*SmdPoolResp_Pool `protobuf:\"bytes,2,rep,name=pools,proto3\" json:\"pools,omitempty\"`\n}\n\nfunc (x *SmdPoolResp) Reset() {\n\t*x = SmdPoolResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdPoolResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdPoolResp) ProtoMessage() {}\n\nfunc (x *SmdPoolResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdPoolResp.ProtoReflect.Descriptor instead.\nfunc (*SmdPoolResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{6}\n}\n\nfunc (x *SmdPoolResp) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *SmdPoolResp) GetPools() []*SmdPoolResp_Pool {\n\tif x != nil {\n\t\treturn x.Pools\n\t}\n\treturn nil\n}\n\ntype SmdQueryReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tOmitDevices      bool   `protobuf:\"varint,1,opt,name=omit_devices,json=omitDevices,proto3\" json:\"omit_devices,omitempty\"`                  // Indicate query should omit devices\n\tOmitPools        bool   `protobuf:\"varint,2,opt,name=omit_pools,json=omitPools,proto3\" json:\"omit_pools,omitempty\"`                        // Indicate query should omit pools\n\tIncludeBioHealth bool   `protobuf:\"varint,3,opt,name=include_bio_health,json=includeBioHealth,proto3\" json:\"include_bio_health,omitempty\"` // Indicate query should include BIO health for devices\n\tUuid             string `protobuf:\"bytes,4,opt,name=uuid,proto3\" json:\"uuid,omitempty\"`                                                    // Constrain query to this UUID (pool or device)\n\tRank             uint32 `protobuf:\"varint,5,opt,name=rank,proto3\" json:\"rank,omitempty\"`                                                   // Restrict response to only include info about this rank\n}\n\nfunc (x *SmdQueryReq) Reset() {\n\t*x = SmdQueryReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdQueryReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdQueryReq) ProtoMessage() {}\n\nfunc (x *SmdQueryReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdQueryReq.ProtoReflect.Descriptor instead.\nfunc (*SmdQueryReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{7}\n}\n\nfunc (x *SmdQueryReq) GetOmitDevices() bool {\n\tif x != nil {\n\t\treturn x.OmitDevices\n\t}\n\treturn false\n}\n\nfunc (x *SmdQueryReq) GetOmitPools() bool {\n\tif x != nil {\n\t\treturn x.OmitPools\n\t}\n\treturn false\n}\n\nfunc (x *SmdQueryReq) GetIncludeBioHealth() bool {\n\tif x != nil {\n\t\treturn x.IncludeBioHealth\n\t}\n\treturn false\n}\n\nfunc (x *SmdQueryReq) GetUuid() string {\n\tif x != nil {\n\t\treturn x.Uuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *SmdQueryReq) GetRank() uint32 {\n\tif x != nil {\n\t\treturn x.Rank\n\t}\n\treturn 0\n}\n\ntype SmdQueryResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tStatus int32                    `protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\"` // DAOS error code\n\tRanks  []*SmdQueryResp_RankResp `protobuf:\"bytes,2,rep,name=ranks,proto3\" json:\"ranks,omitempty\"`    // List of per-rank responses\n}\n\nfunc (x *SmdQueryResp) Reset() {\n\t*x = SmdQueryResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdQueryResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdQueryResp) ProtoMessage() {}\n\nfunc (x *SmdQueryResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdQueryResp.ProtoReflect.Descriptor instead.\nfunc (*SmdQueryResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{8}\n}\n\nfunc (x *SmdQueryResp) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *SmdQueryResp) GetRanks() []*SmdQueryResp_RankResp {\n\tif x != nil {\n\t\treturn x.Ranks\n\t}\n\treturn nil\n}\n\ntype LedManageReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tIds             string    `protobuf:\"bytes,1,opt,name=ids,proto3\" json:\"ids,omitempty\"`                                                   // List of Device-UUIDs and/or PCI-addresses\n\tLedAction       LedAction `protobuf:\"varint,3,opt,name=led_action,json=ledAction,proto3,enum=ctl.LedAction\" json:\"led_action,omitempty\"`  // LED action to perform\n\tLedState        LedState  `protobuf:\"varint,4,opt,name=led_state,json=ledState,proto3,enum=ctl.LedState\" json:\"led_state,omitempty\"`      // LED state to set (used if action is SET)\n\tLedDurationMins uint32    `protobuf:\"varint,5,opt,name=led_duration_mins,json=ledDurationMins,proto3\" json:\"led_duration_mins,omitempty\"` // LED action duration (how long to blink LED in minutes)\n}\n\nfunc (x *LedManageReq) Reset() {\n\t*x = LedManageReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *LedManageReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*LedManageReq) ProtoMessage() {}\n\nfunc (x *LedManageReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use LedManageReq.ProtoReflect.Descriptor instead.\nfunc (*LedManageReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{9}\n}\n\nfunc (x *LedManageReq) GetIds() string {\n\tif x != nil {\n\t\treturn x.Ids\n\t}\n\treturn \"\"\n}\n\nfunc (x *LedManageReq) GetLedAction() LedAction {\n\tif x != nil {\n\t\treturn x.LedAction\n\t}\n\treturn LedAction_GET\n}\n\nfunc (x *LedManageReq) GetLedState() LedState {\n\tif x != nil {\n\t\treturn x.LedState\n\t}\n\treturn LedState_OFF\n}\n\nfunc (x *LedManageReq) GetLedDurationMins() uint32 {\n\tif x != nil {\n\t\treturn x.LedDurationMins\n\t}\n\treturn 0\n}\n\ntype DevReplaceReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tOldDevUuid string `protobuf:\"bytes,1,opt,name=old_dev_uuid,json=oldDevUuid,proto3\" json:\"old_dev_uuid,omitempty\"` // UUID of old (hot-removed) blobstore/device\n\tNewDevUuid string `protobuf:\"bytes,2,opt,name=new_dev_uuid,json=newDevUuid,proto3\" json:\"new_dev_uuid,omitempty\"` // UUID of new (hot-plugged) blobstore/device\n\tNoReint    bool   `protobuf:\"varint,3,opt,name=no_reint,json=noReint,proto3\" json:\"no_reint,omitempty\"`           // Skip device reintegration if set\n}\n\nfunc (x *DevReplaceReq) Reset() {\n\t*x = DevReplaceReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[10]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *DevReplaceReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*DevReplaceReq) ProtoMessage() {}\n\nfunc (x *DevReplaceReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[10]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use DevReplaceReq.ProtoReflect.Descriptor instead.\nfunc (*DevReplaceReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{10}\n}\n\nfunc (x *DevReplaceReq) GetOldDevUuid() string {\n\tif x != nil {\n\t\treturn x.OldDevUuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *DevReplaceReq) GetNewDevUuid() string {\n\tif x != nil {\n\t\treturn x.NewDevUuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *DevReplaceReq) GetNoReint() bool {\n\tif x != nil {\n\t\treturn x.NoReint\n\t}\n\treturn false\n}\n\ntype SetFaultyReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUuid string `protobuf:\"bytes,1,opt,name=uuid,proto3\" json:\"uuid,omitempty\"` // Device-UUID (as recorded in SMD)\n}\n\nfunc (x *SetFaultyReq) Reset() {\n\t*x = SetFaultyReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[11]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SetFaultyReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SetFaultyReq) ProtoMessage() {}\n\nfunc (x *SetFaultyReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[11]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SetFaultyReq.ProtoReflect.Descriptor instead.\nfunc (*SetFaultyReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{11}\n}\n\nfunc (x *SetFaultyReq) GetUuid() string {\n\tif x != nil {\n\t\treturn x.Uuid\n\t}\n\treturn \"\"\n}\n\ntype DevManageResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tStatus int32      `protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\"` // DAOS error code\n\tDevice *SmdDevice `protobuf:\"bytes,2,opt,name=device,proto3\" json:\"device,omitempty\"`  // Details of device that has been managed\n}\n\nfunc (x *DevManageResp) Reset() {\n\t*x = DevManageResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[12]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *DevManageResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*DevManageResp) ProtoMessage() {}\n\nfunc (x *DevManageResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[12]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use DevManageResp.ProtoReflect.Descriptor instead.\nfunc (*DevManageResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{12}\n}\n\nfunc (x *DevManageResp) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *DevManageResp) GetDevice() *SmdDevice {\n\tif x != nil {\n\t\treturn x.Device\n\t}\n\treturn nil\n}\n\ntype SmdManageReq struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\t// Types that are assignable to Op:\n\t//\n\t//\t*SmdManageReq_Led\n\t//\t*SmdManageReq_Replace\n\t//\t*SmdManageReq_Faulty\n\tOp isSmdManageReq_Op `protobuf_oneof:\"op\"`\n}\n\nfunc (x *SmdManageReq) Reset() {\n\t*x = SmdManageReq{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[13]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdManageReq) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdManageReq) ProtoMessage() {}\n\nfunc (x *SmdManageReq) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[13]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdManageReq.ProtoReflect.Descriptor instead.\nfunc (*SmdManageReq) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{13}\n}\n\nfunc (m *SmdManageReq) GetOp() isSmdManageReq_Op {\n\tif m != nil {\n\t\treturn m.Op\n\t}\n\treturn nil\n}\n\nfunc (x *SmdManageReq) GetLed() *LedManageReq {\n\tif x, ok := x.GetOp().(*SmdManageReq_Led); ok {\n\t\treturn x.Led\n\t}\n\treturn nil\n}\n\nfunc (x *SmdManageReq) GetReplace() *DevReplaceReq {\n\tif x, ok := x.GetOp().(*SmdManageReq_Replace); ok {\n\t\treturn x.Replace\n\t}\n\treturn nil\n}\n\nfunc (x *SmdManageReq) GetFaulty() *SetFaultyReq {\n\tif x, ok := x.GetOp().(*SmdManageReq_Faulty); ok {\n\t\treturn x.Faulty\n\t}\n\treturn nil\n}\n\ntype isSmdManageReq_Op interface {\n\tisSmdManageReq_Op()\n}\n\ntype SmdManageReq_Led struct {\n\tLed *LedManageReq `protobuf:\"bytes,1,opt,name=led,proto3,oneof\"` // Request to manage LED state\n}\n\ntype SmdManageReq_Replace struct {\n\tReplace *DevReplaceReq `protobuf:\"bytes,2,opt,name=replace,proto3,oneof\"` // Request to replace SMD device\n}\n\ntype SmdManageReq_Faulty struct {\n\tFaulty *SetFaultyReq `protobuf:\"bytes,3,opt,name=faulty,proto3,oneof\"` // Request to set SMD device faulty\n}\n\nfunc (*SmdManageReq_Led) isSmdManageReq_Op() {}\n\nfunc (*SmdManageReq_Replace) isSmdManageReq_Op() {}\n\nfunc (*SmdManageReq_Faulty) isSmdManageReq_Op() {}\n\ntype SmdManageResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tRanks []*SmdManageResp_RankResp `protobuf:\"bytes,1,rep,name=ranks,proto3\" json:\"ranks,omitempty\"` // List of per-rank responses\n}\n\nfunc (x *SmdManageResp) Reset() {\n\t*x = SmdManageResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[14]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdManageResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdManageResp) ProtoMessage() {}\n\nfunc (x *SmdManageResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[14]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdManageResp.ProtoReflect.Descriptor instead.\nfunc (*SmdManageResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{14}\n}\n\nfunc (x *SmdManageResp) GetRanks() []*SmdManageResp_RankResp {\n\tif x != nil {\n\t\treturn x.Ranks\n\t}\n\treturn nil\n}\n\ntype SmdPoolResp_Pool struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUuid   string   `protobuf:\"bytes,1,opt,name=uuid,proto3\" json:\"uuid,omitempty\"`                           // UUID of VOS pool\n\tTgtIds []int32  `protobuf:\"varint,2,rep,packed,name=tgt_ids,json=tgtIds,proto3\" json:\"tgt_ids,omitempty\"` // VOS target IDs\n\tBlobs  []uint64 `protobuf:\"varint,3,rep,packed,name=blobs,proto3\" json:\"blobs,omitempty\"`                 // SPDK blobs\n}\n\nfunc (x *SmdPoolResp_Pool) Reset() {\n\t*x = SmdPoolResp_Pool{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[15]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdPoolResp_Pool) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdPoolResp_Pool) ProtoMessage() {}\n\nfunc (x *SmdPoolResp_Pool) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[15]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdPoolResp_Pool.ProtoReflect.Descriptor instead.\nfunc (*SmdPoolResp_Pool) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{6, 0}\n}\n\nfunc (x *SmdPoolResp_Pool) GetUuid() string {\n\tif x != nil {\n\t\treturn x.Uuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *SmdPoolResp_Pool) GetTgtIds() []int32 {\n\tif x != nil {\n\t\treturn x.TgtIds\n\t}\n\treturn nil\n}\n\nfunc (x *SmdPoolResp_Pool) GetBlobs() []uint64 {\n\tif x != nil {\n\t\treturn x.Blobs\n\t}\n\treturn nil\n}\n\ntype SmdQueryResp_SmdDeviceWithHealth struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tDetails *SmdDevice     `protobuf:\"bytes,1,opt,name=details,proto3\" json:\"details,omitempty\"`\n\tHealth  *BioHealthResp `protobuf:\"bytes,2,opt,name=health,proto3\" json:\"health,omitempty\"` // optional BIO health\n}\n\nfunc (x *SmdQueryResp_SmdDeviceWithHealth) Reset() {\n\t*x = SmdQueryResp_SmdDeviceWithHealth{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[16]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdQueryResp_SmdDeviceWithHealth) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdQueryResp_SmdDeviceWithHealth) ProtoMessage() {}\n\nfunc (x *SmdQueryResp_SmdDeviceWithHealth) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[16]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdQueryResp_SmdDeviceWithHealth.ProtoReflect.Descriptor instead.\nfunc (*SmdQueryResp_SmdDeviceWithHealth) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{8, 0}\n}\n\nfunc (x *SmdQueryResp_SmdDeviceWithHealth) GetDetails() *SmdDevice {\n\tif x != nil {\n\t\treturn x.Details\n\t}\n\treturn nil\n}\n\nfunc (x *SmdQueryResp_SmdDeviceWithHealth) GetHealth() *BioHealthResp {\n\tif x != nil {\n\t\treturn x.Health\n\t}\n\treturn nil\n}\n\ntype SmdQueryResp_Pool struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUuid   string   `protobuf:\"bytes,1,opt,name=uuid,proto3\" json:\"uuid,omitempty\"`                           // UUID of VOS pool\n\tTgtIds []int32  `protobuf:\"varint,2,rep,packed,name=tgt_ids,json=tgtIds,proto3\" json:\"tgt_ids,omitempty\"` // VOS target IDs\n\tBlobs  []uint64 `protobuf:\"varint,3,rep,packed,name=blobs,proto3\" json:\"blobs,omitempty\"`                 // SPDK blobs\n}\n\nfunc (x *SmdQueryResp_Pool) Reset() {\n\t*x = SmdQueryResp_Pool{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[17]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdQueryResp_Pool) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdQueryResp_Pool) ProtoMessage() {}\n\nfunc (x *SmdQueryResp_Pool) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[17]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdQueryResp_Pool.ProtoReflect.Descriptor instead.\nfunc (*SmdQueryResp_Pool) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{8, 1}\n}\n\nfunc (x *SmdQueryResp_Pool) GetUuid() string {\n\tif x != nil {\n\t\treturn x.Uuid\n\t}\n\treturn \"\"\n}\n\nfunc (x *SmdQueryResp_Pool) GetTgtIds() []int32 {\n\tif x != nil {\n\t\treturn x.TgtIds\n\t}\n\treturn nil\n}\n\nfunc (x *SmdQueryResp_Pool) GetBlobs() []uint64 {\n\tif x != nil {\n\t\treturn x.Blobs\n\t}\n\treturn nil\n}\n\ntype SmdQueryResp_RankResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tRank    uint32                              `protobuf:\"varint,1,opt,name=rank,proto3\" json:\"rank,omitempty\"`      // rank to which this response corresponds\n\tDevices []*SmdQueryResp_SmdDeviceWithHealth `protobuf:\"bytes,2,rep,name=devices,proto3\" json:\"devices,omitempty\"` // List of devices on the rank\n\tPools   []*SmdQueryResp_Pool                `protobuf:\"bytes,3,rep,name=pools,proto3\" json:\"pools,omitempty\"`     // List of pools on the rank\n}\n\nfunc (x *SmdQueryResp_RankResp) Reset() {\n\t*x = SmdQueryResp_RankResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[18]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdQueryResp_RankResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdQueryResp_RankResp) ProtoMessage() {}\n\nfunc (x *SmdQueryResp_RankResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[18]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdQueryResp_RankResp.ProtoReflect.Descriptor instead.\nfunc (*SmdQueryResp_RankResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{8, 2}\n}\n\nfunc (x *SmdQueryResp_RankResp) GetRank() uint32 {\n\tif x != nil {\n\t\treturn x.Rank\n\t}\n\treturn 0\n}\n\nfunc (x *SmdQueryResp_RankResp) GetDevices() []*SmdQueryResp_SmdDeviceWithHealth {\n\tif x != nil {\n\t\treturn x.Devices\n\t}\n\treturn nil\n}\n\nfunc (x *SmdQueryResp_RankResp) GetPools() []*SmdQueryResp_Pool {\n\tif x != nil {\n\t\treturn x.Pools\n\t}\n\treturn nil\n}\n\ntype SmdManageResp_Result struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tStatus int32      `protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\"` // DAOS error code\n\tDevice *SmdDevice `protobuf:\"bytes,2,opt,name=device,proto3\" json:\"device,omitempty\"`\n}\n\nfunc (x *SmdManageResp_Result) Reset() {\n\t*x = SmdManageResp_Result{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[19]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdManageResp_Result) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdManageResp_Result) ProtoMessage() {}\n\nfunc (x *SmdManageResp_Result) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[19]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdManageResp_Result.ProtoReflect.Descriptor instead.\nfunc (*SmdManageResp_Result) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{14, 0}\n}\n\nfunc (x *SmdManageResp_Result) GetStatus() int32 {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn 0\n}\n\nfunc (x *SmdManageResp_Result) GetDevice() *SmdDevice {\n\tif x != nil {\n\t\treturn x.Device\n\t}\n\treturn nil\n}\n\ntype SmdManageResp_RankResp struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tRank    uint32                  `protobuf:\"varint,1,opt,name=rank,proto3\" json:\"rank,omitempty\"`      // Rank to which this response corresponds\n\tResults []*SmdManageResp_Result `protobuf:\"bytes,2,rep,name=results,proto3\" json:\"results,omitempty\"` // List of device results on the rank\n}\n\nfunc (x *SmdManageResp_RankResp) Reset() {\n\t*x = SmdManageResp_RankResp{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_ctl_smd_proto_msgTypes[20]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SmdManageResp_RankResp) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SmdManageResp_RankResp) ProtoMessage() {}\n\nfunc (x *SmdManageResp_RankResp) ProtoReflect() protoreflect.Message {\n\tmi := &file_ctl_smd_proto_msgTypes[20]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SmdManageResp_RankResp.ProtoReflect.Descriptor instead.\nfunc (*SmdManageResp_RankResp) Descriptor() ([]byte, []int) {\n\treturn file_ctl_smd_proto_rawDescGZIP(), []int{14, 1}\n}\n\nfunc (x *SmdManageResp_RankResp) GetRank() uint32 {\n\tif x != nil {\n\t\treturn x.Rank\n\t}\n\treturn 0\n}\n\nfunc (x *SmdManageResp_RankResp) GetResults() []*SmdManageResp_Result {\n\tif x != nil {\n\t\treturn x.Results\n\t}\n\treturn nil\n}\n\nvar File_ctl_smd_proto protoreflect.FileDescriptor\n\nvar file_ctl_smd_proto_rawDesc = []byte{\n\t0x0a, 0x0d, 0x63, 0x74, 0x6c, 0x2f, 0x73, 0x6d, 0x64, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,\n\t0x03, 0x63, 0x74, 0x6c, 0x22, 0x61, 0x0a, 0x0c, 0x42, 0x69, 0x6f, 0x48, 0x65, 0x61, 0x6c, 0x74,\n\t0x68, 0x52, 0x65, 0x71, 0x12, 0x19, 0x0a, 0x08, 0x64, 0x65, 0x76, 0x5f, 0x75, 0x75, 0x69, 0x64,\n\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x76, 0x55, 0x75, 0x69, 0x64, 0x12,\n\t0x1b, 0x0a, 0x09, 0x6d, 0x65, 0x74, 0x61, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01,\n\t0x28, 0x04, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x19, 0x0a, 0x08,\n\t0x72, 0x64, 0x62, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07,\n\t0x72, 0x64, 0x62, 0x53, 0x69, 0x7a, 0x65, 0x22, 0xdd, 0x0e, 0x0a, 0x0d, 0x42, 0x69, 0x6f, 0x48,\n\t0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d,\n\t0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69,\n\t0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x24, 0x0a, 0x0e, 0x77, 0x61, 0x72, 0x6e, 0x5f,\n\t0x74, 0x65, 0x6d, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52,\n\t0x0c, 0x77, 0x61, 0x72, 0x6e, 0x54, 0x65, 0x6d, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x24, 0x0a,\n\t0x0e, 0x63, 0x72, 0x69, 0x74, 0x5f, 0x74, 0x65, 0x6d, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18,\n\t0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x63, 0x72, 0x69, 0x74, 0x54, 0x65, 0x6d, 0x70, 0x54,\n\t0x69, 0x6d, 0x65, 0x12, 0x24, 0x0a, 0x0e, 0x63, 0x74, 0x72, 0x6c, 0x5f, 0x62, 0x75, 0x73, 0x79,\n\t0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x63, 0x74, 0x72,\n\t0x6c, 0x42, 0x75, 0x73, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x6f, 0x77,\n\t0x65, 0x72, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0b, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x43, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x12, 0x24, 0x0a, 0x0e,\n\t0x70, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x6f, 0x6e, 0x5f, 0x68, 0x6f, 0x75, 0x72, 0x73, 0x18, 0x09,\n\t0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x4f, 0x6e, 0x48, 0x6f, 0x75,\n\t0x72, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x75, 0x6e, 0x73, 0x61, 0x66, 0x65, 0x5f, 0x73, 0x68, 0x75,\n\t0x74, 0x64, 0x6f, 0x77, 0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x75, 0x6e,\n\t0x73, 0x61, 0x66, 0x65, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x73, 0x12, 0x1d, 0x0a,\n\t0x0a, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x5f, 0x65, 0x72, 0x72, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28,\n\t0x04, 0x52, 0x09, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x45, 0x72, 0x72, 0x73, 0x12, 0x26, 0x0a, 0x0f,\n\t0x65, 0x72, 0x72, 0x5f, 0x6c, 0x6f, 0x67, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18,\n\t0x0c, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x65, 0x72, 0x72, 0x4c, 0x6f, 0x67, 0x45, 0x6e, 0x74,\n\t0x72, 0x69, 0x65, 0x73, 0x12, 0x22, 0x0a, 0x0d, 0x62, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64,\n\t0x5f, 0x65, 0x72, 0x72, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x62, 0x69, 0x6f,\n\t0x52, 0x65, 0x61, 0x64, 0x45, 0x72, 0x72, 0x73, 0x12, 0x24, 0x0a, 0x0e, 0x62, 0x69, 0x6f, 0x5f,\n\t0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x65, 0x72, 0x72, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d,\n\t0x52, 0x0c, 0x62, 0x69, 0x6f, 0x57, 0x72, 0x69, 0x74, 0x65, 0x45, 0x72, 0x72, 0x73, 0x12, 0x24,\n\t0x0a, 0x0e, 0x62, 0x69, 0x6f, 0x5f, 0x75, 0x6e, 0x6d, 0x61, 0x70, 0x5f, 0x65, 0x72, 0x72, 0x73,\n\t0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x62, 0x69, 0x6f, 0x55, 0x6e, 0x6d, 0x61, 0x70,\n\t0x45, 0x72, 0x72, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d,\n\t0x5f, 0x65, 0x72, 0x72, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x63, 0x68, 0x65,\n\t0x63, 0x6b, 0x73, 0x75, 0x6d, 0x45, 0x72, 0x72, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x6d,\n\t0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b,\n\t0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x74,\n\t0x65, 0x6d, 0x70, 0x5f, 0x77, 0x61, 0x72, 0x6e, 0x18, 0x12, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,\n\t0x74, 0x65, 0x6d, 0x70, 0x57, 0x61, 0x72, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x61, 0x76, 0x61, 0x69,\n\t0x6c, 0x5f, 0x73, 0x70, 0x61, 0x72, 0x65, 0x5f, 0x77, 0x61, 0x72, 0x6e, 0x18, 0x13, 0x20, 0x01,\n\t0x28, 0x08, 0x52, 0x0e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x53, 0x70, 0x61, 0x72, 0x65, 0x57, 0x61,\n\t0x72, 0x6e, 0x12, 0x30, 0x0a, 0x14, 0x64, 0x65, 0x76, 0x5f, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62,\n\t0x69, 0x6c, 0x69, 0x74, 0x79, 0x5f, 0x77, 0x61, 0x72, 0x6e, 0x18, 0x14, 0x20, 0x01, 0x28, 0x08,\n\t0x52, 0x12, 0x64, 0x65, 0x76, 0x52, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79,\n\t0x57, 0x61, 0x72, 0x6e, 0x12, 0x24, 0x0a, 0x0e, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c,\n\t0x79, 0x5f, 0x77, 0x61, 0x72, 0x6e, 0x18, 0x15, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x72, 0x65,\n\t0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x57, 0x61, 0x72, 0x6e, 0x12, 0x2a, 0x0a, 0x11, 0x76, 0x6f,\n\t0x6c, 0x61, 0x74, 0x69, 0x6c, 0x65, 0x5f, 0x6d, 0x65, 0x6d, 0x5f, 0x77, 0x61, 0x72, 0x6e, 0x18,\n\t0x16, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x76, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6c, 0x65, 0x4d,\n\t0x65, 0x6d, 0x57, 0x61, 0x72, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,\n\t0x18, 0x17, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x19,\n\t0x0a, 0x08, 0x64, 0x65, 0x76, 0x5f, 0x75, 0x75, 0x69, 0x64, 0x18, 0x18, 0x20, 0x01, 0x28, 0x09,\n\t0x52, 0x07, 0x64, 0x65, 0x76, 0x55, 0x75, 0x69, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74,\n\t0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a,\n\t0x74, 0x6f, 0x74, 0x61, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76,\n\t0x61, 0x69, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0a, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x31, 0x0a, 0x15, 0x70,\n\t0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x63, 0x6e, 0x74, 0x5f,\n\t0x6e, 0x6f, 0x72, 0x6d, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x70, 0x72, 0x6f, 0x67,\n\t0x72, 0x61, 0x6d, 0x46, 0x61, 0x69, 0x6c, 0x43, 0x6e, 0x74, 0x4e, 0x6f, 0x72, 0x6d, 0x12, 0x2f,\n\t0x0a, 0x14, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x63,\n\t0x6e, 0x74, 0x5f, 0x72, 0x61, 0x77, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x70, 0x72,\n\t0x6f, 0x67, 0x72, 0x61, 0x6d, 0x46, 0x61, 0x69, 0x6c, 0x43, 0x6e, 0x74, 0x52, 0x61, 0x77, 0x12,\n\t0x2d, 0x0a, 0x13, 0x65, 0x72, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x63, 0x6e,\n\t0x74, 0x5f, 0x6e, 0x6f, 0x72, 0x6d, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x65, 0x72,\n\t0x61, 0x73, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x43, 0x6e, 0x74, 0x4e, 0x6f, 0x72, 0x6d, 0x12, 0x2b,\n\t0x0a, 0x12, 0x65, 0x72, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x63, 0x6e, 0x74,\n\t0x5f, 0x72, 0x61, 0x77, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x65, 0x72, 0x61, 0x73,\n\t0x65, 0x46, 0x61, 0x69, 0x6c, 0x43, 0x6e, 0x74, 0x52, 0x61, 0x77, 0x12, 0x33, 0x0a, 0x16, 0x77,\n\t0x65, 0x61, 0x72, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6e, 0x74,\n\t0x5f, 0x6e, 0x6f, 0x72, 0x6d, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x13, 0x77, 0x65, 0x61,\n\t0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x43, 0x6e, 0x74, 0x4e, 0x6f, 0x72, 0x6d,\n\t0x12, 0x31, 0x0a, 0x15, 0x77, 0x65, 0x61, 0x72, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e,\n\t0x67, 0x5f, 0x63, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x18, 0x20, 0x20, 0x01, 0x28, 0x0d, 0x52,\n\t0x12, 0x77, 0x65, 0x61, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x43, 0x6e, 0x74,\n\t0x4d, 0x69, 0x6e, 0x12, 0x31, 0x0a, 0x15, 0x77, 0x65, 0x61, 0x72, 0x5f, 0x6c, 0x65, 0x76, 0x65,\n\t0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6e, 0x74, 0x5f, 0x6d, 0x61, 0x78, 0x18, 0x21, 0x20, 0x01,\n\t0x28, 0x0d, 0x52, 0x12, 0x77, 0x65, 0x61, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e, 0x67,\n\t0x43, 0x6e, 0x74, 0x4d, 0x61, 0x78, 0x12, 0x31, 0x0a, 0x15, 0x77, 0x65, 0x61, 0x72, 0x5f, 0x6c,\n\t0x65, 0x76, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6e, 0x74, 0x5f, 0x61, 0x76, 0x67, 0x18,\n\t0x22, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x77, 0x65, 0x61, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c,\n\t0x69, 0x6e, 0x67, 0x43, 0x6e, 0x74, 0x41, 0x76, 0x67, 0x12, 0x2f, 0x0a, 0x14, 0x65, 0x6e, 0x64,\n\t0x74, 0x6f, 0x65, 0x6e, 0x64, 0x5f, 0x65, 0x72, 0x72, 0x5f, 0x63, 0x6e, 0x74, 0x5f, 0x72, 0x61,\n\t0x77, 0x18, 0x23, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x65, 0x6e, 0x64, 0x74, 0x6f, 0x65, 0x6e,\n\t0x64, 0x45, 0x72, 0x72, 0x43, 0x6e, 0x74, 0x52, 0x61, 0x77, 0x12, 0x25, 0x0a, 0x0f, 0x63, 0x72,\n\t0x63, 0x5f, 0x65, 0x72, 0x72, 0x5f, 0x63, 0x6e, 0x74, 0x5f, 0x72, 0x61, 0x77, 0x18, 0x24, 0x20,\n\t0x01, 0x28, 0x04, 0x52, 0x0c, 0x63, 0x72, 0x63, 0x45, 0x72, 0x72, 0x43, 0x6e, 0x74, 0x52, 0x61,\n\t0x77, 0x12, 0x24, 0x0a, 0x0e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x5f, 0x77, 0x65, 0x61, 0x72, 0x5f,\n\t0x72, 0x61, 0x77, 0x18, 0x25, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x6d, 0x65, 0x64, 0x69, 0x61,\n\t0x57, 0x65, 0x61, 0x72, 0x52, 0x61, 0x77, 0x12, 0x24, 0x0a, 0x0e, 0x68, 0x6f, 0x73, 0x74, 0x5f,\n\t0x72, 0x65, 0x61, 0x64, 0x73, 0x5f, 0x72, 0x61, 0x77, 0x18, 0x26, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0c, 0x68, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x61, 0x64, 0x73, 0x52, 0x61, 0x77, 0x12, 0x2c, 0x0a,\n\t0x12, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x72, 0x5f,\n\t0x72, 0x61, 0x77, 0x18, 0x27, 0x20, 0x01, 0x28, 0x04, 0x52, 0x10, 0x77, 0x6f, 0x72, 0x6b, 0x6c,\n\t0x6f, 0x61, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x52, 0x61, 0x77, 0x12, 0x36, 0x0a, 0x17, 0x74,\n\t0x68, 0x65, 0x72, 0x6d, 0x61, 0x6c, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x5f,\n\t0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x28, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x15, 0x74, 0x68,\n\t0x65, 0x72, 0x6d, 0x61, 0x6c, 0x54, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x53, 0x74, 0x61,\n\t0x74, 0x75, 0x73, 0x12, 0x3b, 0x0a, 0x1a, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x61, 0x6c, 0x5f, 0x74,\n\t0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6e,\n\t0x74, 0x18, 0x29, 0x20, 0x01, 0x28, 0x04, 0x52, 0x17, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x61, 0x6c,\n\t0x54, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x43, 0x6e, 0x74,\n\t0x12, 0x39, 0x0a, 0x19, 0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72,\n\t0x5f, 0x6f, 0x76, 0x65, 0x72, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x63, 0x6e, 0x74, 0x18, 0x2a, 0x20,\n\t0x01, 0x28, 0x04, 0x52, 0x16, 0x72, 0x65, 0x74, 0x72, 0x79, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72,\n\t0x4f, 0x76, 0x65, 0x72, 0x66, 0x6c, 0x6f, 0x77, 0x43, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x11, 0x70,\n\t0x6c, 0x6c, 0x5f, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6c, 0x6f, 0x73, 0x73, 0x5f, 0x63, 0x6e, 0x74,\n\t0x18, 0x2b, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x70, 0x6c, 0x6c, 0x4c, 0x6f, 0x63, 0x6b, 0x4c,\n\t0x6f, 0x73, 0x73, 0x43, 0x6e, 0x74, 0x12, 0x2c, 0x0a, 0x12, 0x6e, 0x61, 0x6e, 0x64, 0x5f, 0x62,\n\t0x79, 0x74, 0x65, 0x73, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x18, 0x2c, 0x20, 0x01,\n\t0x28, 0x04, 0x52, 0x10, 0x6e, 0x61, 0x6e, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73, 0x57, 0x72, 0x69,\n\t0x74, 0x74, 0x65, 0x6e, 0x12, 0x2c, 0x0a, 0x12, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x62, 0x79, 0x74,\n\t0x65, 0x73, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x18, 0x2d, 0x20, 0x01, 0x28, 0x04,\n\t0x52, 0x10, 0x68, 0x6f, 0x73, 0x74, 0x42, 0x79, 0x74, 0x65, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74,\n\t0x65, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x73, 0x69,\n\t0x7a, 0x65, 0x18, 0x2e, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65,\n\t0x72, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x22, 0x0a, 0x0d, 0x6d, 0x65, 0x74, 0x61, 0x5f, 0x77, 0x61,\n\t0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x2f, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x6d, 0x65,\n\t0x74, 0x61, 0x57, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x20, 0x0a, 0x0c, 0x72, 0x64, 0x62,\n\t0x5f, 0x77, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x30, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0a, 0x72, 0x64, 0x62, 0x57, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x4a, 0x04, 0x08, 0x01, 0x10,\n\t0x02, 0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x22, 0xe4, 0x03, 0x0a, 0x09, 0x53, 0x6d, 0x64, 0x44,\n\t0x65, 0x76, 0x69, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x67, 0x74,\n\t0x5f, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x06, 0x74, 0x67, 0x74, 0x49,\n\t0x64, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x72, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x18, 0x03, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x06, 0x74, 0x72, 0x41, 0x64, 0x64, 0x72, 0x12, 0x2e, 0x0a, 0x09, 0x64,\n\t0x65, 0x76, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11,\n\t0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x4e, 0x76, 0x6d, 0x65, 0x44, 0x65, 0x76, 0x53, 0x74, 0x61, 0x74,\n\t0x65, 0x52, 0x08, 0x64, 0x65, 0x76, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x2a, 0x0a, 0x09, 0x6c,\n\t0x65, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d,\n\t0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x4c, 0x65, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x08, 0x6c,\n\t0x65, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c,\n\t0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x74, 0x6f,\n\t0x74, 0x61, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x69,\n\t0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x61,\n\t0x76, 0x61, 0x69, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x6c, 0x75,\n\t0x73, 0x74, 0x65, 0x72, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0b, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x12, 0x0a, 0x04,\n\t0x72, 0x61, 0x6e, 0x6b, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x72, 0x61, 0x6e, 0x6b,\n\t0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x18, 0x0a, 0x20,\n\t0x01, 0x28, 0x0d, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x65, 0x42, 0x69, 0x74, 0x73, 0x12, 0x1b, 0x0a,\n\t0x09, 0x6d, 0x65, 0x74, 0x61, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04,\n\t0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x22, 0x0a, 0x0d, 0x6d, 0x65,\n\t0x74, 0x61, 0x5f, 0x77, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28,\n\t0x04, 0x52, 0x0b, 0x6d, 0x65, 0x74, 0x61, 0x57, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x19,\n\t0x0a, 0x08, 0x72, 0x64, 0x62, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x04,\n\t0x52, 0x07, 0x72, 0x64, 0x62, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x20, 0x0a, 0x0c, 0x72, 0x64, 0x62,\n\t0x5f, 0x77, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x04, 0x52,\n\t0x0a, 0x72, 0x64, 0x62, 0x57, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x75,\n\t0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28,\n\t0x04, 0x52, 0x0b, 0x75, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0x0b,\n\t0x0a, 0x09, 0x53, 0x6d, 0x64, 0x44, 0x65, 0x76, 0x52, 0x65, 0x71, 0x22, 0x4e, 0x0a, 0x0a, 0x53,\n\t0x6d, 0x64, 0x44, 0x65, 0x76, 0x52, 0x65, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61,\n\t0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,\n\t0x73, 0x12, 0x28, 0x0a, 0x07, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03,\n\t0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x44, 0x65, 0x76, 0x69,\n\t0x63, 0x65, 0x52, 0x07, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x22, 0x0c, 0x0a, 0x0a, 0x53,\n\t0x6d, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x22, 0x9d, 0x01, 0x0a, 0x0b, 0x53, 0x6d,\n\t0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61,\n\t0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,\n\t0x73, 0x12, 0x2b, 0x0a, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,\n\t0x32, 0x15, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x65,\n\t0x73, 0x70, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x1a, 0x49,\n\t0x0a, 0x04, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x67,\n\t0x74, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x06, 0x74, 0x67, 0x74,\n\t0x49, 0x64, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x18, 0x03, 0x20, 0x03,\n\t0x28, 0x04, 0x52, 0x05, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x22, 0xa5, 0x01, 0x0a, 0x0b, 0x53, 0x6d,\n\t0x64, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x71, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x6d, 0x69,\n\t0x74, 0x5f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52,\n\t0x0b, 0x6f, 0x6d, 0x69, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x12, 0x1d, 0x0a, 0x0a,\n\t0x6f, 0x6d, 0x69, 0x74, 0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,\n\t0x52, 0x09, 0x6f, 0x6d, 0x69, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x69,\n\t0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x62, 0x69, 0x6f, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x74,\n\t0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65,\n\t0x42, 0x69, 0x6f, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69,\n\t0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x12, 0x0a,\n\t0x04, 0x72, 0x61, 0x6e, 0x6b, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x72, 0x61, 0x6e,\n\t0x6b, 0x22, 0xa0, 0x03, 0x0a, 0x0c, 0x53, 0x6d, 0x64, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65,\n\t0x73, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x05, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x30, 0x0a, 0x05, 0x72, 0x61,\n\t0x6e, 0x6b, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x63, 0x74, 0x6c, 0x2e,\n\t0x53, 0x6d, 0x64, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x2e, 0x52, 0x61, 0x6e,\n\t0x6b, 0x52, 0x65, 0x73, 0x70, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x6b, 0x73, 0x1a, 0x6b, 0x0a, 0x13,\n\t0x53, 0x6d, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x57, 0x69, 0x74, 0x68, 0x48, 0x65, 0x61,\n\t0x6c, 0x74, 0x68, 0x12, 0x28, 0x0a, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x44, 0x65,\n\t0x76, 0x69, 0x63, 0x65, 0x52, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x2a, 0x0a,\n\t0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e,\n\t0x63, 0x74, 0x6c, 0x2e, 0x42, 0x69, 0x6f, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x65, 0x73,\n\t0x70, 0x52, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x1a, 0x49, 0x0a, 0x04, 0x50, 0x6f, 0x6f,\n\t0x6c, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x67, 0x74, 0x5f, 0x69, 0x64, 0x73,\n\t0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x06, 0x74, 0x67, 0x74, 0x49, 0x64, 0x73, 0x12, 0x14,\n\t0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x04, 0x52, 0x05, 0x62,\n\t0x6c, 0x6f, 0x62, 0x73, 0x1a, 0x8d, 0x01, 0x0a, 0x08, 0x52, 0x61, 0x6e, 0x6b, 0x52, 0x65, 0x73,\n\t0x70, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x61, 0x6e, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52,\n\t0x04, 0x72, 0x61, 0x6e, 0x6b, 0x12, 0x3f, 0x0a, 0x07, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73,\n\t0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64,\n\t0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x2e, 0x53, 0x6d, 0x64, 0x44, 0x65, 0x76,\n\t0x69, 0x63, 0x65, 0x57, 0x69, 0x74, 0x68, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x07, 0x64,\n\t0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x12, 0x2c, 0x0a, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18,\n\t0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x51,\n\t0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x52, 0x05, 0x70,\n\t0x6f, 0x6f, 0x6c, 0x73, 0x22, 0xa7, 0x01, 0x0a, 0x0c, 0x4c, 0x65, 0x64, 0x4d, 0x61, 0x6e, 0x61,\n\t0x67, 0x65, 0x52, 0x65, 0x71, 0x12, 0x10, 0x0a, 0x03, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x03, 0x69, 0x64, 0x73, 0x12, 0x2d, 0x0a, 0x0a, 0x6c, 0x65, 0x64, 0x5f, 0x61,\n\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x63, 0x74,\n\t0x6c, 0x2e, 0x4c, 0x65, 0x64, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x6c, 0x65, 0x64,\n\t0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x09, 0x6c, 0x65, 0x64, 0x5f, 0x73, 0x74,\n\t0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x63, 0x74, 0x6c, 0x2e,\n\t0x4c, 0x65, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x08, 0x6c, 0x65, 0x64, 0x53, 0x74, 0x61,\n\t0x74, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x6c, 0x65, 0x64, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,\n\t0x6f, 0x6e, 0x5f, 0x6d, 0x69, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x6c,\n\t0x65, 0x64, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x6e, 0x73, 0x22, 0x6e,\n\t0x0a, 0x0d, 0x44, 0x65, 0x76, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x65, 0x71, 0x12,\n\t0x20, 0x0a, 0x0c, 0x6f, 0x6c, 0x64, 0x5f, 0x64, 0x65, 0x76, 0x5f, 0x75, 0x75, 0x69, 0x64, 0x18,\n\t0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6f, 0x6c, 0x64, 0x44, 0x65, 0x76, 0x55, 0x75, 0x69,\n\t0x64, 0x12, 0x20, 0x0a, 0x0c, 0x6e, 0x65, 0x77, 0x5f, 0x64, 0x65, 0x76, 0x5f, 0x75, 0x75, 0x69,\n\t0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6e, 0x65, 0x77, 0x44, 0x65, 0x76, 0x55,\n\t0x75, 0x69, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x6f, 0x5f, 0x72, 0x65, 0x69, 0x6e, 0x74, 0x18,\n\t0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6e, 0x6f, 0x52, 0x65, 0x69, 0x6e, 0x74, 0x22, 0x22,\n\t0x0a, 0x0c, 0x53, 0x65, 0x74, 0x46, 0x61, 0x75, 0x6c, 0x74, 0x79, 0x52, 0x65, 0x71, 0x12, 0x12,\n\t0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75,\n\t0x69, 0x64, 0x22, 0x4f, 0x0a, 0x0d, 0x44, 0x65, 0x76, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x52,\n\t0x65, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20,\n\t0x01, 0x28, 0x05, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x26, 0x0a, 0x06, 0x64,\n\t0x65, 0x76, 0x69, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x63, 0x74,\n\t0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x52, 0x06, 0x64, 0x65, 0x76,\n\t0x69, 0x63, 0x65, 0x22, 0x98, 0x01, 0x0a, 0x0c, 0x53, 0x6d, 0x64, 0x4d, 0x61, 0x6e, 0x61, 0x67,\n\t0x65, 0x52, 0x65, 0x71, 0x12, 0x25, 0x0a, 0x03, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,\n\t0x0b, 0x32, 0x11, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x4c, 0x65, 0x64, 0x4d, 0x61, 0x6e, 0x61, 0x67,\n\t0x65, 0x52, 0x65, 0x71, 0x48, 0x00, 0x52, 0x03, 0x6c, 0x65, 0x64, 0x12, 0x2e, 0x0a, 0x07, 0x72,\n\t0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x63,\n\t0x74, 0x6c, 0x2e, 0x44, 0x65, 0x76, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x65, 0x71,\n\t0x48, 0x00, 0x52, 0x07, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x12, 0x2b, 0x0a, 0x06, 0x66,\n\t0x61, 0x75, 0x6c, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x63, 0x74,\n\t0x6c, 0x2e, 0x53, 0x65, 0x74, 0x46, 0x61, 0x75, 0x6c, 0x74, 0x79, 0x52, 0x65, 0x71, 0x48, 0x00,\n\t0x52, 0x06, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x79, 0x42, 0x04, 0x0a, 0x02, 0x6f, 0x70, 0x22, 0xe1,\n\t0x01, 0x0a, 0x0d, 0x53, 0x6d, 0x64, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70,\n\t0x12, 0x31, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x6b, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,\n\t0x1b, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x52,\n\t0x65, 0x73, 0x70, 0x2e, 0x52, 0x61, 0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x52, 0x05, 0x72, 0x61,\n\t0x6e, 0x6b, 0x73, 0x1a, 0x48, 0x0a, 0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x16, 0x0a,\n\t0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x73,\n\t0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x26, 0x0a, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x18,\n\t0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x44,\n\t0x65, 0x76, 0x69, 0x63, 0x65, 0x52, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x1a, 0x53, 0x0a,\n\t0x08, 0x52, 0x61, 0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x61, 0x6e,\n\t0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x72, 0x61, 0x6e, 0x6b, 0x12, 0x33, 0x0a,\n\t0x07, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19,\n\t0x2e, 0x63, 0x74, 0x6c, 0x2e, 0x53, 0x6d, 0x64, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x52, 0x65,\n\t0x73, 0x70, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x07, 0x72, 0x65, 0x73, 0x75, 0x6c,\n\t0x74, 0x73, 0x2a, 0x4c, 0x0a, 0x0c, 0x4e, 0x76, 0x6d, 0x65, 0x44, 0x65, 0x76, 0x53, 0x74, 0x61,\n\t0x74, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12,\n\t0x0a, 0x0a, 0x06, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x4e,\n\t0x45, 0x57, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x56, 0x49, 0x43, 0x54, 0x45, 0x44, 0x10,\n\t0x03, 0x12, 0x0d, 0x0a, 0x09, 0x55, 0x4e, 0x50, 0x4c, 0x55, 0x47, 0x47, 0x45, 0x44, 0x10, 0x04,\n\t0x2a, 0x44, 0x0a, 0x08, 0x4c, 0x65, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x07, 0x0a, 0x03,\n\t0x4f, 0x46, 0x46, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x51, 0x55, 0x49, 0x43, 0x4b, 0x5f, 0x42,\n\t0x4c, 0x49, 0x4e, 0x4b, 0x10, 0x01, 0x12, 0x06, 0x0a, 0x02, 0x4f, 0x4e, 0x10, 0x02, 0x12, 0x0e,\n\t0x0a, 0x0a, 0x53, 0x4c, 0x4f, 0x57, 0x5f, 0x42, 0x4c, 0x49, 0x4e, 0x4b, 0x10, 0x03, 0x12, 0x06,\n\t0x0a, 0x02, 0x4e, 0x41, 0x10, 0x04, 0x2a, 0x28, 0x0a, 0x09, 0x4c, 0x65, 0x64, 0x41, 0x63, 0x74,\n\t0x69, 0x6f, 0x6e, 0x12, 0x07, 0x0a, 0x03, 0x47, 0x45, 0x54, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03,\n\t0x53, 0x45, 0x54, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x45, 0x53, 0x45, 0x54, 0x10, 0x02,\n\t0x42, 0x39, 0x5a, 0x37, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x64,\n\t0x61, 0x6f, 0x73, 0x2d, 0x73, 0x74, 0x61, 0x63, 0x6b, 0x2f, 0x64, 0x61, 0x6f, 0x73, 0x2f, 0x73,\n\t0x72, 0x63, 0x2f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,\n\t0x6e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x74, 0x6c, 0x62, 0x06, 0x70, 0x72, 0x6f,\n\t0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_ctl_smd_proto_rawDescOnce sync.Once\n\tfile_ctl_smd_proto_rawDescData = file_ctl_smd_proto_rawDesc\n)\n\nfunc file_ctl_smd_proto_rawDescGZIP() []byte {\n\tfile_ctl_smd_proto_rawDescOnce.Do(func() {\n\t\tfile_ctl_smd_proto_rawDescData = protoimpl.X.CompressGZIP(file_ctl_smd_proto_rawDescData)\n\t})\n\treturn file_ctl_smd_proto_rawDescData\n}\n\nvar file_ctl_smd_proto_enumTypes = make([]protoimpl.EnumInfo, 3)\nvar file_ctl_smd_proto_msgTypes = make([]protoimpl.MessageInfo, 21)\nvar file_ctl_smd_proto_goTypes = []interface{}{\n\t(NvmeDevState)(0),                        // 0: ctl.NvmeDevState\n\t(LedState)(0),                            // 1: ctl.LedState\n\t(LedAction)(0),                           // 2: ctl.LedAction\n\t(*BioHealthReq)(nil),                     // 3: ctl.BioHealthReq\n\t(*BioHealthResp)(nil),                    // 4: ctl.BioHealthResp\n\t(*SmdDevice)(nil),                        // 5: ctl.SmdDevice\n\t(*SmdDevReq)(nil),                        // 6: ctl.SmdDevReq\n\t(*SmdDevResp)(nil),                       // 7: ctl.SmdDevResp\n\t(*SmdPoolReq)(nil),                       // 8: ctl.SmdPoolReq\n\t(*SmdPoolResp)(nil),                      // 9: ctl.SmdPoolResp\n\t(*SmdQueryReq)(nil),                      // 10: ctl.SmdQueryReq\n\t(*SmdQueryResp)(nil),                     // 11: ctl.SmdQueryResp\n\t(*LedManageReq)(nil),                     // 12: ctl.LedManageReq\n\t(*DevReplaceReq)(nil),                    // 13: ctl.DevReplaceReq\n\t(*SetFaultyReq)(nil),                     // 14: ctl.SetFaultyReq\n\t(*DevManageResp)(nil),                    // 15: ctl.DevManageResp\n\t(*SmdManageReq)(nil),                     // 16: ctl.SmdManageReq\n\t(*SmdManageResp)(nil),                    // 17: ctl.SmdManageResp\n\t(*SmdPoolResp_Pool)(nil),                 // 18: ctl.SmdPoolResp.Pool\n\t(*SmdQueryResp_SmdDeviceWithHealth)(nil), // 19: ctl.SmdQueryResp.SmdDeviceWithHealth\n\t(*SmdQueryResp_Pool)(nil),                // 20: ctl.SmdQueryResp.Pool\n\t(*SmdQueryResp_RankResp)(nil),            // 21: ctl.SmdQueryResp.RankResp\n\t(*SmdManageResp_Result)(nil),             // 22: ctl.SmdManageResp.Result\n\t(*SmdManageResp_RankResp)(nil),           // 23: ctl.SmdManageResp.RankResp\n}\nvar file_ctl_smd_proto_depIdxs = []int32{\n\t0,  // 0: ctl.SmdDevice.dev_state:type_name -> ctl.NvmeDevState\n\t1,  // 1: ctl.SmdDevice.led_state:type_name -> ctl.LedState\n\t5,  // 2: ctl.SmdDevResp.devices:type_name -> ctl.SmdDevice\n\t18, // 3: ctl.SmdPoolResp.pools:type_name -> ctl.SmdPoolResp.Pool\n\t21, // 4: ctl.SmdQueryResp.ranks:type_name -> ctl.SmdQueryResp.RankResp\n\t2,  // 5: ctl.LedManageReq.led_action:type_name -> ctl.LedAction\n\t1,  // 6: ctl.LedManageReq.led_state:type_name -> ctl.LedState\n\t5,  // 7: ctl.DevManageResp.device:type_name -> ctl.SmdDevice\n\t12, // 8: ctl.SmdManageReq.led:type_name -> ctl.LedManageReq\n\t13, // 9: ctl.SmdManageReq.replace:type_name -> ctl.DevReplaceReq\n\t14, // 10: ctl.SmdManageReq.faulty:type_name -> ctl.SetFaultyReq\n\t23, // 11: ctl.SmdManageResp.ranks:type_name -> ctl.SmdManageResp.RankResp\n\t5,  // 12: ctl.SmdQueryResp.SmdDeviceWithHealth.details:type_name -> ctl.SmdDevice\n\t4,  // 13: ctl.SmdQueryResp.SmdDeviceWithHealth.health:type_name -> ctl.BioHealthResp\n\t19, // 14: ctl.SmdQueryResp.RankResp.devices:type_name -> ctl.SmdQueryResp.SmdDeviceWithHealth\n\t20, // 15: ctl.SmdQueryResp.RankResp.pools:type_name -> ctl.SmdQueryResp.Pool\n\t5,  // 16: ctl.SmdManageResp.Result.device:type_name -> ctl.SmdDevice\n\t22, // 17: ctl.SmdManageResp.RankResp.results:type_name -> ctl.SmdManageResp.Result\n\t18, // [18:18] is the sub-list for method output_type\n\t18, // [18:18] is the sub-list for method input_type\n\t18, // [18:18] is the sub-list for extension type_name\n\t18, // [18:18] is the sub-list for extension extendee\n\t0,  // [0:18] is the sub-list for field type_name\n}\n\nfunc init() { file_ctl_smd_proto_init() }\nfunc file_ctl_smd_proto_init() {\n\tif File_ctl_smd_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {\n\t\tfile_ctl_smd_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*BioHealthReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*BioHealthResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdDevice); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdDevReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdDevResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdPoolReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdPoolResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdQueryReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdQueryResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*LedManageReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*DevReplaceReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SetFaultyReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*DevManageResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdManageReq); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdManageResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdPoolResp_Pool); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdQueryResp_SmdDeviceWithHealth); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdQueryResp_Pool); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdQueryResp_RankResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdManageResp_Result); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_ctl_smd_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {\n\t\t\tswitch v := v.(*SmdManageResp_RankResp); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tfile_ctl_smd_proto_msgTypes[13].OneofWrappers = []interface{}{\n\t\t(*SmdManageReq_Led)(nil),\n\t\t(*SmdManageReq_Replace)(nil),\n\t\t(*SmdManageReq_Faulty)(nil),\n\t}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_ctl_smd_proto_rawDesc,\n\t\t\tNumEnums:      3,\n\t\t\tNumMessages:   21,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   0,\n\t\t},\n\t\tGoTypes:           file_ctl_smd_proto_goTypes,\n\t\tDependencyIndexes: file_ctl_smd_proto_depIdxs,\n\t\tEnumInfos:         file_ctl_smd_proto_enumTypes,\n\t\tMessageInfos:      file_ctl_smd_proto_msgTypes,\n\t}.Build()\n\tFile_ctl_smd_proto = out.File\n\tfile_ctl_smd_proto_rawDesc = nil\n\tfile_ctl_smd_proto_goTypes = nil\n\tfile_ctl_smd_proto_depIdxs = nil\n}\n"
    },
    {
      "path": "src/control/server/ctl_smd_rpc.go",
      "content": "//\n// (C) Copyright 2020-2023 Intel Corporation.\n//\n// SPDX-License-Identifier: BSD-2-Clause-Patent\n//\n\npackage server\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\tuuid \"github.com/google/uuid\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/daos-stack/daos/src/control/common\"\n\t\"github.com/daos-stack/daos/src/control/common/proto/convert\"\n\tctlpb \"github.com/daos-stack/daos/src/control/common/proto/ctl\"\n\t\"github.com/daos-stack/daos/src/control/drpc\"\n\t\"github.com/daos-stack/daos/src/control/lib/daos\"\n\t\"github.com/daos-stack/daos/src/control/lib/hardware\"\n\t\"github.com/daos-stack/daos/src/control/lib/ranklist\"\n\t\"github.com/daos-stack/daos/src/control/logging\"\n)\n\n// Set as variables so can be overwritten during unit testing.\nvar (\n\tbaseDevReplaceBackoff      = 250 * time.Millisecond\n\tmaxDevReplaceBackoffFactor = 7 // 8s\n\tmaxDevReplaceRetries       = 20\n)\n\nfunc queryRank(reqRank uint32, engineRank ranklist.Rank) bool {\n\trr := ranklist.Rank(reqRank)\n\tif rr.Equals(ranklist.NilRank) {\n\t\treturn true\n\t}\n\treturn rr.Equals(engineRank)\n}\n\nfunc (svc *ControlService) querySmdDevices(ctx context.Context, req *ctlpb.SmdQueryReq, resp *ctlpb.SmdQueryResp) error {\n\tfor _, ei := range svc.harness.Instances() {\n\t\tif !ei.IsReady() {\n\t\t\tsvc.log.Debugf(\"skipping not-ready instance %d\", ei.Index())\n\t\t\tcontinue\n\t\t}\n\n\t\tengineRank, err := ei.GetRank()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !queryRank(req.GetRank(), engineRank) {\n\t\t\tcontinue\n\t\t}\n\n\t\trResp := new(ctlpb.SmdQueryResp_RankResp)\n\t\trResp.Rank = engineRank.Uint32()\n\n\t\tlistDevsResp, err := ei.ListSmdDevices(ctx, new(ctlpb.SmdDevReq))\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"rank %d\", engineRank)\n\t\t}\n\n\t\tif len(listDevsResp.Devices) == 0 {\n\t\t\trResp.Devices = nil\n\t\t\tresp.Ranks = append(resp.Ranks, rResp)\n\t\t\tcontinue\n\t\t}\n\n\t\t// For each SmdDevice returned in list devs response, append a SmdDeviceWithHealth.\n\t\tfor _, sd := range listDevsResp.Devices {\n\t\t\trResp.Devices = append(rResp.Devices, &ctlpb.SmdQueryResp_SmdDeviceWithHealth{\n\t\t\t\tDetails: sd,\n\t\t\t})\n\t\t}\n\t\tresp.Ranks = append(resp.Ranks, rResp)\n\n\t\tif req.Uuid != \"\" {\n\t\t\tfound := false\n\t\t\tfor _, dev := range rResp.Devices {\n\t\t\t\tif dev.Details.Uuid == req.Uuid {\n\t\t\t\t\trResp.Devices = []*ctlpb.SmdQueryResp_SmdDeviceWithHealth{dev}\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\trResp.Devices = nil\n\t\t\t}\n\t\t}\n\n\t\tfor _, dev := range rResp.Devices {\n\t\t\tstate := dev.Details.DevState\n\n\t\t\t// skip health query if the device is not in a normal or faulty state\n\t\t\tif req.IncludeBioHealth {\n\t\t\t\tif state != ctlpb.NvmeDevState_NEW {\n\t\t\t\t\thealth, err := ei.GetBioHealth(ctx, &ctlpb.BioHealthReq{\n\t\t\t\t\t\tDevUuid: dev.Details.Uuid,\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.Wrapf(err, \"device %q, state %q\",\n\t\t\t\t\t\t\tdev, state)\n\t\t\t\t\t}\n\t\t\t\t\tdev.Health = health\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsvc.log.Debugf(\"skip fetching health stats on device %q in NEW state\",\n\t\t\t\t\tdev, state)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (svc *ControlService) querySmdPools(ctx context.Context, req *ctlpb.SmdQueryReq, resp *ctlpb.SmdQueryResp) error {\n\tfor _, ei := range svc.harness.Instances() {\n\t\tif !ei.IsReady() {\n\t\t\tsvc.log.Debugf(\"skipping not-ready instance\")\n\t\t\tcontinue\n\t\t}\n\n\t\tengineRank, err := ei.GetRank()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !queryRank(req.GetRank(), engineRank) {\n\t\t\tcontinue\n\t\t}\n\n\t\trResp := new(ctlpb.SmdQueryResp_RankResp)\n\t\trResp.Rank = engineRank.Uint32()\n\n\t\tdresp, err := ei.CallDrpc(ctx, drpc.MethodSmdPools, new(ctlpb.SmdPoolReq))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trankDevResp := new(ctlpb.SmdPoolResp)\n\t\tif err = proto.Unmarshal(dresp.Body, rankDevResp); err != nil {\n\t\t\treturn errors.Wrap(err, \"unmarshal SmdListPools response\")\n\t\t}\n\n\t\tif rankDevResp.Status != 0 {\n\t\t\treturn errors.Wrapf(daos.Status(rankDevResp.Status),\n\t\t\t\t\"rank %d ListPools failed\", engineRank)\n\t\t}\n\n\t\tif err := convert.Types(rankDevResp.Pools, &rResp.Pools); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to convert pool list\")\n\t\t}\n\t\tresp.Ranks = append(resp.Ranks, rResp)\n\n\t\tif req.Uuid != \"\" {\n\t\t\tfound := false\n\t\t\tfor _, pool := range rResp.Pools {\n\t\t\t\tif pool.Uuid == req.Uuid {\n\t\t\t\t\trResp.Pools = []*ctlpb.SmdQueryResp_Pool{pool}\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\trResp.Pools = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// SmdQuery implements the method defined for the Management Service.\n//\n// Query SMD info for pools or devices.\nfunc (svc *ControlService) SmdQuery(ctx context.Context, req *ctlpb.SmdQueryReq) (*ctlpb.SmdQueryResp, error) {\n\tif !svc.harness.isStarted() {\n\t\treturn nil, FaultHarnessNotStarted\n\t}\n\tif len(svc.harness.readyRanks()) == 0 {\n\t\treturn nil, FaultDataPlaneNotStarted\n\t}\n\n\tif req.Uuid != \"\" && (!req.OmitDevices && !req.OmitPools) {\n\t\treturn nil, errors.New(\"UUID is ambiguous when querying both pools and devices\")\n\t}\n\n\tresp := new(ctlpb.SmdQueryResp)\n\tif !req.OmitDevices {\n\t\tif err := svc.querySmdDevices(ctx, req, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif !req.OmitPools {\n\t\tif err := svc.querySmdPools(ctx, req, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\ntype idMap map[string]bool\n\nfunc (im idMap) Keys() (keys []string) {\n\tfor k := range im {\n\t\tkeys = append(keys, k)\n\t}\n\treturn\n}\n\n// Split IDs in comma separated string and assign each token to relevant return list.\nfunc extractReqIDs(log logging.Logger, ids string, addrs idMap, uuids idMap) error {\n\ttokens := strings.Split(ids, \",\")\n\n\tfor _, token := range tokens {\n\t\tif addr, e := hardware.NewPCIAddress(token); e == nil && addr.IsVMDBackingAddress() {\n\t\t\taddrs[addr.String()] = true\n\t\t\tcontinue\n\t\t}\n\n\t\tif uuid, e := uuid.Parse(token); e == nil {\n\t\t\tuuids[uuid.String()] = true\n\t\t\tcontinue\n\t\t}\n\n\t\treturn errors.Errorf(\"req id entry %q is neither a valid vmd backing device pci \"+\n\t\t\t\"address or uuid\", token)\n\t}\n\n\treturn nil\n}\n\n// Union type containing either traddr or uuid.\ntype devID struct {\n\ttrAddr string\n\tuuid   string\n}\n\nfunc (id *devID) String() string {\n\tif id.trAddr != \"\" {\n\t\treturn id.trAddr\n\t}\n\treturn id.uuid\n}\n\ntype devIDMap map[string]devID\n\nfunc (dim devIDMap) getFirst() *devID {\n\tif len(dim) == 0 {\n\t\treturn nil\n\t}\n\n\tvar keys []string\n\tfor key := range dim {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\td := dim[keys[0]]\n\treturn &d\n}\n\ntype engineDevMap map[Engine]devIDMap\n\nfunc (edm engineDevMap) add(e Engine, id devID) {\n\tif _, exists := edm[e]; !exists {\n\t\tedm[e] = make(devIDMap)\n\t}\n\tif _, exists := edm[e][id.String()]; !exists {\n\t\tedm[e][id.String()] = id\n\t}\n}\n\n// Map requested device IDs provided in comma-separated string to the engine that controls the given\n// device. Device can be identified either by UUID or transport (PCI) address.\nfunc (svc *ControlService) mapIDsToEngine(ctx context.Context, ids string, useTrAddr bool) (engineDevMap, error) {\n\ttrAddrs := make(idMap)\n\tdevUUIDs := make(idMap)\n\tmatchAll := false\n\n\tif ids == \"\" {\n\t\t// Selecting all is not supported unless using transport addresses.\n\t\tif !useTrAddr {\n\t\t\treturn nil, errors.New(\"empty id string\")\n\t\t}\n\t\tmatchAll = true\n\t} else {\n\t\t// Extract transport addresses and device UUIDs from IDs string.\n\t\tif err := extractReqIDs(svc.log, ids, trAddrs, devUUIDs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq := &ctlpb.SmdQueryReq{Rank: uint32(ranklist.NilRank)}\n\tresp := new(ctlpb.SmdQueryResp)\n\tif err := svc.querySmdDevices(ctx, req, resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\tedm := make(engineDevMap)\n\n\tfor _, rr := range resp.Ranks {\n\t\tengines, err := svc.harness.FilterInstancesByRankSet(fmt.Sprintf(\"%d\", rr.Rank))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(engines) == 0 {\n\t\t\treturn nil, errors.Errorf(\"failed to retrieve instance for rank %d\",\n\t\t\t\trr.Rank)\n\t\t}\n\t\tengine := engines[0]\n\t\tfor _, dev := range rr.Devices {\n\t\t\tif dev == nil {\n\t\t\t\treturn nil, errors.New(\"nil device in smd query resp\")\n\t\t\t}\n\t\t\tdds := dev.Details\n\t\t\tif dds == nil {\n\t\t\t\treturn nil, errors.New(\"device with nil details in smd query resp\")\n\t\t\t}\n\t\t\tif dds.TrAddr == \"\" {\n\t\t\t\tsvc.log.Errorf(\"No transport address associated with device %s\",\n\t\t\t\t\tdds.Uuid)\n\t\t\t}\n\n\t\t\tmatchUUID := dds.Uuid != \"\" && devUUIDs[dds.Uuid]\n\n\t\t\t// Where possible specify the TrAddr over UUID as there may be multiple\n\t\t\t// UUIDs mapping to the same TrAddr.\n\t\t\tif useTrAddr && dds.TrAddr != \"\" {\n\t\t\t\tif matchAll || matchUUID || trAddrs[dds.TrAddr] {\n\t\t\t\t\t// If UUID matches, add by TrAddr rather than UUID which\n\t\t\t\t\t// should avoid duplicate UUID entries for the same TrAddr.\n\t\t\t\t\tedm.add(engine, devID{trAddr: dds.TrAddr})\n\t\t\t\t\tdelete(trAddrs, dds.TrAddr)\n\t\t\t\t\tdelete(devUUIDs, dds.Uuid)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif matchUUID {\n\t\t\t\t// Only add UUID entry if TrAddr is not available for a device.\n\t\t\t\tedm.add(engine, devID{uuid: dds.Uuid})\n\t\t\t\tdelete(devUUIDs, dds.Uuid)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check all input IDs have been matched.\n\tmissingKeys := append(devUUIDs.Keys(), trAddrs.Keys()...)\n\tif len(missingKeys) > 0 {\n\t\treturn nil, errors.Errorf(\"ids requested but not found: %v\", missingKeys)\n\t}\n\n\treturn edm, nil\n}\n\nfunc sendManageReq(c context.Context, e Engine, m drpc.Method, b proto.Message) (*ctlpb.SmdManageResp_Result, error) {\n\tif !e.IsReady() {\n\t\treturn &ctlpb.SmdManageResp_Result{\n\t\t\tStatus: daos.Unreachable.Int32(),\n\t\t}, nil\n\t}\n\n\tdResp, err := e.CallDrpc(c, m, b)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"call drpc\")\n\t}\n\n\tmResp := new(ctlpb.DevManageResp)\n\tif err = proto.Unmarshal(dResp.Body, mResp); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"unmarshal %T response\", mResp)\n\t}\n\n\treturn &ctlpb.SmdManageResp_Result{\n\t\tStatus: mResp.Status, Device: mResp.Device,\n\t}, nil\n}\n\nfunc addManageRespIDOnFail(log logging.Logger, res *ctlpb.SmdManageResp_Result, dev *devID) {\n\tif res == nil || dev == nil || res.Status == 0 {\n\t\treturn\n\t}\n\n\tlog.Errorf(\"drpc returned status %q on dev %+v\", daos.Status(res.Status), dev)\n\tif res.Device == nil {\n\t\t// Populate id so failure can be mapped to a device.\n\t\tres.Device = &ctlpb.SmdDevice{\n\t\t\tTrAddr: dev.trAddr, Uuid: dev.uuid,\n\t\t}\n\t}\n}\n\n// Retry dev-replace requests as state propagation may take some time after set-faulty call has\n// been made to manually trigger a faulty device state.\nfunc replaceDevRetryBusy(ctx context.Context, log logging.Logger, e Engine, req proto.Message) (res *ctlpb.SmdManageResp_Result, err error) {\n\tfor try := uint(0); try < uint(maxDevReplaceRetries); try++ {\n\t\tres, err = sendManageReq(ctx, e, drpc.MethodReplaceStorage, req)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif daos.Status(res.Status) != daos.Busy {\n\t\t\tbreak\n\t\t}\n\n\t\tbackoff := common.ExpBackoff(baseDevReplaceBackoff, uint64(try),\n\t\t\tuint64(maxDevReplaceBackoffFactor))\n\t\tlog.Debugf(\"retrying dev-replace drpc request after %s\", backoff)\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\terr = ctx.Err()\n\t\t\treturn\n\t\tcase <-time.After(backoff):\n\t\t}\n\t}\n\n\treturn\n}\n\n// SmdManage implements the method defined for the Management Service.\n//\n// Manage SMD devices.\nfunc (svc *ControlService) SmdManage(ctx context.Context, req *ctlpb.SmdManageReq) (*ctlpb.SmdManageResp, error) {\n\tif !svc.harness.isStarted() {\n\t\treturn nil, FaultHarnessNotStarted\n\t}\n\tif len(svc.harness.readyRanks()) == 0 {\n\t\treturn nil, FaultDataPlaneNotStarted\n\t}\n\n\t// Flag indicates whether Device-UUID can be replaced with its parent NVMe controller address.\n\tvar useTrAddrInReq bool\n\tvar ids string\n\n\tswitch req.Op.(type) {\n\tcase *ctlpb.SmdManageReq_Replace:\n\t\tids = req.GetReplace().OldDevUuid\n\tcase *ctlpb.SmdManageReq_Faulty:\n\t\tids = req.GetFaulty().Uuid\n\tcase *ctlpb.SmdManageReq_Led:\n\t\tuseTrAddrInReq = true\n\t\tids = req.GetLed().Ids\n\tdefault:\n\t\treturn nil, errors.Errorf(\"Unrecognized operation in SmdManageReq: %+v\", req.Op)\n\t}\n\n\t// Evaluate which engine(s) to send requests to.\n\tengineDevMap, err := svc.mapIDsToEngine(ctx, ids, useTrAddrInReq)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"mapping device identifiers to engine\")\n\t}\n\n\trankResps := []*ctlpb.SmdManageResp_RankResp{}\n\n\tfor engine, devs := range engineDevMap {\n\t\tdevResults := []*ctlpb.SmdManageResp_Result{}\n\n\t\trank, err := engine.GetRank()\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"retrieving engine rank\")\n\t\t}\n\n\t\tmsg := fmt.Sprintf(\"CtlSvc.SmdManage dispatch, rank %d: %%s req:%%+v\\n\", rank)\n\n\t\t// Extract request from oneof field and execute dRPC.\n\t\tswitch req.Op.(type) {\n\t\tcase *ctlpb.SmdManageReq_Replace:\n\t\t\tif len(devs) != 1 {\n\t\t\t\treturn nil, errors.New(\"replace request expects only one device ID\")\n\t\t\t}\n\t\t\tdReq := req.GetReplace()\n\t\t\tsvc.log.Debugf(msg, \"dev-replace\", dReq)\n\t\t\tdevRes, err := replaceDevRetryBusy(ctx, svc.log, engine, dReq)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, msg)\n\t\t\t}\n\t\t\taddManageRespIDOnFail(svc.log, devRes, devs.getFirst())\n\t\t\tdevResults = append(devResults, devRes)\n\t\tcase *ctlpb.SmdManageReq_Faulty:\n\t\t\tif len(devs) != 1 {\n\t\t\t\treturn nil, errors.New(\"set-faulty request expects only one device ID\")\n\t\t\t}\n\t\t\tdReq := req.GetFaulty()\n\t\t\tsvc.log.Debugf(msg, \"set-faulty\", dReq)\n\t\t\tdevRes, err := sendManageReq(ctx, engine, drpc.MethodSetFaultyState, dReq)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrap(err, msg)\n\t\t\t}\n\t\t\taddManageRespIDOnFail(svc.log, devRes, devs.getFirst())\n\t\t\tdevResults = append(devResults, devRes)\n\t\tcase *ctlpb.SmdManageReq_Led:\n\t\t\tif len(devs) == 0 {\n\t\t\t\t// Operate on all devices by default.\n\t\t\t\treturn nil, errors.New(\"led-manage request expects one or more IDs\")\n\t\t\t}\n\t\t\t// Multiple addresses are supported in LED request.\n\t\t\tfor _, dev := range devs {\n\t\t\t\tdReq := req.GetLed()\n\t\t\t\t// ID should by now have been resolved to a transport (PCI) address.\n\t\t\t\tif dev.trAddr == \"\" {\n\t\t\t\t\treturn nil, errors.Errorf(\"device uuid %s not resolved to a PCI address\",\n\t\t\t\t\t\tdev.uuid)\n\t\t\t\t}\n\t\t\t\tdReq.Ids = dev.trAddr\n\t\t\t\tsvc.log.Debugf(msg, \"led-manage\", dReq)\n\t\t\t\tdevRes, err := sendManageReq(ctx, engine, drpc.MethodLedManage, dReq)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, errors.Wrap(err, msg)\n\t\t\t\t}\n\t\t\t\taddManageRespIDOnFail(svc.log, devRes, &dev)\n\t\t\t\tdevResults = append(devResults, devRes)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unexpected smd manage request type\")\n\t\t}\n\n\t\trankResps = append(rankResps, &ctlpb.SmdManageResp_RankResp{\n\t\t\tRank: rank.Uint32(), Results: devResults,\n\t\t})\n\t}\n\n\tsort.Slice(rankResps, func(i, j int) bool {\n\t\treturn rankResps[i].Rank < rankResps[j].Rank\n\t})\n\n\tresp := &ctlpb.SmdManageResp{Ranks: rankResps}\n\n\treturn resp, nil\n}\n"
    },
    {
      "path": "src/control/server/harness.go",
      "content": "//\n// (C) Copyright 2019-2023 Intel Corporation.\n//\n// SPDX-License-Identifier: BSD-2-Clause-Patent\n//\n\npackage server\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/protobuf/proto\"\n\n\tcommonpb \"github.com/daos-stack/daos/src/control/common/proto\"\n\tctlpb \"github.com/daos-stack/daos/src/control/common/proto/ctl\"\n\tsrvpb \"github.com/daos-stack/daos/src/control/common/proto/srv\"\n\t\"github.com/daos-stack/daos/src/control/drpc\"\n\t\"github.com/daos-stack/daos/src/control/lib/atm\"\n\t\"github.com/daos-stack/daos/src/control/lib/ranklist\"\n\t\"github.com/daos-stack/daos/src/control/logging\"\n\t\"github.com/daos-stack/daos/src/control/server/config\"\n\t\"github.com/daos-stack/daos/src/control/server/storage\"\n\t\"github.com/daos-stack/daos/src/control/system\"\n)\n\n// Engine defines an interface to be implemented by engine instances.\n//\n// NB: This interface is way too big right now; need to refactor in order\n// to limit scope.\ntype Engine interface {\n\t// These are definitely wrong... They indicate that too much internal\n\t// information is being leaked outside of the implementation.\n\tnewCret(string, error) *ctlpb.NvmeControllerResult\n\ttryDrpc(context.Context, drpc.Method) *system.MemberResult\n\trequestStart(context.Context)\n\tupdateInUseBdevs(context.Context, []storage.NvmeController, uint64, uint64) ([]storage.NvmeController, error)\n\tisAwaitingFormat() bool\n\n\t// These methods should probably be replaced by callbacks.\n\tNotifyDrpcReady(*srvpb.NotifyReadyReq)\n\tNotifyStorageReady()\n\tBioErrorNotify(*srvpb.BioErrorReq)\n\n\t// These methods should probably be refactored out into functions that\n\t// accept the engine instance as a parameter.\n\tGetBioHealth(context.Context, *ctlpb.BioHealthReq) (*ctlpb.BioHealthResp, error)\n\tScanBdevTiers() ([]storage.BdevTierScanResult, error)\n\tListSmdDevices(context.Context, *ctlpb.SmdDevReq) (*ctlpb.SmdDevResp, error)\n\tStorageFormatSCM(context.Context, bool) *ctlpb.ScmMountResult\n\tStorageFormatNVMe() commonpb.NvmeControllerResults\n\n\t// This is a more reasonable surface that will be easier to maintain and test.\n\tCallDrpc(context.Context, drpc.Method, proto.Message) (*drpc.Response, error)\n\tGetRank() (ranklist.Rank, error)\n\tGetTargetCount() int\n\tIndex() uint32\n\tIsStarted() bool\n\tIsReady() bool\n\tLocalState() system.MemberState\n\tRemoveSuperblock() error\n\tRun(context.Context, bool)\n\tSetupRank(context.Context, ranklist.Rank, uint32) error\n\tStop(os.Signal) error\n\tOnInstanceExit(...onInstanceExitFn)\n\tOnReady(...onReadyFn)\n\tGetStorage() *storage.Provider\n}\n\n// EngineHarness is responsible for managing Engine instances.\ntype EngineHarness struct {\n\tsync.RWMutex\n\tlog           logging.Logger\n\tinstances     []Engine\n\tstarted       atm.Bool\n\tfaultDomain   *system.FaultDomain\n\tonDrpcFailure []func(context.Context, error)\n}\n\n// NewEngineHarness returns an initialized *EngineHarness.\nfunc NewEngineHarness(log logging.Logger) *EngineHarness {\n\treturn &EngineHarness{\n\t\tlog:       log,\n\t\tinstances: make([]Engine, 0),\n\t}\n}\n\n// WithFaultDomain adds a fault domain to the EngineHarness.\nfunc (h *EngineHarness) WithFaultDomain(fd *system.FaultDomain) *EngineHarness {\n\th.faultDomain = fd\n\treturn h\n}\n\n// isStarted indicates whether the EngineHarness is in a running state.\nfunc (h *EngineHarness) isStarted() bool {\n\treturn h.started.Load()\n}\n\n// Instances safely returns harness' EngineInstances.\nfunc (h *EngineHarness) Instances() []Engine {\n\th.RLock()\n\tdefer h.RUnlock()\n\treturn h.instances\n}\n\n// FilterInstancesByRankSet returns harness' EngineInstances that match any\n// of a list of ranks derived from provided rank set string.\nfunc (h *EngineHarness) FilterInstancesByRankSet(ranks string) ([]Engine, error) {\n\th.RLock()\n\tdefer h.RUnlock()\n\n\trankList, err := ranklist.ParseRanks(ranks)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tout := make([]Engine, 0)\n\n\tfor _, i := range h.instances {\n\t\tr, err := i.GetRank()\n\t\tif err != nil {\n\t\t\tcontinue // no rank to check against\n\t\t}\n\t\tif r.InList(rankList) {\n\t\t\tout = append(out, i)\n\t\t}\n\t}\n\n\treturn out, nil\n}\n\n// AddInstance adds a new Engine instance to be managed.\nfunc (h *EngineHarness) AddInstance(ei Engine) error {\n\tif h.isStarted() {\n\t\treturn errors.New(\"can't add instance to already-started harness\")\n\t}\n\n\th.Lock()\n\tdefer h.Unlock()\n\tif indexSetter, ok := ei.(interface{ setIndex(uint32) }); ok {\n\t\tindexSetter.setIndex(uint32(len(h.instances)))\n\t}\n\n\th.instances = append(h.instances, ei)\n\treturn nil\n}\n\n// OnDrpcFailure registers callbacks to be invoked on dRPC call failure.\nfunc (h *EngineHarness) OnDrpcFailure(fns ...func(ctx context.Context, err error)) {\n\th.Lock()\n\tdefer h.Unlock()\n\n\th.onDrpcFailure = append(h.onDrpcFailure, fns...)\n}\n\n// CallDrpc calls the supplied dRPC method on a managed I/O Engine instance.\nfunc (h *EngineHarness) CallDrpc(ctx context.Context, method drpc.Method, body proto.Message) (resp *drpc.Response, err error) {\n\tdefer func() {\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t\t// If the context was canceled, don't trigger callbacks.\n\t\tif errors.Cause(err) == context.Canceled {\n\t\t\treturn\n\t\t}\n\t\t// Don't trigger callbacks for these errors which can happen when\n\t\t// things are still starting up.\n\t\tif err == FaultHarnessNotStarted || err == errEngineNotReady {\n\t\t\treturn\n\t\t}\n\n\t\th.log.Debugf(\"invoking dRPC failure handlers for %s\", err)\n\t\th.RLock()\n\t\tdefer h.RUnlock()\n\t\tfor _, fn := range h.onDrpcFailure {\n\t\t\tfn(ctx, err)\n\t\t}\n\t}()\n\n\tif !h.isStarted() {\n\t\treturn nil, FaultHarnessNotStarted\n\t}\n\n\t// Iterate through the managed instances, looking for\n\t// the first one that is available to service the request.\n\t// If the request fails, that error will be returned.\n\tfor _, i := range h.Instances() {\n\t\tresp, err = i.CallDrpc(ctx, method, body)\n\n\t\tswitch errors.Cause(err) {\n\t\tcase errEngineNotReady, errDRPCNotReady, FaultDataPlaneNotStarted:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\ntype dbLeader interface {\n\tIsLeader() bool\n\tShutdownRaft() error\n\tResignLeadership(error) error\n}\n\n// Start starts harness by setting up and starting dRPC before initiating\n// configured instances' processing loops.\n//\n// Run until harness is shutdown.\nfunc (h *EngineHarness) Start(ctx context.Context, db dbLeader, cfg *config.Server) error {\n\tif h.isStarted() {\n\t\treturn errors.New(\"can't start: harness already started\")\n\t}\n\n\tif cfg == nil {\n\t\treturn errors.New(\"nil cfg supplied to Start()\")\n\t}\n\n\t// Now we want to block any RPCs that might try to mess with storage\n\t// (format, firmware update, etc) before attempting to start I/O Engines\n\t// which are using the storage.\n\th.started.SetTrue()\n\tdefer h.started.SetFalse()\n\n\tfor _, ei := range h.Instances() {\n\t\tei.Run(ctx, cfg.RecreateSuperblocks)\n\t}\n\n\th.OnDrpcFailure(func(_ context.Context, errIn error) {\n\t\tif !db.IsLeader() {\n\t\t\treturn\n\t\t}\n\n\t\tswitch errors.Cause(errIn) {\n\t\tcase errDRPCNotReady, FaultDataPlaneNotStarted:\n\t\t\tbreak\n\t\tdefault:\n\t\t\t// Don't shutdown on other failures which are\n\t\t\t// not related to dRPC communications.\n\t\t\treturn\n\t\t}\n\n\t\t// If we cannot service a dRPC request on this node,\n\t\t// we should resign as leader in order to force a new\n\t\t// leader election.\n\t\tif err := db.ResignLeadership(errIn); err != nil {\n\t\t\th.log.Errorf(\"failed to resign leadership after dRPC failure: %s\", err)\n\t\t}\n\t})\n\n\t<-ctx.Done()\n\th.log.Debug(\"shutting down harness\")\n\n\treturn ctx.Err()\n}\n\n// readyRanks returns rank assignment of configured harness instances that are\n// in a ready state. Rank assignments can be nil.\nfunc (h *EngineHarness) readyRanks() []ranklist.Rank {\n\th.RLock()\n\tdefer h.RUnlock()\n\n\tranks := make([]ranklist.Rank, 0)\n\tfor idx, ei := range h.instances {\n\t\tif ei.IsReady() {\n\t\t\trank, err := ei.GetRank()\n\t\t\tif err != nil {\n\t\t\t\th.log.Errorf(\"instance %d: no rank (%s)\", idx, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tranks = append(ranks, rank)\n\t\t}\n\t}\n\n\treturn ranks\n}\n"
    },
    {
      "path": "src/control/server/harness_test.go",
      "content": "//\n// (C) Copyright 2019-2023 Intel Corporation.\n//\n// SPDX-License-Identifier: BSD-2-Clause-Patent\n//\n\npackage server\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/daos-stack/daos/src/control/common/test\"\n\t. \"github.com/daos-stack/daos/src/control/common/test\"\n\t\"github.com/daos-stack/daos/src/control/drpc\"\n\t\"github.com/daos-stack/daos/src/control/lib/atm\"\n\t\"github.com/daos-stack/daos/src/control/lib/control\"\n\t\"github.com/daos-stack/daos/src/control/lib/ranklist\"\n\t\"github.com/daos-stack/daos/src/control/logging\"\n\tsysprov \"github.com/daos-stack/daos/src/control/provider/system\"\n\t\"github.com/daos-stack/daos/src/control/security\"\n\t\"github.com/daos-stack/daos/src/control/server/config\"\n\t\"github.com/daos-stack/daos/src/control/server/engine\"\n\t\"github.com/daos-stack/daos/src/control/server/storage\"\n\t\"github.com/daos-stack/daos/src/control/server/storage/bdev\"\n\t\"github.com/daos-stack/daos/src/control/server/storage/scm\"\n\t\"github.com/daos-stack/daos/src/control/system\"\n\t\"github.com/daos-stack/daos/src/control/system/raft\"\n)\n\nconst (\n\ttestShortTimeout   = 50 * time.Millisecond\n\ttestLongTimeout    = 1 * time.Minute\n\tdelayedFailTimeout = 20 * testShortTimeout\n\tmaxEngines         = 2\n)\n\nfunc TestServer_Harness_Start(t *testing.T) {\n\tfor name, tc := range map[string]struct {\n\t\ttrc              *engine.TestRunnerConfig\n\t\tisAP             bool                     // is first instance an AP/MS replica/bootstrap\n\t\trankInSuperblock bool                     // rank already set in superblock when starting\n\t\tinstanceUuids    map[int]string           // UUIDs for each instance.Index()\n\t\tdontNotifyReady  bool                     // skip sending notify ready on dRPC channel\n\t\twaitTimeout      time.Duration            // time after which test context is cancelled\n\t\texpStartErr      error                    // error from harness.Start()\n\t\texpStartCount    uint32                   // number of instance.runner.Start() calls\n\t\texpDrpcCalls     map[uint32][]drpc.Method // method ids called for each instance.Index()\n\t\texpGrpcCalls     map[uint32][]string      // string repr of call for each instance.Index()\n\t\texpRanks         map[uint32]ranklist.Rank // ranks to have been set during Start()\n\t\texpMembers       system.Members           // members to have been registered during Start()\n\t\texpIoErrs        map[uint32]error         // errors expected from instances\n\t}{\n\t\t\"normal startup/shutdown\": {\n\t\t\ttrc: &engine.TestRunnerConfig{\n\t\t\t\tRunnerExitInfoCb: func(ctx context.Context) *engine.RunnerExitInfo {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcase <-time.After(testLongTimeout):\n\t\t\t\t\t}\n\t\t\t\t\treturn &engine.RunnerExitInfo{\n\t\t\t\t\t\tError: errors.New(\"ending\"),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tinstanceUuids: map[int]string{\n\t\t\t\t0: MockUUID(0),\n\t\t\t\t1: MockUUID(1),\n\t\t\t},\n\t\t\texpStartCount: maxEngines,\n\t\t\texpDrpcCalls: map[uint32][]drpc.Method{\n\t\t\t\t0: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t\t1: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpGrpcCalls: map[uint32][]string{\n\t\t\t\t0: {fmt.Sprintf(\"Join %d\", ranklist.NilRank)},\n\t\t\t\t1: {fmt.Sprintf(\"Join %d\", ranklist.NilRank)},\n\t\t\t},\n\t\t\texpRanks: map[uint32]ranklist.Rank{\n\t\t\t\t0: ranklist.Rank(0),\n\t\t\t\t1: ranklist.Rank(1),\n\t\t\t},\n\t\t},\n\t\t\"startup/shutdown with preset ranks\": {\n\t\t\ttrc: &engine.TestRunnerConfig{\n\t\t\t\tRunnerExitInfoCb: func(ctx context.Context) *engine.RunnerExitInfo {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcase <-time.After(testLongTimeout):\n\t\t\t\t\t}\n\t\t\t\t\treturn &engine.RunnerExitInfo{\n\t\t\t\t\t\tError: errors.New(\"ending\"),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\trankInSuperblock: true,\n\t\t\texpStartCount:    maxEngines,\n\t\t\texpDrpcCalls: map[uint32][]drpc.Method{\n\t\t\t\t0: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t\t1: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpGrpcCalls: map[uint32][]string{\n\t\t\t\t0: {\"Join 1\"}, // rank == instance.Index() + 1\n\t\t\t\t1: {\"Join 2\"},\n\t\t\t},\n\t\t\texpRanks: map[uint32]ranklist.Rank{\n\t\t\t\t0: ranklist.Rank(1),\n\t\t\t\t1: ranklist.Rank(2),\n\t\t\t},\n\t\t},\n\t\t\"fails to start\": {\n\t\t\ttrc:           &engine.TestRunnerConfig{StartErr: errors.New(\"no\")},\n\t\t\twaitTimeout:   10 * testShortTimeout,\n\t\t\texpStartErr:   context.DeadlineExceeded,\n\t\t\texpStartCount: 2, // both start but don't proceed so context times out\n\t\t},\n\t\t\"delayed failure occurs before notify ready\": {\n\t\t\tdontNotifyReady: true,\n\t\t\twaitTimeout:     30 * testShortTimeout,\n\t\t\texpStartErr:     context.DeadlineExceeded,\n\t\t\ttrc: &engine.TestRunnerConfig{\n\t\t\t\tRunnerExitInfoCb: func(ctx context.Context) *engine.RunnerExitInfo {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcase <-time.After(delayedFailTimeout):\n\t\t\t\t\t}\n\t\t\t\t\treturn &engine.RunnerExitInfo{\n\t\t\t\t\t\tError: errors.New(\"oops\"),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\texpStartCount: maxEngines,\n\t\t\texpRanks: map[uint32]ranklist.Rank{\n\t\t\t\t0: ranklist.NilRank,\n\t\t\t\t1: ranklist.NilRank,\n\t\t\t},\n\t\t\texpIoErrs: map[uint32]error{\n\t\t\t\t0: errors.New(\"oops\"),\n\t\t\t\t1: errors.New(\"oops\"),\n\t\t\t},\n\t\t},\n\t\t\"delayed failure occurs after ready\": {\n\t\t\twaitTimeout: 100 * testShortTimeout,\n\t\t\texpStartErr: context.DeadlineExceeded,\n\t\t\ttrc: &engine.TestRunnerConfig{\n\t\t\t\tRunnerExitInfoCb: func(ctx context.Context) *engine.RunnerExitInfo {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcase <-time.After(delayedFailTimeout):\n\t\t\t\t\t}\n\t\t\t\t\treturn &engine.RunnerExitInfo{\n\t\t\t\t\t\tError: errors.New(\"oops\"),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tinstanceUuids: map[int]string{\n\t\t\t\t0: MockUUID(0),\n\t\t\t\t1: MockUUID(1),\n\t\t\t},\n\t\t\texpStartCount: maxEngines,\n\t\t\texpDrpcCalls: map[uint32][]drpc.Method{\n\t\t\t\t0: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t\t1: {\n\t\t\t\t\tdrpc.MethodSetRank,\n\t\t\t\t\tdrpc.MethodSetUp,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpGrpcCalls: map[uint32][]string{\n\t\t\t\t0: {fmt.Sprintf(\"Join %d\", ranklist.NilRank)},\n\t\t\t\t1: {fmt.Sprintf(\"Join %d\", ranklist.NilRank)},\n\t\t\t},\n\t\t\texpRanks: map[uint32]ranklist.Rank{\n\t\t\t\t0: ranklist.Rank(0),\n\t\t\t\t1: ranklist.Rank(1),\n\t\t\t},\n\t\t\texpIoErrs: map[uint32]error{\n\t\t\t\t0: errors.New(\"oops\"),\n\t\t\t\t1: errors.New(\"oops\"),\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tlog, buf := logging.NewTestLogger(t.Name())\n\t\t\tdefer ShowBufferOnFailure(t, buf)\n\n\t\t\ttestDir, cleanup := CreateTestDir(t)\n\t\t\tdefer cleanup()\n\n\t\t\tengineCfgs := make([]*engine.Config, maxEngines)\n\t\t\tfor i := 0; i < maxEngines; i++ {\n\t\t\t\tengineCfgs[i] = engine.MockConfig().\n\t\t\t\t\tWithStorage(\n\t\t\t\t\t\tstorage.NewTierConfig().\n\t\t\t\t\t\t\tWithStorageClass(\"ram\").\n\t\t\t\t\t\t\tWithScmRamdiskSize(1).\n\t\t\t\t\t\t\tWithScmMountPoint(filepath.Join(testDir, strconv.Itoa(i))),\n\t\t\t\t\t)\n\t\t\t}\n\t\t\tconfig := config.DefaultServer().\n\t\t\t\tWithEngines(engineCfgs...).\n\t\t\t\tWithSocketDir(testDir).\n\t\t\t\tWithTransportConfig(&security.TransportConfig{AllowInsecure: true})\n\n\t\t\tjoinMu := sync.Mutex{}\n\t\t\tjoinRequests := make(map[uint32][]string)\n\t\t\tvar instanceStarts uint32\n\t\t\tharness := NewEngineHarness(log)\n\t\t\tfor i, engineCfg := range config.Engines {\n\t\t\t\tif err := os.MkdirAll(engineCfg.Storage.Tiers[0].Scm.MountPoint, 0777); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif tc.trc == nil {\n\t\t\t\t\ttc.trc = &engine.TestRunnerConfig{}\n\t\t\t\t}\n\t\t\t\tif tc.trc.StartCb == nil {\n\t\t\t\t\ttc.trc.StartCb = func() {\n\t\t\t\t\t\t_ = atomic.AddUint32(&instanceStarts, 1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trunner := engine.NewTestRunner(tc.trc, engineCfg)\n\n\t\t\t\tmsc := &sysprov.MockSysConfig{IsMountedBool: true}\n\t\t\t\tsysp := sysprov.NewMockSysProvider(log, msc)\n\t\t\t\tprovider := storage.MockProvider(\n\t\t\t\t\tlog, 0, &engineCfg.Storage,\n\t\t\t\t\tsysp,\n\t\t\t\t\tscm.NewMockProvider(log, nil, msc),\n\t\t\t\t\tbdev.NewMockProvider(log, &bdev.MockBackendConfig{}),\n\t\t\t\t\tnil,\n\t\t\t\t)\n\n\t\t\t\tidx := uint32(i)\n\t\t\t\tjoinFn := func(_ context.Context, req *control.SystemJoinReq) (*control.SystemJoinResp, error) {\n\t\t\t\t\t// appease the race detector\n\t\t\t\t\tjoinMu.Lock()\n\t\t\t\t\tdefer joinMu.Unlock()\n\t\t\t\t\tjoinRequests[idx] = []string{fmt.Sprintf(\"Join %d\", req.Rank)}\n\t\t\t\t\treturn &control.SystemJoinResp{\n\t\t\t\t\t\tRank: ranklist.Rank(idx),\n\t\t\t\t\t}, nil\n\t\t\t\t}\n\n\t\t\t\tei := NewEngineInstance(log, provider, joinFn, runner)\n\t\t\t\tvar isAP bool\n\t\t\t\tif tc.isAP && i == 0 { // first instance will be AP & bootstrap MS\n\t\t\t\t\tisAP = true\n\t\t\t\t}\n\t\t\t\tvar uuid string\n\t\t\t\tif UUID, exists := tc.instanceUuids[i]; exists {\n\t\t\t\t\tuuid = UUID\n\t\t\t\t}\n\t\t\t\tvar rank *ranklist.Rank\n\t\t\t\tvar isValid bool\n\t\t\t\tif tc.rankInSuperblock {\n\t\t\t\t\trank = ranklist.NewRankPtr(uint32(i + 1))\n\t\t\t\t\tisValid = true\n\t\t\t\t} else if isAP { // bootstrap will assume rank 0\n\t\t\t\t\trank = new(ranklist.Rank)\n\t\t\t\t}\n\t\t\t\tei.setSuperblock(&Superblock{\n\t\t\t\t\tUUID: uuid, Rank: rank, ValidRank: isValid,\n\t\t\t\t})\n\n\t\t\t\tif err := harness.AddInstance(ei); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinstances := harness.Instances()\n\n\t\t\t// set mock dRPC client to record call details\n\t\t\tfor _, e := range instances {\n\t\t\t\tei := e.(*EngineInstance)\n\t\t\t\tei.setDrpcClient(newMockDrpcClient(&mockDrpcClientConfig{\n\t\t\t\t\tSendMsgResponse: &drpc.Response{},\n\t\t\t\t}))\n\t\t\t}\n\n\t\t\tctx, cancel := context.WithCancel(test.Context(t))\n\t\t\tif tc.waitTimeout != 0 {\n\t\t\t\tctx, cancel = context.WithTimeout(ctx, tc.waitTimeout)\n\t\t\t}\n\t\t\tdefer cancel()\n\n\t\t\t// start harness async and signal completion\n\t\t\tvar gotErr error\n\t\t\tsysdb := raft.MockDatabase(t, log)\n\t\t\tmembership := system.MockMembership(t, log, sysdb, mockTCPResolver)\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func(ctxIn context.Context) {\n\t\t\t\tgotErr = harness.Start(ctxIn, sysdb, config)\n\t\t\t\tclose(done)\n\t\t\t}(ctx)\n\n\t\t\twaitDrpcReady := make(chan struct{})\n\t\t\tt.Log(\"waiting for dRPC to be ready\")\n\t\t\tgo func(ctxIn context.Context) {\n\t\t\t\tfor {\n\t\t\t\t\tready := true\n\t\t\t\t\tfor _, ei := range instances {\n\t\t\t\t\t\tif ei.(*EngineInstance).waitDrpc.IsFalse() {\n\t\t\t\t\t\t\tready = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ready {\n\t\t\t\t\t\tclose(waitDrpcReady)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-time.After(testShortTimeout):\n\t\t\t\t\tcase <-ctxIn.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(ctx)\n\n\t\t\tselect {\n\t\t\tcase <-waitDrpcReady:\n\t\t\t\tt.Log(\"dRPC is ready\")\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif tc.expStartErr != nil {\n\t\t\t\t\t<-done\n\t\t\t\t\tCmpErr(t, tc.expStartErr, gotErr)\n\t\t\t\t\tif atomic.LoadUint32(&instanceStarts) != tc.expStartCount {\n\t\t\t\t\t\tt.Fatalf(\"expected %d starts, got %d\",\n\t\t\t\t\t\t\ttc.expStartCount, instanceStarts)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// deadline exceeded as expected but desired state not reached\n\t\t\t\tt.Fatalf(\"instances did not get to waiting for dRPC state: %s\", ctx.Err())\n\t\t\t}\n\t\t\tt.Log(\"instances ready and waiting for dRPC ready notification\")\n\n\t\t\t// simulate receiving notify ready whilst instances\n\t\t\t// running in harness (unless dontNotifyReady flag is set)\n\t\t\tfor _, ei := range instances {\n\t\t\t\tif tc.dontNotifyReady {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treq := getTestNotifyReadyReq(t, \"/tmp/instance_test.sock\", 0)\n\t\t\t\tgo func(ctxIn context.Context, i *EngineInstance) {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase i.drpcReady <- req:\n\t\t\t\t\tcase <-ctxIn.Done():\n\t\t\t\t\t}\n\t\t\t\t}(ctx, ei.(*EngineInstance))\n\t\t\t\tt.Logf(\"sent drpc ready to instance %d\", ei.Index())\n\t\t\t}\n\n\t\t\twaitReady := make(chan struct{})\n\t\t\tt.Log(\"waitng for ready\")\n\t\t\tgo func(ctxIn context.Context) {\n\t\t\t\tfor {\n\t\t\t\t\tif len(harness.readyRanks()) == len(instances) {\n\t\t\t\t\t\tclose(waitReady)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-time.After(testShortTimeout):\n\t\t\t\t\tcase <-ctxIn.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(ctx)\n\n\t\t\tselect {\n\t\t\tcase <-waitReady:\n\t\t\t\tt.Log(\"instances setup and ready\")\n\t\t\tcase <-ctx.Done():\n\t\t\t\tt.Logf(\"instances did not get to ready state (%s)\", ctx.Err())\n\t\t\t}\n\n\t\t\tif atomic.LoadUint32(&instanceStarts) != tc.expStartCount {\n\t\t\t\tt.Fatalf(\"expected %d starts, got %d\", tc.expStartCount, instanceStarts)\n\t\t\t}\n\n\t\t\tif tc.waitTimeout == 0 { // if custom timeout, don't cancel\n\t\t\t\tcancel() // all ranks have been started, run finished\n\t\t\t}\n\t\t\t<-done\n\t\t\tif gotErr != context.Canceled || tc.expStartErr != nil {\n\t\t\t\tCmpErr(t, tc.expStartErr, gotErr)\n\t\t\t\tif tc.expStartErr != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjoinMu.Lock()\n\t\t\tdefer joinMu.Unlock()\n\t\t\t// verify expected RPCs were made, ranks allocated and\n\t\t\t// members added to membership\n\t\t\tfor _, e := range instances {\n\t\t\t\tei := e.(*EngineInstance)\n\t\t\t\tdc, err := ei.getDrpcClient()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tgotDrpcCalls := dc.(*mockDrpcClient).CalledMethods()\n\t\t\t\tAssertEqual(t, tc.expDrpcCalls[ei.Index()], gotDrpcCalls,\n\t\t\t\t\tfmt.Sprintf(\"%s: unexpected dRPCs for instance %d\", name, ei.Index()))\n\n\t\t\t\tif diff := cmp.Diff(tc.expGrpcCalls[ei.Index()], joinRequests[ei.Index()]); diff != \"\" {\n\t\t\t\t\tt.Fatalf(\"unexpected gRPCs for instance %d (-want, +got):\\n%s\\n\",\n\t\t\t\t\t\tei.Index(), diff)\n\t\t\t\t}\n\t\t\t\trank, _ := ei.GetRank()\n\t\t\t\tif diff := cmp.Diff(tc.expRanks[ei.Index()], rank); diff != \"\" {\n\t\t\t\t\tt.Fatalf(\"unexpected rank for instance %d (-want, +got):\\n%s\\n\",\n\t\t\t\t\t\tei.Index(), diff)\n\t\t\t\t}\n\t\t\t\tCmpErr(t, tc.expIoErrs[ei.Index()], ei._lastErr)\n\t\t\t}\n\t\t\tmembers, err := membership.Members(nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tAssertEqual(t, len(tc.expMembers), len(members), \"unexpected number in membership\")\n\t\t\tfor i, member := range members {\n\t\t\t\tif diff := cmp.Diff(fmt.Sprintf(\"%v\", member),\n\t\t\t\t\tfmt.Sprintf(\"%v\", tc.expMembers[i])); diff != \"\" {\n\n\t\t\t\t\tt.Fatalf(\"unexpected system membership (-want, +got):\\n%s\\n\", diff)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestServer_Harness_WithFaultDomain(t *testing.T) {\n\tharness := &EngineHarness{}\n\tfd, err := system.NewFaultDomainFromString(\"/one/two\")\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't create fault domain: %s\", err)\n\t}\n\n\tupdatedHarness := harness.WithFaultDomain(fd)\n\n\t// Updated to include the fault domain\n\tif diff := cmp.Diff(harness.faultDomain, fd); diff != \"\" {\n\t\tt.Fatalf(\"unexpected results (-want, +got):\\n%s\\n\", diff)\n\t}\n\t// updatedHarness is the same as harness\n\tAssertEqual(t, updatedHarness, harness, \"not the same structure\")\n}\n\ntype mockdb struct {\n\tisLeader    bool\n\tshutdown    bool\n\tshutdownErr error\n}\n\nfunc (db *mockdb) IsLeader() bool {\n\treturn db.isLeader\n}\n\nfunc (db *mockdb) ShutdownRaft() error {\n\tdb.shutdown = true\n\treturn db.shutdownErr\n}\n\nfunc (db *mockdb) ResignLeadership(error) error {\n\tdb.isLeader = false\n\treturn nil\n}\n\nfunc TestServer_Harness_CallDrpc(t *testing.T) {\n\tfor name, tc := range map[string]struct {\n\t\tmics           []*MockInstanceConfig\n\t\tmethod         drpc.Method\n\t\tbody           proto.Message\n\t\tnotStarted     bool\n\t\tnotLeader      bool\n\t\tresignCause    error\n\t\texpShutdown    bool\n\t\texpNotLeader   bool\n\t\texpFailHandler bool\n\t\texpErr         error\n\t}{\n\t\t\"success\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady: atm.NewBool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"one not ready, one ready\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errDRPCNotReady,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tReady: atm.NewBool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"one not ready, one fails\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errDRPCNotReady,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errors.New(\"whoops\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr:         errors.New(\"whoops\"),\n\t\t\texpFailHandler: true,\n\t\t},\n\t\t\"instance not ready\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tStarted:     atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errEngineNotReady,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: errEngineNotReady,\n\t\t},\n\t\t\"harness not started\": {\n\t\t\tmics:       []*MockInstanceConfig{},\n\t\t\tnotStarted: true,\n\t\t\texpErr:     FaultHarnessNotStarted,\n\t\t},\n\t\t\"first fails (other)\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errors.New(\"whoops\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tReady: atm.NewBool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr:         errors.New(\"whoops\"),\n\t\t\texpFailHandler: true,\n\t\t},\n\t\t\"none available\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: errDRPCNotReady,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: FaultDataPlaneNotStarted,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpNotLeader:   true,\n\t\t\texpErr:         FaultDataPlaneNotStarted,\n\t\t\texpFailHandler: true,\n\t\t},\n\t\t\"context canceled\": {\n\t\t\tmics: []*MockInstanceConfig{\n\t\t\t\t{\n\t\t\t\t\tReady:       atm.NewBool(true),\n\t\t\t\t\tCallDrpcErr: context.Canceled,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: context.Canceled,\n\t\t},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tlog, buf := logging.NewTestLogger(name)\n\t\t\tdefer test.ShowBufferOnFailure(t, buf)\n\n\t\t\th := NewEngineHarness(log)\n\t\t\tfor _, mic := range tc.mics {\n\t\t\t\tif err := h.AddInstance(NewMockInstance(mic)); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar drpcFailureInvoked atm.Bool\n\t\t\th.OnDrpcFailure(func(_ context.Context, err error) {\n\t\t\t\tdrpcFailureInvoked.SetTrue()\n\t\t\t})\n\n\t\t\tctx, cancel := context.WithCancel(test.Context(t))\n\t\t\tdb := &mockdb{\n\t\t\t\tisLeader: !tc.notLeader,\n\t\t\t}\n\n\t\t\tstartErr := make(chan error)\n\t\t\tgo func() {\n\t\t\t\tif err := h.Start(ctx, db, config.DefaultServer()); err != nil {\n\t\t\t\t\tstartErr <- err\n\t\t\t\t}\n\t\t\t\tclose(startErr)\n\t\t\t}()\n\t\t\tfor {\n\t\t\t\tif h.isStarted() {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := <-startErr; err != nil {\n\t\t\t\t\tif err != context.Canceled {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdefer cancel()\n\n\t\t\tif tc.notStarted {\n\t\t\t\th.started.SetFalse()\n\t\t\t}\n\n\t\t\t_, gotErr := h.CallDrpc(ctx, tc.method, tc.body)\n\t\t\ttest.CmpErr(t, tc.expErr, gotErr)\n\t\t\ttest.AssertEqual(t, db.shutdown, tc.expShutdown, \"unexpected shutdown state\")\n\t\t\ttest.AssertEqual(t, db.isLeader, !tc.expNotLeader, \"unexpected leader state\")\n\t\t\ttest.AssertEqual(t, drpcFailureInvoked.Load(), tc.expFailHandler, \"unexpected fail handler invocation\")\n\t\t})\n\t}\n}\n"
    },
    {
      "path": "src/mgmt/smd.pb-c.c",
      "content": "/* Generated by the protocol buffer compiler.  DO NOT EDIT! */\n/* Generated from: smd.proto */\n\n/* Do not generate deprecated warnings for self */\n#ifndef PROTOBUF_C__NO_DEPRECATED\n#define PROTOBUF_C__NO_DEPRECATED\n#endif\n\n#include \"smd.pb-c.h\"\nvoid   ctl__bio_health_req__init\n                     (Ctl__BioHealthReq         *message)\n{\n  static const Ctl__BioHealthReq init_value = CTL__BIO_HEALTH_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__bio_health_req__get_packed_size\n                     (const Ctl__BioHealthReq *message)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__bio_health_req__pack\n                     (const Ctl__BioHealthReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__bio_health_req__pack_to_buffer\n                     (const Ctl__BioHealthReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__BioHealthReq *\n       ctl__bio_health_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__BioHealthReq *)\n     protobuf_c_message_unpack (&ctl__bio_health_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__bio_health_req__free_unpacked\n                     (Ctl__BioHealthReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__bio_health_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__bio_health_resp__init\n                     (Ctl__BioHealthResp         *message)\n{\n  static const Ctl__BioHealthResp init_value = CTL__BIO_HEALTH_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__bio_health_resp__get_packed_size\n                     (const Ctl__BioHealthResp *message)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__bio_health_resp__pack\n                     (const Ctl__BioHealthResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__bio_health_resp__pack_to_buffer\n                     (const Ctl__BioHealthResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__BioHealthResp *\n       ctl__bio_health_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__BioHealthResp *)\n     protobuf_c_message_unpack (&ctl__bio_health_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__bio_health_resp__free_unpacked\n                     (Ctl__BioHealthResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__bio_health_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_device__init\n                     (Ctl__SmdDevice         *message)\n{\n  static const Ctl__SmdDevice init_value = CTL__SMD_DEVICE__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_device__get_packed_size\n                     (const Ctl__SmdDevice *message)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_device__pack\n                     (const Ctl__SmdDevice *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_device__pack_to_buffer\n                     (const Ctl__SmdDevice *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevice *\n       ctl__smd_device__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevice *)\n     protobuf_c_message_unpack (&ctl__smd_device__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_device__free_unpacked\n                     (Ctl__SmdDevice *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_device__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_dev_req__init\n                     (Ctl__SmdDevReq         *message)\n{\n  static const Ctl__SmdDevReq init_value = CTL__SMD_DEV_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_dev_req__get_packed_size\n                     (const Ctl__SmdDevReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_dev_req__pack\n                     (const Ctl__SmdDevReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_dev_req__pack_to_buffer\n                     (const Ctl__SmdDevReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevReq *\n       ctl__smd_dev_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevReq *)\n     protobuf_c_message_unpack (&ctl__smd_dev_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_dev_req__free_unpacked\n                     (Ctl__SmdDevReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_dev_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_dev_resp__init\n                     (Ctl__SmdDevResp         *message)\n{\n  static const Ctl__SmdDevResp init_value = CTL__SMD_DEV_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_dev_resp__get_packed_size\n                     (const Ctl__SmdDevResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_dev_resp__pack\n                     (const Ctl__SmdDevResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_dev_resp__pack_to_buffer\n                     (const Ctl__SmdDevResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdDevResp *\n       ctl__smd_dev_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdDevResp *)\n     protobuf_c_message_unpack (&ctl__smd_dev_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_dev_resp__free_unpacked\n                     (Ctl__SmdDevResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_dev_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_pool_req__init\n                     (Ctl__SmdPoolReq         *message)\n{\n  static const Ctl__SmdPoolReq init_value = CTL__SMD_POOL_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_pool_req__get_packed_size\n                     (const Ctl__SmdPoolReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_pool_req__pack\n                     (const Ctl__SmdPoolReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_pool_req__pack_to_buffer\n                     (const Ctl__SmdPoolReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdPoolReq *\n       ctl__smd_pool_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdPoolReq *)\n     protobuf_c_message_unpack (&ctl__smd_pool_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_pool_req__free_unpacked\n                     (Ctl__SmdPoolReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_pool_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_pool_resp__pool__init\n                     (Ctl__SmdPoolResp__Pool         *message)\n{\n  static const Ctl__SmdPoolResp__Pool init_value = CTL__SMD_POOL_RESP__POOL__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_pool_resp__init\n                     (Ctl__SmdPoolResp         *message)\n{\n  static const Ctl__SmdPoolResp init_value = CTL__SMD_POOL_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_pool_resp__get_packed_size\n                     (const Ctl__SmdPoolResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_pool_resp__pack\n                     (const Ctl__SmdPoolResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_pool_resp__pack_to_buffer\n                     (const Ctl__SmdPoolResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdPoolResp *\n       ctl__smd_pool_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdPoolResp *)\n     protobuf_c_message_unpack (&ctl__smd_pool_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_pool_resp__free_unpacked\n                     (Ctl__SmdPoolResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_pool_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_query_req__init\n                     (Ctl__SmdQueryReq         *message)\n{\n  static const Ctl__SmdQueryReq init_value = CTL__SMD_QUERY_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_query_req__get_packed_size\n                     (const Ctl__SmdQueryReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_query_req__pack\n                     (const Ctl__SmdQueryReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_query_req__pack_to_buffer\n                     (const Ctl__SmdQueryReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdQueryReq *\n       ctl__smd_query_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdQueryReq *)\n     protobuf_c_message_unpack (&ctl__smd_query_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_query_req__free_unpacked\n                     (Ctl__SmdQueryReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_query_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_query_resp__smd_device_with_health__init\n                     (Ctl__SmdQueryResp__SmdDeviceWithHealth         *message)\n{\n  static const Ctl__SmdQueryResp__SmdDeviceWithHealth init_value = CTL__SMD_QUERY_RESP__SMD_DEVICE_WITH_HEALTH__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__pool__init\n                     (Ctl__SmdQueryResp__Pool         *message)\n{\n  static const Ctl__SmdQueryResp__Pool init_value = CTL__SMD_QUERY_RESP__POOL__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__rank_resp__init\n                     (Ctl__SmdQueryResp__RankResp         *message)\n{\n  static const Ctl__SmdQueryResp__RankResp init_value = CTL__SMD_QUERY_RESP__RANK_RESP__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_query_resp__init\n                     (Ctl__SmdQueryResp         *message)\n{\n  static const Ctl__SmdQueryResp init_value = CTL__SMD_QUERY_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_query_resp__get_packed_size\n                     (const Ctl__SmdQueryResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_query_resp__pack\n                     (const Ctl__SmdQueryResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_query_resp__pack_to_buffer\n                     (const Ctl__SmdQueryResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdQueryResp *\n       ctl__smd_query_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdQueryResp *)\n     protobuf_c_message_unpack (&ctl__smd_query_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_query_resp__free_unpacked\n                     (Ctl__SmdQueryResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_query_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__led_manage_req__init\n                     (Ctl__LedManageReq         *message)\n{\n  static const Ctl__LedManageReq init_value = CTL__LED_MANAGE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__led_manage_req__get_packed_size\n                     (const Ctl__LedManageReq *message)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__led_manage_req__pack\n                     (const Ctl__LedManageReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__led_manage_req__pack_to_buffer\n                     (const Ctl__LedManageReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__LedManageReq *\n       ctl__led_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__LedManageReq *)\n     protobuf_c_message_unpack (&ctl__led_manage_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__led_manage_req__free_unpacked\n                     (Ctl__LedManageReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__led_manage_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__dev_replace_req__init\n                     (Ctl__DevReplaceReq         *message)\n{\n  static const Ctl__DevReplaceReq init_value = CTL__DEV_REPLACE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__dev_replace_req__get_packed_size\n                     (const Ctl__DevReplaceReq *message)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__dev_replace_req__pack\n                     (const Ctl__DevReplaceReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__dev_replace_req__pack_to_buffer\n                     (const Ctl__DevReplaceReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__DevReplaceReq *\n       ctl__dev_replace_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__DevReplaceReq *)\n     protobuf_c_message_unpack (&ctl__dev_replace_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__dev_replace_req__free_unpacked\n                     (Ctl__DevReplaceReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__dev_replace_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__set_faulty_req__init\n                     (Ctl__SetFaultyReq         *message)\n{\n  static const Ctl__SetFaultyReq init_value = CTL__SET_FAULTY_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__set_faulty_req__get_packed_size\n                     (const Ctl__SetFaultyReq *message)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__set_faulty_req__pack\n                     (const Ctl__SetFaultyReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__set_faulty_req__pack_to_buffer\n                     (const Ctl__SetFaultyReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SetFaultyReq *\n       ctl__set_faulty_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SetFaultyReq *)\n     protobuf_c_message_unpack (&ctl__set_faulty_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__set_faulty_req__free_unpacked\n                     (Ctl__SetFaultyReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__set_faulty_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__dev_manage_resp__init\n                     (Ctl__DevManageResp         *message)\n{\n  static const Ctl__DevManageResp init_value = CTL__DEV_MANAGE_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__dev_manage_resp__get_packed_size\n                     (const Ctl__DevManageResp *message)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__dev_manage_resp__pack\n                     (const Ctl__DevManageResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__dev_manage_resp__pack_to_buffer\n                     (const Ctl__DevManageResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__DevManageResp *\n       ctl__dev_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__DevManageResp *)\n     protobuf_c_message_unpack (&ctl__dev_manage_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__dev_manage_resp__free_unpacked\n                     (Ctl__DevManageResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__dev_manage_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_manage_req__init\n                     (Ctl__SmdManageReq         *message)\n{\n  static const Ctl__SmdManageReq init_value = CTL__SMD_MANAGE_REQ__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_manage_req__get_packed_size\n                     (const Ctl__SmdManageReq *message)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_manage_req__pack\n                     (const Ctl__SmdManageReq *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_manage_req__pack_to_buffer\n                     (const Ctl__SmdManageReq *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdManageReq *\n       ctl__smd_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdManageReq *)\n     protobuf_c_message_unpack (&ctl__smd_manage_req__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_manage_req__free_unpacked\n                     (Ctl__SmdManageReq *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_manage_req__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nvoid   ctl__smd_manage_resp__result__init\n                     (Ctl__SmdManageResp__Result         *message)\n{\n  static const Ctl__SmdManageResp__Result init_value = CTL__SMD_MANAGE_RESP__RESULT__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_manage_resp__rank_resp__init\n                     (Ctl__SmdManageResp__RankResp         *message)\n{\n  static const Ctl__SmdManageResp__RankResp init_value = CTL__SMD_MANAGE_RESP__RANK_RESP__INIT;\n  *message = init_value;\n}\nvoid   ctl__smd_manage_resp__init\n                     (Ctl__SmdManageResp         *message)\n{\n  static const Ctl__SmdManageResp init_value = CTL__SMD_MANAGE_RESP__INIT;\n  *message = init_value;\n}\nsize_t ctl__smd_manage_resp__get_packed_size\n                     (const Ctl__SmdManageResp *message)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n}\nsize_t ctl__smd_manage_resp__pack\n                     (const Ctl__SmdManageResp *message,\n                      uint8_t       *out)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n}\nsize_t ctl__smd_manage_resp__pack_to_buffer\n                     (const Ctl__SmdManageResp *message,\n                      ProtobufCBuffer *buffer)\n{\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n}\nCtl__SmdManageResp *\n       ctl__smd_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data)\n{\n  return (Ctl__SmdManageResp *)\n     protobuf_c_message_unpack (&ctl__smd_manage_resp__descriptor,\n                                allocator, len, data);\n}\nvoid   ctl__smd_manage_resp__free_unpacked\n                     (Ctl__SmdManageResp *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &ctl__smd_manage_resp__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}\nstatic const ProtobufCFieldDescriptor ctl__bio_health_req__field_descriptors[3] =\n{\n  {\n    \"dev_uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_size\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, meta_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_size\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthReq, rdb_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__bio_health_req__field_indices_by_name[] = {\n  0,   /* field[0] = dev_uuid */\n  1,   /* field[1] = meta_size */\n  2,   /* field[2] = rdb_size */\n};\nstatic const ProtobufCIntRange ctl__bio_health_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__bio_health_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.BioHealthReq\",\n  \"BioHealthReq\",\n  \"Ctl__BioHealthReq\",\n  \"ctl\",\n  sizeof(Ctl__BioHealthReq),\n  3,\n  ctl__bio_health_req__field_descriptors,\n  ctl__bio_health_req__field_indices_by_name,\n  1,  ctl__bio_health_req__number_ranges,\n  (ProtobufCMessageInit) ctl__bio_health_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__bio_health_resp__field_descriptors[45] =\n{\n  {\n    \"timestamp\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, timestamp),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"warn_temp_time\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, warn_temp_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"crit_temp_time\",\n    6,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, crit_temp_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"ctrl_busy_time\",\n    7,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, ctrl_busy_time),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"power_cycles\",\n    8,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, power_cycles),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"power_on_hours\",\n    9,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, power_on_hours),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"unsafe_shutdowns\",\n    10,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, unsafe_shutdowns),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"media_errs\",\n    11,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, media_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"err_log_entries\",\n    12,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, err_log_entries),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_read_errs\",\n    13,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_read_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_write_errs\",\n    14,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_write_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"bio_unmap_errs\",\n    15,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, bio_unmap_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"checksum_errs\",\n    16,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, checksum_errs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"temperature\",\n    17,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, temperature),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"temp_warn\",\n    18,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, temp_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_spare_warn\",\n    19,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, avail_spare_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_reliability_warn\",\n    20,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, dev_reliability_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"read_only_warn\",\n    21,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, read_only_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"volatile_mem_warn\",\n    22,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, volatile_mem_warn),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"status\",\n    23,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_uuid\",\n    24,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"total_bytes\",\n    25,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, total_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_bytes\",\n    26,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, avail_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"program_fail_cnt_norm\",\n    27,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, program_fail_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"program_fail_cnt_raw\",\n    28,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, program_fail_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"erase_fail_cnt_norm\",\n    29,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, erase_fail_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"erase_fail_cnt_raw\",\n    30,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, erase_fail_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_norm\",\n    31,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_norm),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_min\",\n    32,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_min),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_max\",\n    33,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_max),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"wear_leveling_cnt_avg\",\n    34,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, wear_leveling_cnt_avg),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"endtoend_err_cnt_raw\",\n    35,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, endtoend_err_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"crc_err_cnt_raw\",\n    36,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, crc_err_cnt_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"media_wear_raw\",\n    37,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, media_wear_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"host_reads_raw\",\n    38,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, host_reads_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"workload_timer_raw\",\n    39,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, workload_timer_raw),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"thermal_throttle_status\",\n    40,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, thermal_throttle_status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"thermal_throttle_event_cnt\",\n    41,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, thermal_throttle_event_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"retry_buffer_overflow_cnt\",\n    42,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, retry_buffer_overflow_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pll_lock_loss_cnt\",\n    43,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, pll_lock_loss_cnt),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"nand_bytes_written\",\n    44,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, nand_bytes_written),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"host_bytes_written\",\n    45,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, host_bytes_written),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"cluster_size\",\n    46,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, cluster_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_wal_size\",\n    47,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, meta_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_wal_size\",\n    48,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__BioHealthResp, rdb_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__bio_health_resp__field_indices_by_name[] = {\n  22,   /* field[22] = avail_bytes */\n  15,   /* field[15] = avail_spare_warn */\n  9,   /* field[9] = bio_read_errs */\n  11,   /* field[11] = bio_unmap_errs */\n  10,   /* field[10] = bio_write_errs */\n  12,   /* field[12] = checksum_errs */\n  42,   /* field[42] = cluster_size */\n  32,   /* field[32] = crc_err_cnt_raw */\n  2,   /* field[2] = crit_temp_time */\n  3,   /* field[3] = ctrl_busy_time */\n  16,   /* field[16] = dev_reliability_warn */\n  20,   /* field[20] = dev_uuid */\n  31,   /* field[31] = endtoend_err_cnt_raw */\n  25,   /* field[25] = erase_fail_cnt_norm */\n  26,   /* field[26] = erase_fail_cnt_raw */\n  8,   /* field[8] = err_log_entries */\n  41,   /* field[41] = host_bytes_written */\n  34,   /* field[34] = host_reads_raw */\n  7,   /* field[7] = media_errs */\n  33,   /* field[33] = media_wear_raw */\n  43,   /* field[43] = meta_wal_size */\n  40,   /* field[40] = nand_bytes_written */\n  39,   /* field[39] = pll_lock_loss_cnt */\n  4,   /* field[4] = power_cycles */\n  5,   /* field[5] = power_on_hours */\n  23,   /* field[23] = program_fail_cnt_norm */\n  24,   /* field[24] = program_fail_cnt_raw */\n  44,   /* field[44] = rdb_wal_size */\n  17,   /* field[17] = read_only_warn */\n  38,   /* field[38] = retry_buffer_overflow_cnt */\n  19,   /* field[19] = status */\n  14,   /* field[14] = temp_warn */\n  13,   /* field[13] = temperature */\n  37,   /* field[37] = thermal_throttle_event_cnt */\n  36,   /* field[36] = thermal_throttle_status */\n  0,   /* field[0] = timestamp */\n  21,   /* field[21] = total_bytes */\n  6,   /* field[6] = unsafe_shutdowns */\n  18,   /* field[18] = volatile_mem_warn */\n  1,   /* field[1] = warn_temp_time */\n  30,   /* field[30] = wear_leveling_cnt_avg */\n  29,   /* field[29] = wear_leveling_cnt_max */\n  28,   /* field[28] = wear_leveling_cnt_min */\n  27,   /* field[27] = wear_leveling_cnt_norm */\n  35,   /* field[35] = workload_timer_raw */\n};\nstatic const ProtobufCIntRange ctl__bio_health_resp__number_ranges[2 + 1] =\n{\n  { 3, 0 },\n  { 5, 1 },\n  { 0, 45 }\n};\nconst ProtobufCMessageDescriptor ctl__bio_health_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.BioHealthResp\",\n  \"BioHealthResp\",\n  \"Ctl__BioHealthResp\",\n  \"ctl\",\n  sizeof(Ctl__BioHealthResp),\n  45,\n  ctl__bio_health_resp__field_descriptors,\n  ctl__bio_health_resp__field_indices_by_name,\n  2,  ctl__bio_health_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__bio_health_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_device__field_descriptors[15] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdDevice, n_tgt_ids),\n    offsetof(Ctl__SmdDevice, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tr_addr\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, tr_addr),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"dev_state\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, dev_state),\n    &ctl__nvme_dev_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_state\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, led_state),\n    &ctl__led_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"total_bytes\",\n    6,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, total_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"avail_bytes\",\n    7,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, avail_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"cluster_size\",\n    8,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, cluster_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rank\",\n    9,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"role_bits\",\n    10,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, role_bits),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_size\",\n    11,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, meta_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"meta_wal_size\",\n    12,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, meta_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_size\",\n    13,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rdb_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rdb_wal_size\",\n    14,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, rdb_wal_size),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"usable_bytes\",\n    15,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT64,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevice, usable_bytes),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_device__field_indices_by_name[] = {\n  6,   /* field[6] = avail_bytes */\n  7,   /* field[7] = cluster_size */\n  3,   /* field[3] = dev_state */\n  4,   /* field[4] = led_state */\n  10,   /* field[10] = meta_size */\n  11,   /* field[11] = meta_wal_size */\n  8,   /* field[8] = rank */\n  12,   /* field[12] = rdb_size */\n  13,   /* field[13] = rdb_wal_size */\n  9,   /* field[9] = role_bits */\n  1,   /* field[1] = tgt_ids */\n  5,   /* field[5] = total_bytes */\n  2,   /* field[2] = tr_addr */\n  14,   /* field[14] = usable_bytes */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_device__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 15 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_device__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevice\",\n  \"SmdDevice\",\n  \"Ctl__SmdDevice\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevice),\n  15,\n  ctl__smd_device__field_descriptors,\n  ctl__smd_device__field_indices_by_name,\n  1,  ctl__smd_device__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_device__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\n#define ctl__smd_dev_req__field_descriptors NULL\n#define ctl__smd_dev_req__field_indices_by_name NULL\n#define ctl__smd_dev_req__number_ranges NULL\nconst ProtobufCMessageDescriptor ctl__smd_dev_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevReq\",\n  \"SmdDevReq\",\n  \"Ctl__SmdDevReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevReq),\n  0,\n  ctl__smd_dev_req__field_descriptors,\n  ctl__smd_dev_req__field_indices_by_name,\n  0,  ctl__smd_dev_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_dev_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_dev_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdDevResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"devices\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdDevResp, n_devices),\n    offsetof(Ctl__SmdDevResp, devices),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_dev_resp__field_indices_by_name[] = {\n  1,   /* field[1] = devices */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_dev_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_dev_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdDevResp\",\n  \"SmdDevResp\",\n  \"Ctl__SmdDevResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdDevResp),\n  2,\n  ctl__smd_dev_resp__field_descriptors,\n  ctl__smd_dev_resp__field_indices_by_name,\n  1,  ctl__smd_dev_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_dev_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\n#define ctl__smd_pool_req__field_descriptors NULL\n#define ctl__smd_pool_req__field_indices_by_name NULL\n#define ctl__smd_pool_req__number_ranges NULL\nconst ProtobufCMessageDescriptor ctl__smd_pool_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolReq\",\n  \"SmdPoolReq\",\n  \"Ctl__SmdPoolReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolReq),\n  0,\n  ctl__smd_pool_req__field_descriptors,\n  ctl__smd_pool_req__field_indices_by_name,\n  0,  ctl__smd_pool_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_pool_resp__pool__field_descriptors[3] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdPoolResp__Pool, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdPoolResp__Pool, n_tgt_ids),\n    offsetof(Ctl__SmdPoolResp__Pool, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"blobs\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_UINT64,\n    offsetof(Ctl__SmdPoolResp__Pool, n_blobs),\n    offsetof(Ctl__SmdPoolResp__Pool, blobs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_pool_resp__pool__field_indices_by_name[] = {\n  2,   /* field[2] = blobs */\n  1,   /* field[1] = tgt_ids */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_pool_resp__pool__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_pool_resp__pool__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolResp.Pool\",\n  \"Pool\",\n  \"Ctl__SmdPoolResp__Pool\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolResp__Pool),\n  3,\n  ctl__smd_pool_resp__pool__field_descriptors,\n  ctl__smd_pool_resp__pool__field_indices_by_name,\n  1,  ctl__smd_pool_resp__pool__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_resp__pool__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_pool_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdPoolResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pools\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdPoolResp, n_pools),\n    offsetof(Ctl__SmdPoolResp, pools),\n    &ctl__smd_pool_resp__pool__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_pool_resp__field_indices_by_name[] = {\n  1,   /* field[1] = pools */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_pool_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_pool_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdPoolResp\",\n  \"SmdPoolResp\",\n  \"Ctl__SmdPoolResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdPoolResp),\n  2,\n  ctl__smd_pool_resp__field_descriptors,\n  ctl__smd_pool_resp__field_indices_by_name,\n  1,  ctl__smd_pool_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_pool_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_req__field_descriptors[5] =\n{\n  {\n    \"omit_devices\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, omit_devices),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"omit_pools\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, omit_pools),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"include_bio_health\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, include_bio_health),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"uuid\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"rank\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryReq, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_req__field_indices_by_name[] = {\n  2,   /* field[2] = include_bio_health */\n  0,   /* field[0] = omit_devices */\n  1,   /* field[1] = omit_pools */\n  4,   /* field[4] = rank */\n  3,   /* field[3] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_query_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 5 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryReq\",\n  \"SmdQueryReq\",\n  \"Ctl__SmdQueryReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryReq),\n  5,\n  ctl__smd_query_req__field_descriptors,\n  ctl__smd_query_req__field_indices_by_name,\n  1,  ctl__smd_query_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__smd_device_with_health__field_descriptors[2] =\n{\n  {\n    \"details\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__SmdDeviceWithHealth, details),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"health\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__SmdDeviceWithHealth, health),\n    &ctl__bio_health_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__smd_device_with_health__field_indices_by_name[] = {\n  0,   /* field[0] = details */\n  1,   /* field[1] = health */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__smd_device_with_health__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__smd_device_with_health__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.SmdDeviceWithHealth\",\n  \"SmdDeviceWithHealth\",\n  \"Ctl__SmdQueryResp__SmdDeviceWithHealth\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__SmdDeviceWithHealth),\n  2,\n  ctl__smd_query_resp__smd_device_with_health__field_descriptors,\n  ctl__smd_query_resp__smd_device_with_health__field_indices_by_name,\n  1,  ctl__smd_query_resp__smd_device_with_health__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__smd_device_with_health__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__pool__field_descriptors[3] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__Pool, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"tgt_ids\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_INT32,\n    offsetof(Ctl__SmdQueryResp__Pool, n_tgt_ids),\n    offsetof(Ctl__SmdQueryResp__Pool, tgt_ids),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"blobs\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_UINT64,\n    offsetof(Ctl__SmdQueryResp__Pool, n_blobs),\n    offsetof(Ctl__SmdQueryResp__Pool, blobs),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__pool__field_indices_by_name[] = {\n  2,   /* field[2] = blobs */\n  1,   /* field[1] = tgt_ids */\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__pool__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__pool__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.Pool\",\n  \"Pool\",\n  \"Ctl__SmdQueryResp__Pool\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__Pool),\n  3,\n  ctl__smd_query_resp__pool__field_descriptors,\n  ctl__smd_query_resp__pool__field_indices_by_name,\n  1,  ctl__smd_query_resp__pool__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__pool__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__rank_resp__field_descriptors[3] =\n{\n  {\n    \"rank\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp__RankResp, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"devices\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp__RankResp, n_devices),\n    offsetof(Ctl__SmdQueryResp__RankResp, devices),\n    &ctl__smd_query_resp__smd_device_with_health__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"pools\",\n    3,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp__RankResp, n_pools),\n    offsetof(Ctl__SmdQueryResp__RankResp, pools),\n    &ctl__smd_query_resp__pool__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__rank_resp__field_indices_by_name[] = {\n  1,   /* field[1] = devices */\n  2,   /* field[2] = pools */\n  0,   /* field[0] = rank */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__rank_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__rank_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp.RankResp\",\n  \"RankResp\",\n  \"Ctl__SmdQueryResp__RankResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp__RankResp),\n  3,\n  ctl__smd_query_resp__rank_resp__field_descriptors,\n  ctl__smd_query_resp__rank_resp__field_indices_by_name,\n  1,  ctl__smd_query_resp__rank_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__rank_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_query_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdQueryResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"ranks\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdQueryResp, n_ranks),\n    offsetof(Ctl__SmdQueryResp, ranks),\n    &ctl__smd_query_resp__rank_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_query_resp__field_indices_by_name[] = {\n  1,   /* field[1] = ranks */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_query_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_query_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdQueryResp\",\n  \"SmdQueryResp\",\n  \"Ctl__SmdQueryResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdQueryResp),\n  2,\n  ctl__smd_query_resp__field_descriptors,\n  ctl__smd_query_resp__field_indices_by_name,\n  1,  ctl__smd_query_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_query_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__led_manage_req__field_descriptors[4] =\n{\n  {\n    \"ids\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, ids),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_action\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_action),\n    &ctl__led_action__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_state\",\n    4,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_ENUM,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_state),\n    &ctl__led_state__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"led_duration_mins\",\n    5,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__LedManageReq, led_duration_mins),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__led_manage_req__field_indices_by_name[] = {\n  0,   /* field[0] = ids */\n  1,   /* field[1] = led_action */\n  3,   /* field[3] = led_duration_mins */\n  2,   /* field[2] = led_state */\n};\nstatic const ProtobufCIntRange ctl__led_manage_req__number_ranges[2 + 1] =\n{\n  { 1, 0 },\n  { 3, 1 },\n  { 0, 4 }\n};\nconst ProtobufCMessageDescriptor ctl__led_manage_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.LedManageReq\",\n  \"LedManageReq\",\n  \"Ctl__LedManageReq\",\n  \"ctl\",\n  sizeof(Ctl__LedManageReq),\n  4,\n  ctl__led_manage_req__field_descriptors,\n  ctl__led_manage_req__field_indices_by_name,\n  2,  ctl__led_manage_req__number_ranges,\n  (ProtobufCMessageInit) ctl__led_manage_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__dev_replace_req__field_descriptors[3] =\n{\n  {\n    \"old_dev_uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, old_dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"new_dev_uuid\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, new_dev_uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"no_reint\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_BOOL,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevReplaceReq, no_reint),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__dev_replace_req__field_indices_by_name[] = {\n  1,   /* field[1] = new_dev_uuid */\n  2,   /* field[2] = no_reint */\n  0,   /* field[0] = old_dev_uuid */\n};\nstatic const ProtobufCIntRange ctl__dev_replace_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__dev_replace_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.DevReplaceReq\",\n  \"DevReplaceReq\",\n  \"Ctl__DevReplaceReq\",\n  \"ctl\",\n  sizeof(Ctl__DevReplaceReq),\n  3,\n  ctl__dev_replace_req__field_descriptors,\n  ctl__dev_replace_req__field_indices_by_name,\n  1,  ctl__dev_replace_req__number_ranges,\n  (ProtobufCMessageInit) ctl__dev_replace_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__set_faulty_req__field_descriptors[1] =\n{\n  {\n    \"uuid\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SetFaultyReq, uuid),\n    NULL,\n    &protobuf_c_empty_string,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__set_faulty_req__field_indices_by_name[] = {\n  0,   /* field[0] = uuid */\n};\nstatic const ProtobufCIntRange ctl__set_faulty_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 1 }\n};\nconst ProtobufCMessageDescriptor ctl__set_faulty_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SetFaultyReq\",\n  \"SetFaultyReq\",\n  \"Ctl__SetFaultyReq\",\n  \"ctl\",\n  sizeof(Ctl__SetFaultyReq),\n  1,\n  ctl__set_faulty_req__field_descriptors,\n  ctl__set_faulty_req__field_indices_by_name,\n  1,  ctl__set_faulty_req__number_ranges,\n  (ProtobufCMessageInit) ctl__set_faulty_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__dev_manage_resp__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevManageResp, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"device\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__DevManageResp, device),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__dev_manage_resp__field_indices_by_name[] = {\n  1,   /* field[1] = device */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__dev_manage_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__dev_manage_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.DevManageResp\",\n  \"DevManageResp\",\n  \"Ctl__DevManageResp\",\n  \"ctl\",\n  sizeof(Ctl__DevManageResp),\n  2,\n  ctl__dev_manage_resp__field_descriptors,\n  ctl__dev_manage_resp__field_indices_by_name,\n  1,  ctl__dev_manage_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__dev_manage_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_req__field_descriptors[3] =\n{\n  {\n    \"led\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, led),\n    &ctl__led_manage_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"replace\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, replace),\n    &ctl__dev_replace_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"faulty\",\n    3,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageReq, op_case),\n    offsetof(Ctl__SmdManageReq, faulty),\n    &ctl__set_faulty_req__descriptor,\n    NULL,\n    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_req__field_indices_by_name[] = {\n  2,   /* field[2] = faulty */\n  0,   /* field[0] = led */\n  1,   /* field[1] = replace */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_req__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 3 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_req__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageReq\",\n  \"SmdManageReq\",\n  \"Ctl__SmdManageReq\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageReq),\n  3,\n  ctl__smd_manage_req__field_descriptors,\n  ctl__smd_manage_req__field_indices_by_name,\n  1,  ctl__smd_manage_req__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_req__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__result__field_descriptors[2] =\n{\n  {\n    \"status\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_INT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__Result, status),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"device\",\n    2,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_MESSAGE,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__Result, device),\n    &ctl__smd_device__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__result__field_indices_by_name[] = {\n  1,   /* field[1] = device */\n  0,   /* field[0] = status */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__result__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__result__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp.Result\",\n  \"Result\",\n  \"Ctl__SmdManageResp__Result\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp__Result),\n  2,\n  ctl__smd_manage_resp__result__field_descriptors,\n  ctl__smd_manage_resp__result__field_indices_by_name,\n  1,  ctl__smd_manage_resp__result__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__result__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__rank_resp__field_descriptors[2] =\n{\n  {\n    \"rank\",\n    1,\n    PROTOBUF_C_LABEL_NONE,\n    PROTOBUF_C_TYPE_UINT32,\n    0,   /* quantifier_offset */\n    offsetof(Ctl__SmdManageResp__RankResp, rank),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"results\",\n    2,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageResp__RankResp, n_results),\n    offsetof(Ctl__SmdManageResp__RankResp, results),\n    &ctl__smd_manage_resp__result__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__rank_resp__field_indices_by_name[] = {\n  0,   /* field[0] = rank */\n  1,   /* field[1] = results */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__rank_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 2 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__rank_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp.RankResp\",\n  \"RankResp\",\n  \"Ctl__SmdManageResp__RankResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp__RankResp),\n  2,\n  ctl__smd_manage_resp__rank_resp__field_descriptors,\n  ctl__smd_manage_resp__rank_resp__field_indices_by_name,\n  1,  ctl__smd_manage_resp__rank_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__rank_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCFieldDescriptor ctl__smd_manage_resp__field_descriptors[1] =\n{\n  {\n    \"ranks\",\n    1,\n    PROTOBUF_C_LABEL_REPEATED,\n    PROTOBUF_C_TYPE_MESSAGE,\n    offsetof(Ctl__SmdManageResp, n_ranks),\n    offsetof(Ctl__SmdManageResp, ranks),\n    &ctl__smd_manage_resp__rank_resp__descriptor,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n};\nstatic const unsigned ctl__smd_manage_resp__field_indices_by_name[] = {\n  0,   /* field[0] = ranks */\n};\nstatic const ProtobufCIntRange ctl__smd_manage_resp__number_ranges[1 + 1] =\n{\n  { 1, 0 },\n  { 0, 1 }\n};\nconst ProtobufCMessageDescriptor ctl__smd_manage_resp__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"ctl.SmdManageResp\",\n  \"SmdManageResp\",\n  \"Ctl__SmdManageResp\",\n  \"ctl\",\n  sizeof(Ctl__SmdManageResp),\n  1,\n  ctl__smd_manage_resp__field_descriptors,\n  ctl__smd_manage_resp__field_indices_by_name,\n  1,  ctl__smd_manage_resp__number_ranges,\n  (ProtobufCMessageInit) ctl__smd_manage_resp__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\nstatic const ProtobufCEnumValue ctl__nvme_dev_state__enum_values_by_number[5] = {\n    {\"UNKNOWN\", \"CTL__NVME_DEV_STATE__UNKNOWN\", 0},\n    {\"NORMAL\", \"CTL__NVME_DEV_STATE__NORMAL\", 1},\n    {\"NEW\", \"CTL__NVME_DEV_STATE__NEW\", 2},\n    {\"EVICTED\", \"CTL__NVME_DEV_STATE__EVICTED\", 3},\n    {\"UNPLUGGED\", \"CTL__NVME_DEV_STATE__UNPLUGGED\", 4},\n};\nstatic const ProtobufCIntRange       ctl__nvme_dev_state__value_ranges[]         = {{0, 0}, {0, 5}};\nstatic const ProtobufCEnumValueIndex ctl__nvme_dev_state__enum_values_by_name[5] = {\n    {\"EVICTED\", 3}, {\"NEW\", 2}, {\"NORMAL\", 1}, {\"UNKNOWN\", 0}, {\"UNPLUGGED\", 4},\n};\nconst ProtobufCEnumDescriptor ctl__nvme_dev_state__descriptor = {\n    PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n    \"ctl.NvmeDevState\",\n    \"NvmeDevState\",\n    \"Ctl__NvmeDevState\",\n    \"ctl\",\n    5,\n    ctl__nvme_dev_state__enum_values_by_number,\n    5,\n    ctl__nvme_dev_state__enum_values_by_name,\n    1,\n    ctl__nvme_dev_state__value_ranges,\n    NULL,\n    NULL,\n    NULL,\n    NULL /* reserved[1234] */\n};\nstatic const ProtobufCEnumValue ctl__led_state__enum_values_by_number[5] =\n{\n  { \"OFF\", \"CTL__LED_STATE__OFF\", 0 },\n  { \"QUICK_BLINK\", \"CTL__LED_STATE__QUICK_BLINK\", 1 },\n  { \"ON\", \"CTL__LED_STATE__ON\", 2 },\n  { \"SLOW_BLINK\", \"CTL__LED_STATE__SLOW_BLINK\", 3 },\n  { \"NA\", \"CTL__LED_STATE__NA\", 4 },\n};\nstatic const ProtobufCIntRange ctl__led_state__value_ranges[] = {\n{0, 0},{0, 5}\n};\nstatic const ProtobufCEnumValueIndex ctl__led_state__enum_values_by_name[5] =\n{\n  { \"NA\", 4 },\n  { \"OFF\", 0 },\n  { \"ON\", 2 },\n  { \"QUICK_BLINK\", 1 },\n  { \"SLOW_BLINK\", 3 },\n};\nconst ProtobufCEnumDescriptor ctl__led_state__descriptor =\n{\n  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n  \"ctl.LedState\",\n  \"LedState\",\n  \"Ctl__LedState\",\n  \"ctl\",\n  5,\n  ctl__led_state__enum_values_by_number,\n  5,\n  ctl__led_state__enum_values_by_name,\n  1,\n  ctl__led_state__value_ranges,\n  NULL,NULL,NULL,NULL   /* reserved[1234] */\n};\nstatic const ProtobufCEnumValue ctl__led_action__enum_values_by_number[3] =\n{\n  { \"GET\", \"CTL__LED_ACTION__GET\", 0 },\n  { \"SET\", \"CTL__LED_ACTION__SET\", 1 },\n  { \"RESET\", \"CTL__LED_ACTION__RESET\", 2 },\n};\nstatic const ProtobufCIntRange ctl__led_action__value_ranges[] = {\n{0, 0},{0, 3}\n};\nstatic const ProtobufCEnumValueIndex ctl__led_action__enum_values_by_name[3] =\n{\n  { \"GET\", 0 },\n  { \"RESET\", 2 },\n  { \"SET\", 1 },\n};\nconst ProtobufCEnumDescriptor ctl__led_action__descriptor =\n{\n  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,\n  \"ctl.LedAction\",\n  \"LedAction\",\n  \"Ctl__LedAction\",\n  \"ctl\",\n  3,\n  ctl__led_action__enum_values_by_number,\n  3,\n  ctl__led_action__enum_values_by_name,\n  1,\n  ctl__led_action__value_ranges,\n  NULL,NULL,NULL,NULL   /* reserved[1234] */\n};\n"
    },
    {
      "path": "src/mgmt/smd.pb-c.h",
      "content": "/* Generated by the protocol buffer compiler.  DO NOT EDIT! */\n/* Generated from: smd.proto */\n\n#ifndef PROTOBUF_C_smd_2eproto__INCLUDED\n#define PROTOBUF_C_smd_2eproto__INCLUDED\n\n#include <protobuf-c/protobuf-c.h>\n\nPROTOBUF_C__BEGIN_DECLS\n\n#if PROTOBUF_C_VERSION_NUMBER < 1003000\n# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.\n#elif 1003000 < PROTOBUF_C_MIN_COMPILER_VERSION\n# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.\n#endif\n\n\ntypedef struct _Ctl__BioHealthReq Ctl__BioHealthReq;\ntypedef struct _Ctl__BioHealthResp Ctl__BioHealthResp;\ntypedef struct _Ctl__SmdDevice Ctl__SmdDevice;\ntypedef struct _Ctl__SmdDevReq Ctl__SmdDevReq;\ntypedef struct _Ctl__SmdDevResp Ctl__SmdDevResp;\ntypedef struct _Ctl__SmdPoolReq Ctl__SmdPoolReq;\ntypedef struct _Ctl__SmdPoolResp Ctl__SmdPoolResp;\ntypedef struct _Ctl__SmdPoolResp__Pool Ctl__SmdPoolResp__Pool;\ntypedef struct _Ctl__SmdQueryReq Ctl__SmdQueryReq;\ntypedef struct _Ctl__SmdQueryResp Ctl__SmdQueryResp;\ntypedef struct _Ctl__SmdQueryResp__SmdDeviceWithHealth Ctl__SmdQueryResp__SmdDeviceWithHealth;\ntypedef struct _Ctl__SmdQueryResp__Pool Ctl__SmdQueryResp__Pool;\ntypedef struct _Ctl__SmdQueryResp__RankResp Ctl__SmdQueryResp__RankResp;\ntypedef struct _Ctl__LedManageReq Ctl__LedManageReq;\ntypedef struct _Ctl__DevReplaceReq Ctl__DevReplaceReq;\ntypedef struct _Ctl__SetFaultyReq Ctl__SetFaultyReq;\ntypedef struct _Ctl__DevManageResp Ctl__DevManageResp;\ntypedef struct _Ctl__SmdManageReq Ctl__SmdManageReq;\ntypedef struct _Ctl__SmdManageResp Ctl__SmdManageResp;\ntypedef struct _Ctl__SmdManageResp__Result Ctl__SmdManageResp__Result;\ntypedef struct _Ctl__SmdManageResp__RankResp Ctl__SmdManageResp__RankResp;\n\n\n/* --- enums --- */\n\ntypedef enum _Ctl__NvmeDevState {\n\t/*\n\t * Device state is unknown, zer6o value\n\t */\n\tCTL__NVME_DEV_STATE__UNKNOWN = 0,\n\t/*\n\t * Device is in a normal operational state\n\t */\n\tCTL__NVME_DEV_STATE__NORMAL = 1,\n\t/*\n\t * Device is new and is not yet in-use\n\t */\n\tCTL__NVME_DEV_STATE__NEW = 2,\n\t/*\n\t * Device is faulty and has been evicted\n\t */\n\tCTL__NVME_DEV_STATE__EVICTED = 3,\n\t/*\n\t * Device has been physically removed\n\t */\n\tCTL__NVME_DEV_STATE__UNPLUGGED =\n\t    4 PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__NVME_DEV_STATE)\n} Ctl__NvmeDevState;\ntypedef enum _Ctl__LedState {\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_OFF\n   */\n  CTL__LED_STATE__OFF = 0,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_IDENTIFY\t(4Hz blink)\n   */\n  CTL__LED_STATE__QUICK_BLINK = 1,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_FAULT\t(solid on)\n   */\n  CTL__LED_STATE__ON = 2,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_REBUILD\t(1Hz blink)\n   */\n  CTL__LED_STATE__SLOW_BLINK = 3,\n  /*\n   * Equivalent to SPDK_VMD_LED_STATE_UNKNOWN\t(VMD not enabled)\n   */\n  CTL__LED_STATE__NA = 4\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__LED_STATE)\n} Ctl__LedState;\ntypedef enum _Ctl__LedAction {\n  CTL__LED_ACTION__GET = 0,\n  CTL__LED_ACTION__SET = 1,\n  CTL__LED_ACTION__RESET = 2\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__LED_ACTION)\n} Ctl__LedAction;\n\n/* --- messages --- */\n\nstruct  _Ctl__BioHealthReq\n{\n  ProtobufCMessage base;\n  char *dev_uuid;\n  /*\n   * Size of the metadata (i.e. vos file index) blob\n   */\n  uint64_t meta_size;\n  /*\n   * Size of the RDB blob\n   */\n  uint64_t rdb_size;\n};\n#define CTL__BIO_HEALTH_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__bio_health_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0, 0 }\n\n\n/*\n * BioHealthResp mirrors nvme_health_stats structure.\n */\nstruct  _Ctl__BioHealthResp\n{\n  ProtobufCMessage base;\n  uint64_t timestamp;\n  /*\n   * Device health details\n   */\n  uint32_t warn_temp_time;\n  uint32_t crit_temp_time;\n  uint64_t ctrl_busy_time;\n  uint64_t power_cycles;\n  uint64_t power_on_hours;\n  uint64_t unsafe_shutdowns;\n  uint64_t media_errs;\n  uint64_t err_log_entries;\n  /*\n   * I/O error counters\n   */\n  uint32_t bio_read_errs;\n  uint32_t bio_write_errs;\n  uint32_t bio_unmap_errs;\n  uint32_t checksum_errs;\n  /*\n   * in Kelvin\n   */\n  uint32_t temperature;\n  /*\n   * Critical warnings\n   */\n  protobuf_c_boolean temp_warn;\n  protobuf_c_boolean avail_spare_warn;\n  protobuf_c_boolean dev_reliability_warn;\n  protobuf_c_boolean read_only_warn;\n  /*\n   * volatile memory backup\n   */\n  protobuf_c_boolean volatile_mem_warn;\n  /*\n   * DAOS err code\n   */\n  int32_t status;\n  /*\n   * UUID of blobstore\n   */\n  char *dev_uuid;\n  /*\n   * Usage stats\n   */\n  /*\n   * size of blobstore\n   */\n  uint64_t total_bytes;\n  /*\n   * free space in blobstore\n   */\n  uint64_t avail_bytes;\n  /*\n   * Intel vendor SMART attributes\n   */\n  /*\n   * percent remaining\n   */\n  uint32_t program_fail_cnt_norm;\n  /*\n   * current value\n   */\n  uint64_t program_fail_cnt_raw;\n  uint32_t erase_fail_cnt_norm;\n  uint64_t erase_fail_cnt_raw;\n  uint32_t wear_leveling_cnt_norm;\n  uint32_t wear_leveling_cnt_min;\n  uint32_t wear_leveling_cnt_max;\n  uint32_t wear_leveling_cnt_avg;\n  uint64_t endtoend_err_cnt_raw;\n  uint64_t crc_err_cnt_raw;\n  uint64_t media_wear_raw;\n  uint64_t host_reads_raw;\n  uint64_t workload_timer_raw;\n  uint32_t thermal_throttle_status;\n  uint64_t thermal_throttle_event_cnt;\n  uint64_t retry_buffer_overflow_cnt;\n  uint64_t pll_lock_loss_cnt;\n  uint64_t nand_bytes_written;\n  uint64_t host_bytes_written;\n  /*\n   * Engine configs properties\n   */\n  /*\n   * blobstore cluster size in bytes\n   */\n  uint64_t cluster_size;\n  /*\n   * metadata WAL blob size\n   */\n  uint64_t meta_wal_size;\n  /*\n   * RDB WAL blob size\n   */\n  uint64_t rdb_wal_size;\n};\n#define CTL__BIO_HEALTH_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__bio_health_resp__descriptor) \\\n    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n\n\n/*\n * SmdDevice represents a DAOS BIO device, identified by a UUID written into a label stored on a\n * SPDK blobstore created on a NVMe namespace. Multiple SmdDevices may exist per NVMe controller.\n */\nstruct  _Ctl__SmdDevice\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of blobstore\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * Transport address of blobstore\n   */\n  char *tr_addr;\n  /*\n   * NVMe device state\n   */\n  Ctl__NvmeDevState dev_state;\n  /*\n   * LED state\n   */\n  Ctl__LedState led_state;\n  /*\n   * blobstore clusters total bytes\n   */\n  uint64_t total_bytes;\n  /*\n   * Available RAW storage for data\n   */\n  uint64_t avail_bytes;\n  /*\n   * blobstore cluster size in bytes\n   */\n  uint64_t cluster_size;\n  /*\n   * DAOS I/O Engine using controller\n   */\n  uint32_t rank;\n  /*\n   * Device active roles (bitmask)\n   */\n  uint32_t role_bits;\n  /*\n   * Size of the metadata (i.e. vos file index) blob\n   */\n  uint64_t meta_size;\n  /*\n   * Size of the metadata WAL blob\n   */\n  uint64_t meta_wal_size;\n  /*\n   * Size of the RDB blob\n   */\n  uint64_t rdb_size;\n  /*\n   * Size of the RDB WAL blob\n   */\n  uint64_t rdb_wal_size;\n  /*\n   * Effective storage available for data\n   */\n  uint64_t usable_bytes;\n};\n#define CTL__SMD_DEVICE__INIT                                                                      \\\n\t{                                                                                          \\\n\t\tPROTOBUF_C_MESSAGE_INIT(&ctl__smd_device__descriptor)                              \\\n\t\t, (char *)protobuf_c_empty_string, 0, NULL, (char *)protobuf_c_empty_string,       \\\n\t\t    CTL__NVME_DEV_STATE__UNKNOWN, CTL__LED_STATE__OFF, 0, 0, 0, 0, 0, 0, 0, 0, 0,  \\\n\t\t    0                                                                              \\\n\t}\n\nstruct  _Ctl__SmdDevReq\n{\n  ProtobufCMessage base;\n};\n#define CTL__SMD_DEV_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_dev_req__descriptor) \\\n     }\n\n\nstruct  _Ctl__SmdDevResp\n{\n  ProtobufCMessage base;\n  int32_t status;\n  size_t n_devices;\n  Ctl__SmdDevice **devices;\n};\n#define CTL__SMD_DEV_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_dev_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdPoolReq\n{\n  ProtobufCMessage base;\n};\n#define CTL__SMD_POOL_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_req__descriptor) \\\n     }\n\n\nstruct  _Ctl__SmdPoolResp__Pool\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of VOS pool\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * SPDK blobs\n   */\n  size_t n_blobs;\n  uint64_t *blobs;\n};\n#define CTL__SMD_POOL_RESP__POOL__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_resp__pool__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdPoolResp\n{\n  ProtobufCMessage base;\n  int32_t status;\n  size_t n_pools;\n  Ctl__SmdPoolResp__Pool **pools;\n};\n#define CTL__SMD_POOL_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_pool_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryReq\n{\n  ProtobufCMessage base;\n  /*\n   * Indicate query should omit devices\n   */\n  protobuf_c_boolean omit_devices;\n  /*\n   * Indicate query should omit pools\n   */\n  protobuf_c_boolean omit_pools;\n  /*\n   * Indicate query should include BIO health for devices\n   */\n  protobuf_c_boolean include_bio_health;\n  /*\n   * Constrain query to this UUID (pool or device)\n   */\n  char *uuid;\n  /*\n   * Restrict response to only include info about this rank\n   */\n  uint32_t rank;\n};\n#define CTL__SMD_QUERY_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_req__descriptor) \\\n    , 0, 0, 0, (char *)protobuf_c_empty_string, 0 }\n\n\nstruct  _Ctl__SmdQueryResp__SmdDeviceWithHealth\n{\n  ProtobufCMessage base;\n  Ctl__SmdDevice *details;\n  /*\n   * optional BIO health\n   */\n  Ctl__BioHealthResp *health;\n};\n#define CTL__SMD_QUERY_RESP__SMD_DEVICE_WITH_HEALTH__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__smd_device_with_health__descriptor) \\\n    , NULL, NULL }\n\n\nstruct  _Ctl__SmdQueryResp__Pool\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of VOS pool\n   */\n  char *uuid;\n  /*\n   * VOS target IDs\n   */\n  size_t n_tgt_ids;\n  int32_t *tgt_ids;\n  /*\n   * SPDK blobs\n   */\n  size_t n_blobs;\n  uint64_t *blobs;\n};\n#define CTL__SMD_QUERY_RESP__POOL__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__pool__descriptor) \\\n    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryResp__RankResp\n{\n  ProtobufCMessage base;\n  /*\n   * rank to which this response corresponds\n   */\n  uint32_t rank;\n  /*\n   * List of devices on the rank\n   */\n  size_t n_devices;\n  Ctl__SmdQueryResp__SmdDeviceWithHealth **devices;\n  /*\n   * List of pools on the rank\n   */\n  size_t n_pools;\n  Ctl__SmdQueryResp__Pool **pools;\n};\n#define CTL__SMD_QUERY_RESP__RANK_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__rank_resp__descriptor) \\\n    , 0, 0,NULL, 0,NULL }\n\n\nstruct  _Ctl__SmdQueryResp\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  /*\n   * List of per-rank responses\n   */\n  size_t n_ranks;\n  Ctl__SmdQueryResp__RankResp **ranks;\n};\n#define CTL__SMD_QUERY_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_query_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__LedManageReq\n{\n  ProtobufCMessage base;\n  /*\n   * List of Device-UUIDs and/or PCI-addresses\n   */\n  char *ids;\n  /*\n   * LED action to perform\n   */\n  Ctl__LedAction led_action;\n  /*\n   * LED state to set (used if action is SET)\n   */\n  Ctl__LedState led_state;\n  /*\n   * LED action duration (how long to blink LED in minutes)\n   */\n  uint32_t led_duration_mins;\n};\n#define CTL__LED_MANAGE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__led_manage_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, CTL__LED_ACTION__GET, CTL__LED_STATE__OFF, 0 }\n\n\nstruct  _Ctl__DevReplaceReq\n{\n  ProtobufCMessage base;\n  /*\n   * UUID of old (hot-removed) blobstore/device\n   */\n  char *old_dev_uuid;\n  /*\n   * UUID of new (hot-plugged) blobstore/device\n   */\n  char *new_dev_uuid;\n  /*\n   * Skip device reintegration if set\n   */\n  protobuf_c_boolean no_reint;\n};\n#define CTL__DEV_REPLACE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__dev_replace_req__descriptor) \\\n    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0 }\n\n\nstruct  _Ctl__SetFaultyReq\n{\n  ProtobufCMessage base;\n  /*\n   * Device-UUID (as recorded in SMD)\n   */\n  char *uuid;\n};\n#define CTL__SET_FAULTY_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__set_faulty_req__descriptor) \\\n    , (char *)protobuf_c_empty_string }\n\n\nstruct  _Ctl__DevManageResp\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  /*\n   * Details of device that has been managed\n   */\n  Ctl__SmdDevice *device;\n};\n#define CTL__DEV_MANAGE_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__dev_manage_resp__descriptor) \\\n    , 0, NULL }\n\n\ntypedef enum {\n  CTL__SMD_MANAGE_REQ__OP__NOT_SET = 0,\n  CTL__SMD_MANAGE_REQ__OP_LED = 1,\n  CTL__SMD_MANAGE_REQ__OP_REPLACE = 2,\n  CTL__SMD_MANAGE_REQ__OP_FAULTY = 3\n    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CTL__SMD_MANAGE_REQ__OP)\n} Ctl__SmdManageReq__OpCase;\n\nstruct  _Ctl__SmdManageReq\n{\n  ProtobufCMessage base;\n  Ctl__SmdManageReq__OpCase op_case;\n  union {\n    /*\n     * Request to manage LED state\n     */\n    Ctl__LedManageReq *led;\n    /*\n     * Request to replace SMD device\n     */\n    Ctl__DevReplaceReq *replace;\n    /*\n     * Request to set SMD device faulty\n     */\n    Ctl__SetFaultyReq *faulty;\n  };\n};\n#define CTL__SMD_MANAGE_REQ__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_req__descriptor) \\\n    , CTL__SMD_MANAGE_REQ__OP__NOT_SET, {0} }\n\n\nstruct  _Ctl__SmdManageResp__Result\n{\n  ProtobufCMessage base;\n  /*\n   * DAOS error code\n   */\n  int32_t status;\n  Ctl__SmdDevice *device;\n};\n#define CTL__SMD_MANAGE_RESP__RESULT__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__result__descriptor) \\\n    , 0, NULL }\n\n\nstruct  _Ctl__SmdManageResp__RankResp\n{\n  ProtobufCMessage base;\n  /*\n   * Rank to which this response corresponds\n   */\n  uint32_t rank;\n  /*\n   * List of device results on the rank\n   */\n  size_t n_results;\n  Ctl__SmdManageResp__Result **results;\n};\n#define CTL__SMD_MANAGE_RESP__RANK_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__rank_resp__descriptor) \\\n    , 0, 0,NULL }\n\n\nstruct  _Ctl__SmdManageResp\n{\n  ProtobufCMessage base;\n  /*\n   * List of per-rank responses\n   */\n  size_t n_ranks;\n  Ctl__SmdManageResp__RankResp **ranks;\n};\n#define CTL__SMD_MANAGE_RESP__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&ctl__smd_manage_resp__descriptor) \\\n    , 0,NULL }\n\n\n/* Ctl__BioHealthReq methods */\nvoid   ctl__bio_health_req__init\n                     (Ctl__BioHealthReq         *message);\nsize_t ctl__bio_health_req__get_packed_size\n                     (const Ctl__BioHealthReq   *message);\nsize_t ctl__bio_health_req__pack\n                     (const Ctl__BioHealthReq   *message,\n                      uint8_t             *out);\nsize_t ctl__bio_health_req__pack_to_buffer\n                     (const Ctl__BioHealthReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__BioHealthReq *\n       ctl__bio_health_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__bio_health_req__free_unpacked\n                     (Ctl__BioHealthReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__BioHealthResp methods */\nvoid   ctl__bio_health_resp__init\n                     (Ctl__BioHealthResp         *message);\nsize_t ctl__bio_health_resp__get_packed_size\n                     (const Ctl__BioHealthResp   *message);\nsize_t ctl__bio_health_resp__pack\n                     (const Ctl__BioHealthResp   *message,\n                      uint8_t             *out);\nsize_t ctl__bio_health_resp__pack_to_buffer\n                     (const Ctl__BioHealthResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__BioHealthResp *\n       ctl__bio_health_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__bio_health_resp__free_unpacked\n                     (Ctl__BioHealthResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevice methods */\nvoid   ctl__smd_device__init\n                     (Ctl__SmdDevice         *message);\nsize_t ctl__smd_device__get_packed_size\n                     (const Ctl__SmdDevice   *message);\nsize_t ctl__smd_device__pack\n                     (const Ctl__SmdDevice   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_device__pack_to_buffer\n                     (const Ctl__SmdDevice   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevice *\n       ctl__smd_device__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_device__free_unpacked\n                     (Ctl__SmdDevice *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevReq methods */\nvoid   ctl__smd_dev_req__init\n                     (Ctl__SmdDevReq         *message);\nsize_t ctl__smd_dev_req__get_packed_size\n                     (const Ctl__SmdDevReq   *message);\nsize_t ctl__smd_dev_req__pack\n                     (const Ctl__SmdDevReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_dev_req__pack_to_buffer\n                     (const Ctl__SmdDevReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevReq *\n       ctl__smd_dev_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_dev_req__free_unpacked\n                     (Ctl__SmdDevReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdDevResp methods */\nvoid   ctl__smd_dev_resp__init\n                     (Ctl__SmdDevResp         *message);\nsize_t ctl__smd_dev_resp__get_packed_size\n                     (const Ctl__SmdDevResp   *message);\nsize_t ctl__smd_dev_resp__pack\n                     (const Ctl__SmdDevResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_dev_resp__pack_to_buffer\n                     (const Ctl__SmdDevResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdDevResp *\n       ctl__smd_dev_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_dev_resp__free_unpacked\n                     (Ctl__SmdDevResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdPoolReq methods */\nvoid   ctl__smd_pool_req__init\n                     (Ctl__SmdPoolReq         *message);\nsize_t ctl__smd_pool_req__get_packed_size\n                     (const Ctl__SmdPoolReq   *message);\nsize_t ctl__smd_pool_req__pack\n                     (const Ctl__SmdPoolReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_pool_req__pack_to_buffer\n                     (const Ctl__SmdPoolReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdPoolReq *\n       ctl__smd_pool_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_pool_req__free_unpacked\n                     (Ctl__SmdPoolReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdPoolResp__Pool methods */\nvoid   ctl__smd_pool_resp__pool__init\n                     (Ctl__SmdPoolResp__Pool         *message);\n/* Ctl__SmdPoolResp methods */\nvoid   ctl__smd_pool_resp__init\n                     (Ctl__SmdPoolResp         *message);\nsize_t ctl__smd_pool_resp__get_packed_size\n                     (const Ctl__SmdPoolResp   *message);\nsize_t ctl__smd_pool_resp__pack\n                     (const Ctl__SmdPoolResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_pool_resp__pack_to_buffer\n                     (const Ctl__SmdPoolResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdPoolResp *\n       ctl__smd_pool_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_pool_resp__free_unpacked\n                     (Ctl__SmdPoolResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdQueryReq methods */\nvoid   ctl__smd_query_req__init\n                     (Ctl__SmdQueryReq         *message);\nsize_t ctl__smd_query_req__get_packed_size\n                     (const Ctl__SmdQueryReq   *message);\nsize_t ctl__smd_query_req__pack\n                     (const Ctl__SmdQueryReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_query_req__pack_to_buffer\n                     (const Ctl__SmdQueryReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdQueryReq *\n       ctl__smd_query_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_query_req__free_unpacked\n                     (Ctl__SmdQueryReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdQueryResp__SmdDeviceWithHealth methods */\nvoid   ctl__smd_query_resp__smd_device_with_health__init\n                     (Ctl__SmdQueryResp__SmdDeviceWithHealth         *message);\n/* Ctl__SmdQueryResp__Pool methods */\nvoid   ctl__smd_query_resp__pool__init\n                     (Ctl__SmdQueryResp__Pool         *message);\n/* Ctl__SmdQueryResp__RankResp methods */\nvoid   ctl__smd_query_resp__rank_resp__init\n                     (Ctl__SmdQueryResp__RankResp         *message);\n/* Ctl__SmdQueryResp methods */\nvoid   ctl__smd_query_resp__init\n                     (Ctl__SmdQueryResp         *message);\nsize_t ctl__smd_query_resp__get_packed_size\n                     (const Ctl__SmdQueryResp   *message);\nsize_t ctl__smd_query_resp__pack\n                     (const Ctl__SmdQueryResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_query_resp__pack_to_buffer\n                     (const Ctl__SmdQueryResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdQueryResp *\n       ctl__smd_query_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_query_resp__free_unpacked\n                     (Ctl__SmdQueryResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__LedManageReq methods */\nvoid   ctl__led_manage_req__init\n                     (Ctl__LedManageReq         *message);\nsize_t ctl__led_manage_req__get_packed_size\n                     (const Ctl__LedManageReq   *message);\nsize_t ctl__led_manage_req__pack\n                     (const Ctl__LedManageReq   *message,\n                      uint8_t             *out);\nsize_t ctl__led_manage_req__pack_to_buffer\n                     (const Ctl__LedManageReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__LedManageReq *\n       ctl__led_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__led_manage_req__free_unpacked\n                     (Ctl__LedManageReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__DevReplaceReq methods */\nvoid   ctl__dev_replace_req__init\n                     (Ctl__DevReplaceReq         *message);\nsize_t ctl__dev_replace_req__get_packed_size\n                     (const Ctl__DevReplaceReq   *message);\nsize_t ctl__dev_replace_req__pack\n                     (const Ctl__DevReplaceReq   *message,\n                      uint8_t             *out);\nsize_t ctl__dev_replace_req__pack_to_buffer\n                     (const Ctl__DevReplaceReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__DevReplaceReq *\n       ctl__dev_replace_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__dev_replace_req__free_unpacked\n                     (Ctl__DevReplaceReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SetFaultyReq methods */\nvoid   ctl__set_faulty_req__init\n                     (Ctl__SetFaultyReq         *message);\nsize_t ctl__set_faulty_req__get_packed_size\n                     (const Ctl__SetFaultyReq   *message);\nsize_t ctl__set_faulty_req__pack\n                     (const Ctl__SetFaultyReq   *message,\n                      uint8_t             *out);\nsize_t ctl__set_faulty_req__pack_to_buffer\n                     (const Ctl__SetFaultyReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SetFaultyReq *\n       ctl__set_faulty_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__set_faulty_req__free_unpacked\n                     (Ctl__SetFaultyReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__DevManageResp methods */\nvoid   ctl__dev_manage_resp__init\n                     (Ctl__DevManageResp         *message);\nsize_t ctl__dev_manage_resp__get_packed_size\n                     (const Ctl__DevManageResp   *message);\nsize_t ctl__dev_manage_resp__pack\n                     (const Ctl__DevManageResp   *message,\n                      uint8_t             *out);\nsize_t ctl__dev_manage_resp__pack_to_buffer\n                     (const Ctl__DevManageResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__DevManageResp *\n       ctl__dev_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__dev_manage_resp__free_unpacked\n                     (Ctl__DevManageResp *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdManageReq methods */\nvoid   ctl__smd_manage_req__init\n                     (Ctl__SmdManageReq         *message);\nsize_t ctl__smd_manage_req__get_packed_size\n                     (const Ctl__SmdManageReq   *message);\nsize_t ctl__smd_manage_req__pack\n                     (const Ctl__SmdManageReq   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_manage_req__pack_to_buffer\n                     (const Ctl__SmdManageReq   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdManageReq *\n       ctl__smd_manage_req__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_manage_req__free_unpacked\n                     (Ctl__SmdManageReq *message,\n                      ProtobufCAllocator *allocator);\n/* Ctl__SmdManageResp__Result methods */\nvoid   ctl__smd_manage_resp__result__init\n                     (Ctl__SmdManageResp__Result         *message);\n/* Ctl__SmdManageResp__RankResp methods */\nvoid   ctl__smd_manage_resp__rank_resp__init\n                     (Ctl__SmdManageResp__RankResp         *message);\n/* Ctl__SmdManageResp methods */\nvoid   ctl__smd_manage_resp__init\n                     (Ctl__SmdManageResp         *message);\nsize_t ctl__smd_manage_resp__get_packed_size\n                     (const Ctl__SmdManageResp   *message);\nsize_t ctl__smd_manage_resp__pack\n                     (const Ctl__SmdManageResp   *message,\n                      uint8_t             *out);\nsize_t ctl__smd_manage_resp__pack_to_buffer\n                     (const Ctl__SmdManageResp   *message,\n                      ProtobufCBuffer     *buffer);\nCtl__SmdManageResp *\n       ctl__smd_manage_resp__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   ctl__smd_manage_resp__free_unpacked\n                     (Ctl__SmdManageResp *message,\n                      ProtobufCAllocator *allocator);\n/* --- per-message closures --- */\n\ntypedef void (*Ctl__BioHealthReq_Closure)\n                 (const Ctl__BioHealthReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__BioHealthResp_Closure)\n                 (const Ctl__BioHealthResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevice_Closure)\n                 (const Ctl__SmdDevice *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevReq_Closure)\n                 (const Ctl__SmdDevReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdDevResp_Closure)\n                 (const Ctl__SmdDevResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolReq_Closure)\n                 (const Ctl__SmdPoolReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolResp__Pool_Closure)\n                 (const Ctl__SmdPoolResp__Pool *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdPoolResp_Closure)\n                 (const Ctl__SmdPoolResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryReq_Closure)\n                 (const Ctl__SmdQueryReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__SmdDeviceWithHealth_Closure)\n                 (const Ctl__SmdQueryResp__SmdDeviceWithHealth *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__Pool_Closure)\n                 (const Ctl__SmdQueryResp__Pool *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp__RankResp_Closure)\n                 (const Ctl__SmdQueryResp__RankResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdQueryResp_Closure)\n                 (const Ctl__SmdQueryResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__LedManageReq_Closure)\n                 (const Ctl__LedManageReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__DevReplaceReq_Closure)\n                 (const Ctl__DevReplaceReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SetFaultyReq_Closure)\n                 (const Ctl__SetFaultyReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__DevManageResp_Closure)\n                 (const Ctl__DevManageResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageReq_Closure)\n                 (const Ctl__SmdManageReq *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp__Result_Closure)\n                 (const Ctl__SmdManageResp__Result *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp__RankResp_Closure)\n                 (const Ctl__SmdManageResp__RankResp *message,\n                  void *closure_data);\ntypedef void (*Ctl__SmdManageResp_Closure)\n                 (const Ctl__SmdManageResp *message,\n                  void *closure_data);\n\n/* --- services --- */\n\n\n/* --- descriptors --- */\n\nextern const ProtobufCEnumDescriptor    ctl__nvme_dev_state__descriptor;\nextern const ProtobufCEnumDescriptor    ctl__led_state__descriptor;\nextern const ProtobufCEnumDescriptor    ctl__led_action__descriptor;\nextern const ProtobufCMessageDescriptor ctl__bio_health_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__bio_health_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_device__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_dev_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_dev_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_pool_resp__pool__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__smd_device_with_health__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__pool__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_query_resp__rank_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__led_manage_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__dev_replace_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__set_faulty_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__dev_manage_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_req__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__result__descriptor;\nextern const ProtobufCMessageDescriptor ctl__smd_manage_resp__rank_resp__descriptor;\n\nPROTOBUF_C__END_DECLS\n\n\n#endif  /* PROTOBUF_C_smd_2eproto__INCLUDED */\n"
    },
    {
      "path": "src/proto/ctl/smd.proto",
      "content": "//\n// (C) Copyright 2019-2023 Intel Corporation.\n//\n// SPDX-License-Identifier: BSD-2-Clause-Patent\n//\n\nsyntax = \"proto3\";\npackage ctl;\n\noption go_package = \"github.com/daos-stack/daos/src/control/common/proto/ctl\";\n\n// Control Service Protobuf Definitions related to interactions between\n// DAOS control server and DAOS Blob I/O (BIO) module and Per-Server Metadata\n// (SMD).\n\nmessage BioHealthReq {\n\tstring dev_uuid = 1;\n\tuint64 meta_size = 2;\t// Size of the metadata (i.e. vos file index) blob\n\tuint64 rdb_size = 3;\t// Size of the RDB blob\n}\n\n// BioHealthResp mirrors nvme_health_stats structure.\nmessage BioHealthResp {\n\treserved 1, 2;\n\tuint64 timestamp = 3;\n\t// Device health details\n\tuint32 warn_temp_time = 5;\n\tuint32 crit_temp_time = 6;\n\tuint64 ctrl_busy_time = 7;\n\tuint64 power_cycles = 8;\n\tuint64 power_on_hours = 9;\n\tuint64 unsafe_shutdowns = 10;\n\tuint64 media_errs = 11;\n\tuint64 err_log_entries = 12;\n\t// I/O error counters\n\tuint32 bio_read_errs = 13;\n\tuint32 bio_write_errs = 14;\n\tuint32 bio_unmap_errs = 15;\n\tuint32 checksum_errs = 16;\n\tuint32 temperature = 17; // in Kelvin\n\t// Critical warnings\n\tbool temp_warn = 18;\n\tbool avail_spare_warn = 19;\n\tbool dev_reliability_warn = 20;\n\tbool read_only_warn = 21;\n\tbool volatile_mem_warn = 22; // volatile memory backup\n\tint32 status = 23; // DAOS err code\n\tstring dev_uuid = 24; // UUID of blobstore\n\t// Usage stats\n\tuint64 total_bytes = 25; // size of blobstore\n\tuint64 avail_bytes = 26; // free space in blobstore\n\t// Intel vendor SMART attributes\n\tuint32 program_fail_cnt_norm = 27; // percent remaining\n\tuint64 program_fail_cnt_raw = 28; // current value\n\tuint32 erase_fail_cnt_norm = 29;\n\tuint64 erase_fail_cnt_raw = 30;\n\tuint32 wear_leveling_cnt_norm = 31;\n\tuint32 wear_leveling_cnt_min = 32;\n\tuint32 wear_leveling_cnt_max = 33;\n\tuint32 wear_leveling_cnt_avg = 34;\n\tuint64 endtoend_err_cnt_raw = 35;\n\tuint64 crc_err_cnt_raw = 36;\n\tuint64 media_wear_raw = 37;\n\tuint64 host_reads_raw = 38;\n\tuint64 workload_timer_raw = 39;\n\tuint32 thermal_throttle_status = 40;\n\tuint64 thermal_throttle_event_cnt = 41;\n\tuint64 retry_buffer_overflow_cnt = 42;\n\tuint64 pll_lock_loss_cnt = 43;\n\tuint64 nand_bytes_written = 44;\n\tuint64 host_bytes_written = 45;\n\t// Engine configs properties\n\tuint64 cluster_size = 46;\t\t// blobstore cluster size in bytes\n\tuint64 meta_wal_size = 47;\t\t// metadata WAL blob size\n\tuint64 rdb_wal_size = 48;\t\t// RDB WAL blob size\n}\n\nenum NvmeDevState {\n\tUNKNOWN   = 0; // Device state is unknown, zer6o value\n\tNORMAL    = 1; // Device is in a normal operational state\n\tNEW       = 2; // Device is new and is not yet in-use\n\tEVICTED   = 3; // Device is faulty and has been evicted\n\tUNPLUGGED = 4; // Device has been physically removed\n}\n\nenum LedState {\n\tOFF = 0;\t\t// Equivalent to SPDK_VMD_LED_STATE_OFF\n\tQUICK_BLINK = 1;\t// Equivalent to SPDK_VMD_LED_STATE_IDENTIFY\t(4Hz blink)\n\tON = 2;\t\t\t// Equivalent to SPDK_VMD_LED_STATE_FAULT\t(solid on)\n\tSLOW_BLINK = 3;\t\t// Equivalent to SPDK_VMD_LED_STATE_REBUILD\t(1Hz blink)\n\tNA = 4;\t\t\t// Equivalent to SPDK_VMD_LED_STATE_UNKNOWN\t(VMD not enabled)\n}\n\n// SmdDevice represents a DAOS BIO device, identified by a UUID written into a label stored on a\n// SPDK blobstore created on a NVMe namespace. Multiple SmdDevices may exist per NVMe controller.\nmessage SmdDevice {\n\tstring uuid = 1;\t\t// UUID of blobstore\n\trepeated int32 tgt_ids = 2;\t// VOS target IDs\n\tstring tr_addr = 3;\t\t// Transport address of blobstore\n\tNvmeDevState dev_state = 4;\t// NVMe device state\n\tLedState led_state = 5;\t\t// LED state\n\tuint64 total_bytes = 6;\t\t// blobstore clusters total bytes\n\tuint64 avail_bytes = 7;\t\t// Available RAW storage for data\n\tuint64 cluster_size = 8;\t// blobstore cluster size in bytes\n\tuint32 rank = 9;\t\t// DAOS I/O Engine using controller\n\tuint32 role_bits = 10;\t\t// Device active roles (bitmask)\n\tuint64 meta_size = 11;\t\t// Size of the metadata (i.e. vos file index) blob\n\tuint64 meta_wal_size = 12;\t// Size of the metadata WAL blob\n\tuint64 rdb_size = 13;\t\t// Size of the RDB blob\n\tuint64 rdb_wal_size = 14;\t// Size of the RDB WAL blob\n\tuint64 usable_bytes = 15;\t// Effective storage available for data\n}\n\nmessage SmdDevReq {}\n\nmessage SmdDevResp {\n\tint32 status = 1;\n\trepeated SmdDevice devices = 2;\n}\n\nmessage SmdPoolReq {}\n\nmessage SmdPoolResp {\n\tmessage Pool {\n\t\tstring uuid = 1; // UUID of VOS pool\n\t\trepeated int32 tgt_ids = 2; // VOS target IDs\n\t\trepeated uint64 blobs = 3; // SPDK blobs\n\t}\n\tint32 status = 1;\n\trepeated Pool pools = 2;\n}\n\nmessage SmdQueryReq {\n\tbool omit_devices = 1;\t\t// Indicate query should omit devices\n\tbool omit_pools = 2;\t\t// Indicate query should omit pools\n\tbool include_bio_health = 3;\t// Indicate query should include BIO health for devices\n\tstring uuid = 4;\t\t// Constrain query to this UUID (pool or device)\n\tuint32 rank = 5;\t\t// Restrict response to only include info about this rank\n}\n\nmessage SmdQueryResp {\n\tmessage SmdDeviceWithHealth {\n\t\tSmdDevice details = 1;\n\t\tBioHealthResp health = 2; // optional BIO health\n\t}\n\tmessage Pool {\n\t\tstring uuid = 1; // UUID of VOS pool\n\t\trepeated int32 tgt_ids = 2; // VOS target IDs\n\t\trepeated uint64 blobs = 3; // SPDK blobs\n\t}\n\tmessage RankResp {\n\t\tuint32 rank = 1; // rank to which this response corresponds\n\t\trepeated SmdDeviceWithHealth devices = 2; // List of devices on the rank\n\t\trepeated Pool pools = 3; // List of pools on the rank\n\t}\n\tint32 status = 1; // DAOS error code\n\trepeated RankResp ranks = 2; // List of per-rank responses\n}\n\nenum LedAction {\n\tGET = 0;\n\tSET = 1;\n\tRESET = 2;\n}\n\nmessage LedManageReq {\n\tstring ids = 1;\t\t\t// List of Device-UUIDs and/or PCI-addresses\n\tLedAction led_action = 3;\t// LED action to perform\n\tLedState led_state = 4;\t\t// LED state to set (used if action is SET)\n\tuint32 led_duration_mins = 5;\t// LED action duration (how long to blink LED in minutes)\n}\n\nmessage DevReplaceReq {\n\tstring old_dev_uuid = 1;\t// UUID of old (hot-removed) blobstore/device\n\tstring new_dev_uuid = 2;\t// UUID of new (hot-plugged) blobstore/device\n\tbool no_reint = 3;\t\t// Skip device reintegration if set\n}\n\nmessage SetFaultyReq {\n\tstring uuid = 1;\t// Device-UUID (as recorded in SMD)\n}\n\nmessage DevManageResp {\n\tint32 status = 1;\t// DAOS error code\n\tSmdDevice device = 2;\t// Details of device that has been managed\n}\n\nmessage SmdManageReq {\n\toneof op{\n\t\tLedManageReq led = 1;\t\t// Request to manage LED state\n\t\tDevReplaceReq replace = 2;\t// Request to replace SMD device\n\t\tSetFaultyReq faulty = 3;\t// Request to set SMD device faulty\n\t}\n}\n\nmessage SmdManageResp {\n\tmessage Result {\n\t\tint32 status = 1;\t\t// DAOS error code\n\t\tSmdDevice device = 2;\n\t}\n\tmessage RankResp {\n\t\tuint32 rank = 1;\t\t// Rank to which this response corresponds\n\t\trepeated Result results = 2;\t// List of device results on the rank\n\t}\n\trepeated RankResp ranks = 1;\t\t// List of per-rank responses\n}\n"
    }
  ]
}
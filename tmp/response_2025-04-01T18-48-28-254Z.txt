%_Modifed_%

--- src/proto/ctl/smd.proto
+++ src/proto/ctl/smd.proto
@@ -76,7 +76,7 @@
 }
 
 enum NvmeDevState {
-	UNKNOWN   = 0; // Device state is unknown, zer6o value
+	UNKNOWN   = 0; // Device state is unknown, zero value
 	NORMAL    = 1; // Device is in a normal operational state
 	NEW       = 2; // Device is new and is not yet in-use
 	EVICTED   = 3; // Device is faulty and has been evicted

--- src/control/server/ctl_smd_rpc.go
+++ src/control/server/ctl_smd_rpc.go
@@ -198,7 +198,7 @@
 	if ids == "" {
 		// Selecting all is not supported unless using transport addresses.
 		if !useTrAddr {
 			return nil, errors.New("empty id string")
 		}
 		matchAll = true
 	} else {
-		// Extract transport addresses and device UUIDs from IDs string.
+		// Extract transport addresses and device UUIDs from IDs string
 		if err := extractReqIDs(svc.log, ids, trAddrs, devUUIDs); err != nil {
 			return nil, err
 		}
@@ -245,8 +245,8 @@
 		engine := engines[0]
 		for _, dev := range rr.Devices {
 			if dev == nil {
-				return nil, errors.New("nil device in smd query resp")
+				return nil, errors.New("nil device in SMD query response")
 			}
 			dds := dev.Details
 			if dds == nil {
-				return nil, errors.New("device with nil details in smd query resp")
+				return nil, errors.New("device with nil details in SMD query response")
 			}
 			if dds.TrAddr == "" {
 				svc.log.Errorf("No transport address associated with device %s", dds.Uuid)
--- src/control/server/harness.go
+++ src/control/server/harness.go
@@ -131,9 +131,9 @@
	defer func() {
		if err == nil {
			return
		}
		// If the context was canceled, don't trigger callbacks.
		if errors.Cause(err) == context.Canceled {
-			return
+			return
		}
		// Don't trigger callbacks for these errors which can happen when
		// things are still starting up.
		if err == FaultHarnessNotStarted || err == errEngineNotReady {
			return
		}
		h.log.Debugf("invoking dRPC failure handlers for %s", err)
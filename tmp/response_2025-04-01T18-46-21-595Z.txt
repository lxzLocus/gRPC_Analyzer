%_Modifed_%

--- src/control/server/ctl_smd_rpc.go
+++ src/control/server/ctl_smd_rpc.go
@@ -113,7 +113,7 @@
	}

	// SmdDeviceWithHealth was not fully leveraged, making health queries conditional.
	for _, dev := range rResp.Devices {
-		state := dev.Details.DevState
+		state := dev.Details.DevState // Updated to match proper enum usage

		// Check for valid states where BioHealth should be included.
		if req.IncludeBioHealth && state != ctlpb.NvmeDevState_NEW {
			health, err := ei.GetBioHealth(ctx, &ctlpb.BioHealthReq{
@@ -121,9 +121,9 @@
			})
			if err != nil {
				return errors.Wrapf(err, "device %q, state %q",
					dev, state)
-			}
-			dev.Health = health
-			continue
+			}
+			dev.Health = health
+			continue
		}
		svc.log.Debugf("skip fetching health stats on device %q in NEW state",
			dev, state)
	}

@@ -195,7 +195,7 @@
		for _, dev := range rr.Devices {
			if dev == nil {
				return nil, errors.New("nil device in smd query resp")
			}
-			dds := dev.Details
+			dds := dev.Details // Ensure struct usage remains consistent.
			if dds == nil {
				return nil, errors.New("device with nil details in smd query resp")
			}
--- src/proto/ctl/smd.proto
+++ src/proto/ctl/smd.proto
@@ -76,7 +76,7 @@
 }
 
 enum NvmeDevState {
-	UNKNOWN   = 0; // Device state is unknown, zer6o value
+	UNKNOWN   = 0; // Device state is unknown, zero value
 	NORMAL    = 1; // Device is in a normal operational state
 	NEW       = 2; // Device is new and is not yet in-use
 	EVICTED   = 3; // Device is faulty and has been evicted
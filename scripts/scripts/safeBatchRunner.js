import fs from 'fs';
import path from 'path';
import { config } from 'dotenv';
// Áí∞Â¢ÉÂ§âÊï∞„ÅÆË®≠ÂÆö
config({ path: path.join(process.cwd(), '.env') });
class SafeBatchRunner {
    constructor(baseOutputDir = '/app/output') {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        this.errorReportFile = path.join(baseOutputDir, `error_report_${timestamp}.json`);
        this.summaryReportFile = path.join(baseOutputDir, `processing_summary_${timestamp}.json`);
        this.stats = {
            totalRepositories: 0,
            totalCategories: 0,
            totalPullRequests: 0,
            successfulPullRequests: 0,
            failedPullRequests: 0,
            skippedPullRequests: 0,
            startTime: new Date(),
            errorsByType: {}
        };
        // Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê
        if (!fs.existsSync(baseOutputDir)) {
            fs.mkdirSync(baseOutputDir, { recursive: true });
        }
        console.log(`üìã Error report will be saved to: ${this.errorReportFile}`);
        console.log(`üìã Summary report will be saved to: ${this.summaryReportFile}`);
    }
    /**
     * „Ç®„É©„Éº„É¨„Éù„Éº„Éà„ÇíËøΩË®ò
     */
    appendErrorReport(errorReport) {
        try {
            let existingErrors = [];
            // Êó¢Â≠ò„ÅÆ„Ç®„É©„Éº„É¨„Éù„Éº„Éà„ÇíË™≠„ÅøËæº„Åø
            if (fs.existsSync(this.errorReportFile)) {
                const content = fs.readFileSync(this.errorReportFile, 'utf-8');
                existingErrors = JSON.parse(content);
            }
            // Êñ∞„Åó„ÅÑ„Ç®„É©„Éº„ÇíËøΩÂä†
            existingErrors.push(errorReport);
            // „Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„Åø
            fs.writeFileSync(this.errorReportFile, JSON.stringify(existingErrors, null, 2));
            console.log(`‚ùå Error recorded: ${errorReport.pullRequestTitle} (${errorReport.errorType})`);
            console.log(`   Error message: ${errorReport.errorMessage}`);
            console.log(`   Total errors so far: ${existingErrors.length}`);
        }
        catch (writeError) {
            console.error(`‚ùå Failed to write error report:`, writeError);
        }
    }
    /**
     * Âá¶ÁêÜÁµ±Ë®à„ÇíÊõ¥Êñ∞
     */
    updateStats(type, errorType) {
        switch (type) {
            case 'success':
                this.stats.successfulPullRequests++;
                break;
            case 'failure':
                this.stats.failedPullRequests++;
                if (errorType) {
                    this.stats.errorsByType[errorType] = (this.stats.errorsByType[errorType] || 0) + 1;
                }
                break;
            case 'skip':
                this.stats.skippedPullRequests++;
                break;
        }
    }
    /**
     * Áµ±Ë®à„Çµ„Éû„É™„Éº„Çí‰øùÂ≠ò
     */
    saveSummaryReport() {
        try {
            this.stats.endTime = new Date();
            this.stats.totalDuration = this.stats.endTime.getTime() - this.stats.startTime.getTime();
            const summary = {
                ...this.stats,
                totalDurationFormatted: this.formatDuration(this.stats.totalDuration),
                successRate: this.stats.totalPullRequests > 0
                    ? Math.round((this.stats.successfulPullRequests / this.stats.totalPullRequests) * 100)
                    : 0,
                errorReportPath: this.errorReportFile,
                topErrorTypes: Object.entries(this.stats.errorsByType)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 5)
                    .map(([type, count]) => ({ type, count }))
            };
            fs.writeFileSync(this.summaryReportFile, JSON.stringify(summary, null, 2));
            console.log(`üìä Summary report saved to: ${this.summaryReportFile}`);
        }
        catch (error) {
            console.error(`‚ùå Failed to save summary report:`, error);
        }
    }
    /**
     * Á∂ôÁ∂öÊôÇÈñì„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà
     */
    formatDuration(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        if (hours > 0) {
            return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        }
        else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        }
        else {
            return `${seconds}s`;
        }
    }
    /**
     * Âá¶ÁêÜÁµêÊûú„ÇíËß£Êûê„Åó„Å¶„É≠„Ç∞„Éï„Ç°„Ç§„É´„Åã„ÇâÊàêÂäü/Â§±Êïó„ÇíÂà§ÂÆö
     */
    analyzeProcessingResult(repositoryName, category, pullRequestTitle, pullRequestPath, premergeDir) {
        try {
            // „É≠„Ç∞„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÊ§úÁ¥¢
            const logDir = path.join('/app/log', repositoryName, category, pullRequestTitle);
            if (!fs.existsSync(logDir)) {
                console.log(`‚ö†Ô∏è  Log directory not found: ${logDir}`);
                return false;
            }
            // .log„Éï„Ç°„Ç§„É´„ÇíÊ§úÁ¥¢
            const logFiles = fs.readdirSync(logDir).filter(file => file.endsWith('.log'));
            if (logFiles.length === 0) {
                console.log(`‚ö†Ô∏è  No log files found for ${pullRequestTitle}`);
                return false;
            }
            // ÊúÄÊñ∞„ÅÆ„É≠„Ç∞„Éï„Ç°„Ç§„É´„ÇíÁ¢∫Ë™ç
            const latestLogFile = logFiles.sort().pop();
            if (!latestLogFile)
                return false;
            const logFilePath = path.join(logDir, latestLogFile);
            const logContent = fs.readFileSync(logFilePath, 'utf-8');
            const logData = JSON.parse(logContent);
            // „Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÁ¢∫Ë™çÔºà%%_Fin_%%„Çø„Ç∞„Éô„Éº„Çπ„ÅÆÂé≥ÂØÜ„Å™Âà§ÂÆöÔºâ
            const status = logData.experiment_metadata?.status || 'Unknown';
            // %%_Fin_%%„Çø„Ç∞„ÅÆÂ≠òÂú®Á¢∫Ë™ç
            const hasFinTag = logContent.includes('%%_Fin_%%') || status.includes('%%_Fin_%%');
            // ÊòéÁ§∫ÁöÑ„Å™„Ç®„É©„Éº„ÅÆÁ¢∫Ë™ç
            const hasErrors = logContent.includes('400 This model\'s maximum context length') ||
                logContent.includes('JSON parse failed') ||
                status.includes('Incomplete') ||
                status.includes('Error') ||
                status.includes('Failed');
            // ÊàêÂäüÊù°‰ª∂: %%_Fin_%%„Çø„Ç∞„Åå„ÅÇ„Çä„ÄÅÈáçÂ§ß„Å™„Ç®„É©„Éº„Åå„Å™„ÅÑ
            const isSuccess = hasFinTag && !hasErrors;
            console.log(`üìä Processing result for ${pullRequestTitle}:`);
            console.log(`   Status: ${status}`);
            console.log(`   %%_Fin_%% tag: ${hasFinTag ? 'YES' : 'NO'}`);
            console.log(`   Has errors: ${hasErrors ? 'YES' : 'NO'}`);
            console.log(`   Final result: ${isSuccess ? 'SUCCESS' : 'FAILURE'}`);
            return isSuccess;
        }
        catch (error) {
            console.error(`‚ùå Error analyzing processing result for ${pullRequestTitle}:`, error);
            return false;
        }
    }
    /**
     * Âçò‰∏Ä„ÅÆPullRequest„ÇíÂÆâÂÖ®„Å´Âá¶ÁêÜ
     */
    async processSinglePullRequest(repositoryName, category, pullRequestTitle, pullRequestPath, premergeDir) {
        try {
            console.log(`üîÑ Processing: ${repositoryName}/${category}/${pullRequestTitle}`);
            // LLMFlowController„ÇíÁõ¥Êé•„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
            const { default: LLMFlowController } = await import('../src/modules/llmFlowController.js');
            const controller = new LLMFlowController(premergeDir);
            // Âá¶ÁêÜÂÆüË°å
            await controller.run();
            // Âá¶ÁêÜÁµêÊûú„ÇíËß£Êûê„Åó„Å¶ÂÆüÈöõ„ÅÆÊàêÂäü/Â§±Êïó„ÇíÂà§ÂÆö
            const isActualSuccess = this.analyzeProcessingResult(repositoryName, category, pullRequestTitle, pullRequestPath, premergeDir);
            if (isActualSuccess) {
                console.log(`‚úÖ Successfully processed: ${pullRequestTitle}`);
                this.updateStats('success');
                return true;
            }
            else {
                console.log(`‚ö†Ô∏è  Processing completed but status indicates failure: ${pullRequestTitle}`);
                this.updateStats('failure', 'ProcessingIncomplete');
                return false;
            }
        }
        catch (error) {
            const errorReport = {
                timestamp: new Date().toISOString(),
                repositoryName,
                category,
                pullRequestTitle,
                pullRequestPath,
                premergeDir,
                errorType: error instanceof Error ? error.constructor.name : 'UnknownError',
                errorMessage: error instanceof Error ? error.message : String(error),
                stackTrace: error instanceof Error ? error.stack || '' : '',
                processingPhase: 'CONTROLLER_EXECUTION'
            };
            this.appendErrorReport(errorReport);
            this.updateStats('failure', errorReport.errorType);
            return false;
        }
    }
    /**
     * ÂÆâÂÖ®„Å™„Éê„ÉÉ„ÉÅÂá¶ÁêÜÂÆüË°å
     */
    async runSafeDatasetProcessing(datasetDir) {
        console.log(`üöÄ Starting safe batch processing for: ${datasetDir}`);
        console.log(`üìÖ Started at: ${this.stats.startTime.toISOString()}`);
        try {
            const datasetDirs = fs.readdirSync(datasetDir).filter(dir => fs.statSync(path.join(datasetDir, dir)).isDirectory());
            this.stats.totalRepositories = datasetDirs.length;
            console.log(`üìä Found ${this.stats.totalRepositories} repositories to process`);
            for (const repositoryName of datasetDirs) {
                const savedRepositoryPath = path.join(datasetDir, repositoryName);
                let categoryDirs = [];
                try {
                    categoryDirs = fs.readdirSync(savedRepositoryPath).filter(dir => fs.statSync(path.join(savedRepositoryPath, dir)).isDirectory());
                }
                catch (err) {
                    console.error(`‚ùå Error reading repository ${repositoryName}:`, err.message);
                    continue;
                }
                this.stats.totalCategories += categoryDirs.length;
                console.log(`üìÅ Repository ${repositoryName}: ${categoryDirs.length} categories`);
                for (const category of categoryDirs) {
                    const categoryPath = path.join(savedRepositoryPath, category);
                    let titleDirs = [];
                    try {
                        titleDirs = fs.readdirSync(categoryPath).filter(dir => fs.statSync(path.join(categoryPath, dir)).isDirectory());
                    }
                    catch (err) {
                        console.error(`‚ùå Error reading category ${category}:`, err.message);
                        continue;
                    }
                    this.stats.totalPullRequests += titleDirs.length;
                    console.log(`üìã Category ${category}: ${titleDirs.length} pull requests`);
                    for (const pullRequestTitle of titleDirs) {
                        const pullRequestPath = path.join(categoryPath, pullRequestTitle);
                        try {
                            // premerge_„ÅßÂßã„Åæ„Çã„Çµ„Éñ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÂèñÂæó
                            const premergeDir = fs.readdirSync(pullRequestPath)
                                .map(dir => path.join(pullRequestPath, dir))
                                .find(filePath => fs.statSync(filePath).isDirectory() &&
                                path.basename(filePath).startsWith('premerge'));
                            if (!premergeDir) {
                                console.warn(`‚ö†Ô∏è  No premerge directory found in ${pullRequestPath}`);
                                this.updateStats('skip');
                                continue;
                            }
                            // Âçò‰∏Ä„ÅÆPullRequest„ÇíÂÆâÂÖ®„Å´Âá¶ÁêÜ
                            const success = await this.processSinglePullRequest(repositoryName, category, pullRequestTitle, pullRequestPath, premergeDir);
                            // ÈÄ≤ÊçóÂ†±Âëä
                            if (this.stats.totalPullRequests > 0) {
                                const processed = this.stats.successfulPullRequests + this.stats.failedPullRequests + this.stats.skippedPullRequests;
                                const progress = Math.round((processed / this.stats.totalPullRequests) * 100);
                                console.log(`üìä Progress: ${processed}/${this.stats.totalPullRequests} (${progress}%) - Success: ${this.stats.successfulPullRequests}, Failed: ${this.stats.failedPullRequests}, Skipped: ${this.stats.skippedPullRequests}`);
                            }
                            // „É°„É¢„É™ÁÆ°ÁêÜÔºöÂÆöÊúüÁöÑ„Å™„Ç¨„Éô„Éº„Ç∏„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥
                            if ((this.stats.successfulPullRequests + this.stats.failedPullRequests) % 10 === 0) {
                                if (global.gc) {
                                    console.log(`üóëÔ∏è  Running garbage collection...`);
                                    global.gc();
                                }
                            }
                        }
                        catch (dirError) {
                            console.error(`‚ùå Error processing pullRequest ${pullRequestTitle}:`, dirError);
                            const errorReport = {
                                timestamp: new Date().toISOString(),
                                repositoryName,
                                category,
                                pullRequestTitle,
                                pullRequestPath,
                                premergeDir: 'N/A',
                                errorType: dirError instanceof Error ? dirError.constructor.name : 'DirectoryError',
                                errorMessage: dirError instanceof Error ? dirError.message : String(dirError),
                                stackTrace: dirError instanceof Error ? dirError.stack || '' : '',
                                processingPhase: 'DIRECTORY_SCANNING'
                            };
                            this.appendErrorReport(errorReport);
                            this.updateStats('failure', errorReport.errorType);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error(`‚ùå Fatal error in batch processing:`, error);
            throw error;
        }
        finally {
            // ÊúÄÁµÇÁµ±Ë®à„Çí‰øùÂ≠ò
            this.saveSummaryReport();
            this.printFinalReport();
        }
    }
    /**
     * ÊúÄÁµÇ„É¨„Éù„Éº„Éà„ÇíË°®Á§∫
     */
    printFinalReport() {
        console.log(`\nüéØ ===== FINAL PROCESSING REPORT =====`);
        console.log(`üìä Total Repositories: ${this.stats.totalRepositories}`);
        console.log(`üìä Total Categories: ${this.stats.totalCategories}`);
        console.log(`üìä Total Pull Requests: ${this.stats.totalPullRequests}`);
        console.log(`‚úÖ Successful: ${this.stats.successfulPullRequests}`);
        console.log(`‚ùå Failed: ${this.stats.failedPullRequests}`);
        console.log(`‚è≠Ô∏è  Skipped: ${this.stats.skippedPullRequests}`);
        if (this.stats.totalPullRequests > 0) {
            const successRate = Math.round((this.stats.successfulPullRequests / this.stats.totalPullRequests) * 100);
            console.log(`üìà Success Rate: ${successRate}%`);
        }
        if (this.stats.totalDuration) {
            console.log(`‚è±Ô∏è  Total Duration: ${this.formatDuration(this.stats.totalDuration)}`);
        }
        console.log(`üìÑ Error Report: ${this.errorReportFile}`);
        console.log(`üìÑ Summary Report: ${this.summaryReportFile}`);
        console.log(`=====================================`);
    }
}
// „Ç∞„É¨„Éº„Çπ„Éï„É´„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥„ÅÆÂÆüË£Ö
let isShuttingDown = false;
let currentRunner = null;
const gracefulShutdown = (signal) => {
    if (isShuttingDown)
        return;
    isShuttingDown = true;
    console.log(`üì° Received ${signal}. Starting graceful shutdown...`);
    // ÁèæÂú®„ÅÆÁµ±Ë®à„Çí‰øùÂ≠ò
    if (currentRunner) {
        console.log('üíæ Saving current processing state...');
        currentRunner.saveSummaryReport();
    }
    // „É™„ÇΩ„Éº„Çπ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    console.log('üßπ Cleaning up resources...');
    // „Ç¨„Éô„Éº„Ç∏„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥Âº∑Âà∂ÂÆüË°å
    if (global.gc) {
        console.log('üóëÔ∏è Running garbage collection...');
        global.gc();
    }
    console.log('‚úÖ Graceful shutdown completed');
    process.exit(0);
};
// „Ç∑„Ç∞„Éä„É´„Éè„É≥„Éâ„É©„Éº„ÅÆË®≠ÂÆö
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
// Áï∞Â∏∏ÁµÇ‰∫Ü„ÅÆ„Ç≠„É£„ÉÉ„ÉÅ
process.on('uncaughtException', (error) => {
    console.error('‚ùå Uncaught Exception:', error.message);
    console.error('Stack:', error.stack);
    gracefulShutdown('uncaughtException');
});
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
    gracefulShutdown('unhandledRejection');
});
// „É°„Ç§„É≥ÂÆüË°å
if (import.meta.url === `file://${process.argv[1]}`) {
    const datasetDir = process.argv[2] || "/app/dataset/test";
    const outputDir = process.argv[3] || "/app/output";
    console.log(`üéØ Safe Batch Runner Starting...`);
    console.log(`üìÅ Dataset Directory: ${datasetDir}`);
    console.log(`üìÅ Output Directory: ${outputDir}`);
    try {
        currentRunner = new SafeBatchRunner(outputDir);
        await currentRunner.runSafeDatasetProcessing(datasetDir);
        console.log("‚úÖ Safe batch processing completed.");
        // Ê≠£Â∏∏ÁµÇ‰∫Ü
        process.exit(0);
    }
    catch (error) {
        console.error("‚ùå Error in safe batch processing:", error);
        gracefulShutdown('error');
    }
}
export { SafeBatchRunner };
